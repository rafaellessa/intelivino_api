
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  external_id: number
  name: string
  cpf_cnpj: string | null
  market_name: string
  email: string
  phone: string | null
  whatsapp: string | null
  logo: string | null
  person_type: PersonType
  site: string | null
  social_reason: string | null
  facebook_url: string | null
  instagram_url: string | null
  banner: string | null
  gender: GenderType
  street: string
  number: string
  district: string
  country: string
  state: string
  complement: string | null
  zipcode: string
  plan_id: string | null
  created_at: Date
  updated_at: Date
  domain: string
  isActive: boolean
}

/**
 * Model AccountConfiguration
 * 
 */
export type AccountConfiguration = {
  id: string
  account_id: string
  banner_market_url: string | null
  header_color: string | null
}

/**
 * Model AccountActivities
 * 
 */
export type AccountActivities = {
  account_id: string
  activities_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Activities
 * 
 */
export type Activities = {
  id: string
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string
  email: string
  password: string
  whatsapp: string | null
  phone: string | null
  cpf_cnpj: string | null
  street: string
  number: string
  district: string
  country: string
  state: string
  complement: string | null
  city: string
  zipcode: string
  photo: string | null
  gender: GenderType
  birthdate: Date | null
  google_id: string | null
  apple_id: string | null
  facebook_id: string | null
  created_at: Date
  updated_at: Date
  lastLogin: Date
}

/**
 * Model AccountUser
 * 
 */
export type AccountUser = {
  id: string
  account_id: string
  user_id: string
  role_id: string
}

/**
 * Model Permision
 * 
 */
export type Permision = {
  id: string
  name: string
}

/**
 * Model RolePermission
 * 
 */
export type RolePermission = {
  role_id: string
  permission_id: string
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: string
  name: string
}

/**
 * Model Campaign
 * 
 */
export type Campaign = {
  id: string
  name: string
  description: string | null
  percentage_discount: number | null
  start_date: Date | null
  expiration_date: Date | null
  type_id: string
  account_id: string
  account_user_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model CampaignType
 * 
 */
export type CampaignType = {
  id: string
  name: string
  slug: string
}

/**
 * Model Coupon
 * 
 */
export type Coupon = {
  id: string
  code: string
  dicount_type: CouponDiscountType
  discount_value: number
  couponUse_type: CouponUseType
  inital_date: Date
  expiration_date: Date | null
  min_value: number | null
  max_value: number | null
  created_at: Date
  updated_at: Date
}

/**
 * Model Label
 * 
 */
export type Label = {
  id: string
  name: string
  description: string | null
  type_id: string
  country_id: string
  region_id: string
  harvest: string | null
  wine_type_id: string
  alcohol_percentage: Prisma.Decimal | null
  price: number
  promotional_price: number | null
  is_active: boolean
  stock: boolean
  created_at: Date
  updated_at: Date
}

/**
 * Model LabelCampaign
 * 
 */
export type LabelCampaign = {
  label_id: string
  campaign_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model LabelGrape
 * 
 */
export type LabelGrape = {
  label_id: string
  grape_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Grape
 * 
 */
export type Grape = {
  id: string
  name: string
  created_at: Date
  updatedAt: Date
}

/**
 * Model LabelType
 * 
 */
export type LabelType = {
  id: string
  name: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Country
 * 
 */
export type Country = {
  id: string
  name: string
  slug: string
  value: string
  created_at: Date
  updated_at: Date
}

/**
 * Model State
 * 
 */
export type State = {
  id: string
  name: string
  slug: string
  country_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model City
 * 
 */
export type City = {
  id: string
  name: string
  slug: string
  state_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Region
 * 
 */
export type Region = {
  id: string
  state_id: string
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model SubRegion
 * 
 */
export type SubRegion = {
  id: string
  name: string
  slug: string
  region_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model WineType
 * 
 */
export type WineType = {
  id: string
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: string
  code: string
  account_id: string
  total: number
  coupon_id: number | null
  created_at: Date
  updated_at: Date
}

/**
 * Model OrderLabel
 * 
 */
export type OrderLabel = {
  order_id: string
  label_id: string
  created_at: Date
  updated_at: Date
  quantity: number
}

/**
 * Model Invoice
 * 
 */
export type Invoice = {
  id: string
  order_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Device
 * 
 */
export type Device = {
  id: string
  device_physical_id: string
  platform: PlatformType
  version: string
  token_notification: string
  created_at: Date
  updated_at: Date
}

/**
 * Model DeviceUser
 * 
 */
export type DeviceUser = {
  device_id: string
  user_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Notifications
 * 
 */
export type Notifications = {
  id: string
  title: string
  message: string
  created_at: Date
  updated_at: Date
  type: TypeNotification
}

/**
 * Model EmailNotification
 * 
 */
export type EmailNotification = {
  id: string
  notification_id: string
  to: string
  from: string
  from_name: string
  cc: string | null
  bcc: string | null
  type: EmailTypeNotification
  subject: string
  body: string
  url_callback: string
  opened: string | null
  clicked: string | null
  failed: string | null
  error_description: string | null
  created_at: Date
  updated_at: Date
}

/**
 * Model SmsNotification
 * 
 */
export type SmsNotification = {
  id: string
  notification_id: string
  device_id: string
  to: string
  subject: string
  body: string
  send: string | null
  created_at: Date
  updated_at: Date
}

/**
 * Model PushNotification
 * 
 */
export type PushNotification = {
  id: string
  notification_id: string
  title: string
  subject: string
  send: string | null
  device_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model DeviceNotification
 * 
 */
export type DeviceNotification = {
  device_id: string
  notification_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Plan
 * 
 */
export type Plan = {
  id: string
  name: string
  description: string
  slug: string
  price: number
  max_users: number
  max_labels: number
  payment_cycle_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model PaymentCycle
 * 
 */
export type PaymentCycle = {
  id: string
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Subscription
 * 
 */
export type Subscription = {
  id: string
  plan_id: string
  account_id: string
  due: Date
  price: number
  created_at: Date
  updated_at: Date
}

/**
 * Model StockLabel
 * 
 */
export type StockLabel = {
  label_id: string
  account_id: string
  min_quantity: number
  max_quantity: number
}

/**
 * Model StockHistory
 * 
 */
export type StockHistory = {
  id: string
  label_id: string
  reason: string
  quantity: number
  date: Date
  created_at: Date
  updated_at: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CouponDiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  VALUE: 'VALUE'
};

export type CouponDiscountType = (typeof CouponDiscountType)[keyof typeof CouponDiscountType]


export const CouponUseType: {
  UNLIMITED: 'UNLIMITED',
  UNIQUE_BY_USER: 'UNIQUE_BY_USER',
  UNIQUE: 'UNIQUE'
};

export type CouponUseType = (typeof CouponUseType)[keyof typeof CouponUseType]


export const EmailTypeNotification: {
  html: 'html',
  text: 'text'
};

export type EmailTypeNotification = (typeof EmailTypeNotification)[keyof typeof EmailTypeNotification]


export const GenderType: {
  F: 'F',
  M: 'M',
  ND: 'ND'
};

export type GenderType = (typeof GenderType)[keyof typeof GenderType]


export const PersonType: {
  F: 'F',
  J: 'J'
};

export type PersonType = (typeof PersonType)[keyof typeof PersonType]


export const PlatformType: {
  android: 'android',
  ios: 'ios'
};

export type PlatformType = (typeof PlatformType)[keyof typeof PlatformType]


export const TypeNotification: {
  email: 'email',
  sms: 'sms',
  push: 'push'
};

export type TypeNotification = (typeof TypeNotification)[keyof typeof TypeNotification]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.accountConfiguration`: Exposes CRUD operations for the **AccountConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountConfigurations
    * const accountConfigurations = await prisma.accountConfiguration.findMany()
    * ```
    */
  get accountConfiguration(): Prisma.AccountConfigurationDelegate<GlobalReject>;

  /**
   * `prisma.accountActivities`: Exposes CRUD operations for the **AccountActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountActivities
    * const accountActivities = await prisma.accountActivities.findMany()
    * ```
    */
  get accountActivities(): Prisma.AccountActivitiesDelegate<GlobalReject>;

  /**
   * `prisma.activities`: Exposes CRUD operations for the **Activities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activities.findMany()
    * ```
    */
  get activities(): Prisma.ActivitiesDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.accountUser`: Exposes CRUD operations for the **AccountUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountUsers
    * const accountUsers = await prisma.accountUser.findMany()
    * ```
    */
  get accountUser(): Prisma.AccountUserDelegate<GlobalReject>;

  /**
   * `prisma.permision`: Exposes CRUD operations for the **Permision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permisions
    * const permisions = await prisma.permision.findMany()
    * ```
    */
  get permision(): Prisma.PermisionDelegate<GlobalReject>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<GlobalReject>;

  /**
   * `prisma.campaignType`: Exposes CRUD operations for the **CampaignType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTypes
    * const campaignTypes = await prisma.campaignType.findMany()
    * ```
    */
  get campaignType(): Prisma.CampaignTypeDelegate<GlobalReject>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<GlobalReject>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<GlobalReject>;

  /**
   * `prisma.labelCampaign`: Exposes CRUD operations for the **LabelCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabelCampaigns
    * const labelCampaigns = await prisma.labelCampaign.findMany()
    * ```
    */
  get labelCampaign(): Prisma.LabelCampaignDelegate<GlobalReject>;

  /**
   * `prisma.labelGrape`: Exposes CRUD operations for the **LabelGrape** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabelGrapes
    * const labelGrapes = await prisma.labelGrape.findMany()
    * ```
    */
  get labelGrape(): Prisma.LabelGrapeDelegate<GlobalReject>;

  /**
   * `prisma.grape`: Exposes CRUD operations for the **Grape** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grapes
    * const grapes = await prisma.grape.findMany()
    * ```
    */
  get grape(): Prisma.GrapeDelegate<GlobalReject>;

  /**
   * `prisma.labelType`: Exposes CRUD operations for the **LabelType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabelTypes
    * const labelTypes = await prisma.labelType.findMany()
    * ```
    */
  get labelType(): Prisma.LabelTypeDelegate<GlobalReject>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<GlobalReject>;

  /**
   * `prisma.subRegion`: Exposes CRUD operations for the **SubRegion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubRegions
    * const subRegions = await prisma.subRegion.findMany()
    * ```
    */
  get subRegion(): Prisma.SubRegionDelegate<GlobalReject>;

  /**
   * `prisma.wineType`: Exposes CRUD operations for the **WineType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WineTypes
    * const wineTypes = await prisma.wineType.findMany()
    * ```
    */
  get wineType(): Prisma.WineTypeDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.orderLabel`: Exposes CRUD operations for the **OrderLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderLabels
    * const orderLabels = await prisma.orderLabel.findMany()
    * ```
    */
  get orderLabel(): Prisma.OrderLabelDelegate<GlobalReject>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<GlobalReject>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<GlobalReject>;

  /**
   * `prisma.deviceUser`: Exposes CRUD operations for the **DeviceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceUsers
    * const deviceUsers = await prisma.deviceUser.findMany()
    * ```
    */
  get deviceUser(): Prisma.DeviceUserDelegate<GlobalReject>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<GlobalReject>;

  /**
   * `prisma.emailNotification`: Exposes CRUD operations for the **EmailNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailNotifications
    * const emailNotifications = await prisma.emailNotification.findMany()
    * ```
    */
  get emailNotification(): Prisma.EmailNotificationDelegate<GlobalReject>;

  /**
   * `prisma.smsNotification`: Exposes CRUD operations for the **SmsNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmsNotifications
    * const smsNotifications = await prisma.smsNotification.findMany()
    * ```
    */
  get smsNotification(): Prisma.SmsNotificationDelegate<GlobalReject>;

  /**
   * `prisma.pushNotification`: Exposes CRUD operations for the **PushNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushNotifications
    * const pushNotifications = await prisma.pushNotification.findMany()
    * ```
    */
  get pushNotification(): Prisma.PushNotificationDelegate<GlobalReject>;

  /**
   * `prisma.deviceNotification`: Exposes CRUD operations for the **DeviceNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceNotifications
    * const deviceNotifications = await prisma.deviceNotification.findMany()
    * ```
    */
  get deviceNotification(): Prisma.DeviceNotificationDelegate<GlobalReject>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<GlobalReject>;

  /**
   * `prisma.paymentCycle`: Exposes CRUD operations for the **PaymentCycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentCycles
    * const paymentCycles = await prisma.paymentCycle.findMany()
    * ```
    */
  get paymentCycle(): Prisma.PaymentCycleDelegate<GlobalReject>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.stockLabel`: Exposes CRUD operations for the **StockLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockLabels
    * const stockLabels = await prisma.stockLabel.findMany()
    * ```
    */
  get stockLabel(): Prisma.StockLabelDelegate<GlobalReject>;

  /**
   * `prisma.stockHistory`: Exposes CRUD operations for the **StockHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockHistories
    * const stockHistories = await prisma.stockHistory.findMany()
    * ```
    */
  get stockHistory(): Prisma.StockHistoryDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export type Extension = runtime.Extension 

  /**
   * Prisma Client JS version: 4.5.0
   * Query Engine version: 0362da9eebca54d94c8ef5edd3b2e90af99ba452
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Account: 'Account',
    AccountConfiguration: 'AccountConfiguration',
    AccountActivities: 'AccountActivities',
    Activities: 'Activities',
    User: 'User',
    AccountUser: 'AccountUser',
    Permision: 'Permision',
    RolePermission: 'RolePermission',
    Role: 'Role',
    Campaign: 'Campaign',
    CampaignType: 'CampaignType',
    Coupon: 'Coupon',
    Label: 'Label',
    LabelCampaign: 'LabelCampaign',
    LabelGrape: 'LabelGrape',
    Grape: 'Grape',
    LabelType: 'LabelType',
    Country: 'Country',
    State: 'State',
    City: 'City',
    Region: 'Region',
    SubRegion: 'SubRegion',
    WineType: 'WineType',
    Order: 'Order',
    OrderLabel: 'OrderLabel',
    Invoice: 'Invoice',
    Device: 'Device',
    DeviceUser: 'DeviceUser',
    Notifications: 'Notifications',
    EmailNotification: 'EmailNotification',
    SmsNotification: 'SmsNotification',
    PushNotification: 'PushNotification',
    DeviceNotification: 'DeviceNotification',
    Plan: 'Plan',
    PaymentCycle: 'PaymentCycle',
    Subscription: 'Subscription',
    StockLabel: 'StockLabel',
    StockHistory: 'StockHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */


  export type AccountCountOutputType = {
    campaign: number
    subscription: number
    order: number
    account_activities: number
    account_users: number
    StockLabel: number
  }

  export type AccountCountOutputTypeSelect = {
    campaign?: boolean
    subscription?: boolean
    order?: boolean
    account_activities?: boolean
    account_users?: boolean
    StockLabel?: boolean
  }

  export type AccountCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AccountCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AccountCountOutputType
    : S extends undefined
    ? never
    : S extends AccountCountOutputTypeArgs
    ?'include' extends U
    ? AccountCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AccountCountOutputType ? AccountCountOutputType[P] : never
  } 
    : AccountCountOutputType
  : AccountCountOutputType




  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     * 
    **/
    select?: AccountCountOutputTypeSelect | null
  }



  /**
   * Count Type ActivitiesCountOutputType
   */


  export type ActivitiesCountOutputType = {
    account_activities: number
  }

  export type ActivitiesCountOutputTypeSelect = {
    account_activities?: boolean
  }

  export type ActivitiesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ActivitiesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ActivitiesCountOutputType
    : S extends undefined
    ? never
    : S extends ActivitiesCountOutputTypeArgs
    ?'include' extends U
    ? ActivitiesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ActivitiesCountOutputType ? ActivitiesCountOutputType[P] : never
  } 
    : ActivitiesCountOutputType
  : ActivitiesCountOutputType




  // Custom InputTypes

  /**
   * ActivitiesCountOutputType without action
   */
  export type ActivitiesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ActivitiesCountOutputType
     * 
    **/
    select?: ActivitiesCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    device_user: number
    account_user: number
  }

  export type UserCountOutputTypeSelect = {
    device_user?: boolean
    account_user?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type AccountUserCountOutputType
   */


  export type AccountUserCountOutputType = {
    campaigns: number
  }

  export type AccountUserCountOutputTypeSelect = {
    campaigns?: boolean
  }

  export type AccountUserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AccountUserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AccountUserCountOutputType
    : S extends undefined
    ? never
    : S extends AccountUserCountOutputTypeArgs
    ?'include' extends U
    ? AccountUserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AccountUserCountOutputType ? AccountUserCountOutputType[P] : never
  } 
    : AccountUserCountOutputType
  : AccountUserCountOutputType




  // Custom InputTypes

  /**
   * AccountUserCountOutputType without action
   */
  export type AccountUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AccountUserCountOutputType
     * 
    **/
    select?: AccountUserCountOutputTypeSelect | null
  }



  /**
   * Count Type PermisionCountOutputType
   */


  export type PermisionCountOutputType = {
    RolePermission: number
  }

  export type PermisionCountOutputTypeSelect = {
    RolePermission?: boolean
  }

  export type PermisionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PermisionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PermisionCountOutputType
    : S extends undefined
    ? never
    : S extends PermisionCountOutputTypeArgs
    ?'include' extends U
    ? PermisionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PermisionCountOutputType ? PermisionCountOutputType[P] : never
  } 
    : PermisionCountOutputType
  : PermisionCountOutputType




  // Custom InputTypes

  /**
   * PermisionCountOutputType without action
   */
  export type PermisionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PermisionCountOutputType
     * 
    **/
    select?: PermisionCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    RolePermission: number
    AccountUser: number
  }

  export type RoleCountOutputTypeSelect = {
    RolePermission?: boolean
    AccountUser?: boolean
  }

  export type RoleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RoleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RoleCountOutputType
    : S extends undefined
    ? never
    : S extends RoleCountOutputTypeArgs
    ?'include' extends U
    ? RoleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
    : RoleCountOutputType
  : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     * 
    **/
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type CampaignCountOutputType
   */


  export type CampaignCountOutputType = {
    label_campaign: number
  }

  export type CampaignCountOutputTypeSelect = {
    label_campaign?: boolean
  }

  export type CampaignCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CampaignCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignCountOutputType
    : S extends undefined
    ? never
    : S extends CampaignCountOutputTypeArgs
    ?'include' extends U
    ? CampaignCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CampaignCountOutputType ? CampaignCountOutputType[P] : never
  } 
    : CampaignCountOutputType
  : CampaignCountOutputType




  // Custom InputTypes

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     * 
    **/
    select?: CampaignCountOutputTypeSelect | null
  }



  /**
   * Count Type CampaignTypeCountOutputType
   */


  export type CampaignTypeCountOutputType = {
    Campaign: number
  }

  export type CampaignTypeCountOutputTypeSelect = {
    Campaign?: boolean
  }

  export type CampaignTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CampaignTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignTypeCountOutputType
    : S extends undefined
    ? never
    : S extends CampaignTypeCountOutputTypeArgs
    ?'include' extends U
    ? CampaignTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CampaignTypeCountOutputType ? CampaignTypeCountOutputType[P] : never
  } 
    : CampaignTypeCountOutputType
  : CampaignTypeCountOutputType




  // Custom InputTypes

  /**
   * CampaignTypeCountOutputType without action
   */
  export type CampaignTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignTypeCountOutputType
     * 
    **/
    select?: CampaignTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type LabelCountOutputType
   */


  export type LabelCountOutputType = {
    label_grape: number
    order_label: number
    label_campaign: number
    StockLabel: number
    StockHistory: number
  }

  export type LabelCountOutputTypeSelect = {
    label_grape?: boolean
    order_label?: boolean
    label_campaign?: boolean
    StockLabel?: boolean
    StockHistory?: boolean
  }

  export type LabelCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LabelCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LabelCountOutputType
    : S extends undefined
    ? never
    : S extends LabelCountOutputTypeArgs
    ?'include' extends U
    ? LabelCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LabelCountOutputType ? LabelCountOutputType[P] : never
  } 
    : LabelCountOutputType
  : LabelCountOutputType




  // Custom InputTypes

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LabelCountOutputType
     * 
    **/
    select?: LabelCountOutputTypeSelect | null
  }



  /**
   * Count Type GrapeCountOutputType
   */


  export type GrapeCountOutputType = {
    LabelGrape: number
  }

  export type GrapeCountOutputTypeSelect = {
    LabelGrape?: boolean
  }

  export type GrapeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | GrapeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? GrapeCountOutputType
    : S extends undefined
    ? never
    : S extends GrapeCountOutputTypeArgs
    ?'include' extends U
    ? GrapeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof GrapeCountOutputType ? GrapeCountOutputType[P] : never
  } 
    : GrapeCountOutputType
  : GrapeCountOutputType




  // Custom InputTypes

  /**
   * GrapeCountOutputType without action
   */
  export type GrapeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GrapeCountOutputType
     * 
    **/
    select?: GrapeCountOutputTypeSelect | null
  }



  /**
   * Count Type LabelTypeCountOutputType
   */


  export type LabelTypeCountOutputType = {
    labels: number
  }

  export type LabelTypeCountOutputTypeSelect = {
    labels?: boolean
  }

  export type LabelTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LabelTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LabelTypeCountOutputType
    : S extends undefined
    ? never
    : S extends LabelTypeCountOutputTypeArgs
    ?'include' extends U
    ? LabelTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LabelTypeCountOutputType ? LabelTypeCountOutputType[P] : never
  } 
    : LabelTypeCountOutputType
  : LabelTypeCountOutputType




  // Custom InputTypes

  /**
   * LabelTypeCountOutputType without action
   */
  export type LabelTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LabelTypeCountOutputType
     * 
    **/
    select?: LabelTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type CountryCountOutputType
   */


  export type CountryCountOutputType = {
    states: number
    labels: number
  }

  export type CountryCountOutputTypeSelect = {
    states?: boolean
    labels?: boolean
  }

  export type CountryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CountryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CountryCountOutputType
    : S extends undefined
    ? never
    : S extends CountryCountOutputTypeArgs
    ?'include' extends U
    ? CountryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CountryCountOutputType ? CountryCountOutputType[P] : never
  } 
    : CountryCountOutputType
  : CountryCountOutputType




  // Custom InputTypes

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     * 
    **/
    select?: CountryCountOutputTypeSelect | null
  }



  /**
   * Count Type StateCountOutputType
   */


  export type StateCountOutputType = {
    regions: number
    cities: number
  }

  export type StateCountOutputTypeSelect = {
    regions?: boolean
    cities?: boolean
  }

  export type StateCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StateCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StateCountOutputType
    : S extends undefined
    ? never
    : S extends StateCountOutputTypeArgs
    ?'include' extends U
    ? StateCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StateCountOutputType ? StateCountOutputType[P] : never
  } 
    : StateCountOutputType
  : StateCountOutputType




  // Custom InputTypes

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     * 
    **/
    select?: StateCountOutputTypeSelect | null
  }



  /**
   * Count Type RegionCountOutputType
   */


  export type RegionCountOutputType = {
    subregion: number
    labels: number
  }

  export type RegionCountOutputTypeSelect = {
    subregion?: boolean
    labels?: boolean
  }

  export type RegionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RegionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RegionCountOutputType
    : S extends undefined
    ? never
    : S extends RegionCountOutputTypeArgs
    ?'include' extends U
    ? RegionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RegionCountOutputType ? RegionCountOutputType[P] : never
  } 
    : RegionCountOutputType
  : RegionCountOutputType




  // Custom InputTypes

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     * 
    **/
    select?: RegionCountOutputTypeSelect | null
  }



  /**
   * Count Type WineTypeCountOutputType
   */


  export type WineTypeCountOutputType = {
    labels: number
  }

  export type WineTypeCountOutputTypeSelect = {
    labels?: boolean
  }

  export type WineTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WineTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WineTypeCountOutputType
    : S extends undefined
    ? never
    : S extends WineTypeCountOutputTypeArgs
    ?'include' extends U
    ? WineTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WineTypeCountOutputType ? WineTypeCountOutputType[P] : never
  } 
    : WineTypeCountOutputType
  : WineTypeCountOutputType




  // Custom InputTypes

  /**
   * WineTypeCountOutputType without action
   */
  export type WineTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WineTypeCountOutputType
     * 
    **/
    select?: WineTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    order_label: number
    invoice: number
  }

  export type OrderCountOutputTypeSelect = {
    order_label?: boolean
    invoice?: boolean
  }

  export type OrderCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderCountOutputType
    : S extends undefined
    ? never
    : S extends OrderCountOutputTypeArgs
    ?'include' extends U
    ? OrderCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
    : OrderCountOutputType
  : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     * 
    **/
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type DeviceCountOutputType
   */


  export type DeviceCountOutputType = {
    device_user: number
    push_notification: number
    sms_notification: number
    device_notification: number
  }

  export type DeviceCountOutputTypeSelect = {
    device_user?: boolean
    push_notification?: boolean
    sms_notification?: boolean
    device_notification?: boolean
  }

  export type DeviceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DeviceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DeviceCountOutputType
    : S extends undefined
    ? never
    : S extends DeviceCountOutputTypeArgs
    ?'include' extends U
    ? DeviceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DeviceCountOutputType ? DeviceCountOutputType[P] : never
  } 
    : DeviceCountOutputType
  : DeviceCountOutputType




  // Custom InputTypes

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     * 
    **/
    select?: DeviceCountOutputTypeSelect | null
  }



  /**
   * Count Type NotificationsCountOutputType
   */


  export type NotificationsCountOutputType = {
    sms_notification: number
    email_notification: number
    push_notification: number
    device_notification: number
  }

  export type NotificationsCountOutputTypeSelect = {
    sms_notification?: boolean
    email_notification?: boolean
    push_notification?: boolean
    device_notification?: boolean
  }

  export type NotificationsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | NotificationsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? NotificationsCountOutputType
    : S extends undefined
    ? never
    : S extends NotificationsCountOutputTypeArgs
    ?'include' extends U
    ? NotificationsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof NotificationsCountOutputType ? NotificationsCountOutputType[P] : never
  } 
    : NotificationsCountOutputType
  : NotificationsCountOutputType




  // Custom InputTypes

  /**
   * NotificationsCountOutputType without action
   */
  export type NotificationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the NotificationsCountOutputType
     * 
    **/
    select?: NotificationsCountOutputTypeSelect | null
  }



  /**
   * Count Type PlanCountOutputType
   */


  export type PlanCountOutputType = {
    account: number
    subscription: number
  }

  export type PlanCountOutputTypeSelect = {
    account?: boolean
    subscription?: boolean
  }

  export type PlanCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlanCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlanCountOutputType
    : S extends undefined
    ? never
    : S extends PlanCountOutputTypeArgs
    ?'include' extends U
    ? PlanCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlanCountOutputType ? PlanCountOutputType[P] : never
  } 
    : PlanCountOutputType
  : PlanCountOutputType




  // Custom InputTypes

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     * 
    **/
    select?: PlanCountOutputTypeSelect | null
  }



  /**
   * Count Type PaymentCycleCountOutputType
   */


  export type PaymentCycleCountOutputType = {
    plans: number
  }

  export type PaymentCycleCountOutputTypeSelect = {
    plans?: boolean
  }

  export type PaymentCycleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PaymentCycleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PaymentCycleCountOutputType
    : S extends undefined
    ? never
    : S extends PaymentCycleCountOutputTypeArgs
    ?'include' extends U
    ? PaymentCycleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PaymentCycleCountOutputType ? PaymentCycleCountOutputType[P] : never
  } 
    : PaymentCycleCountOutputType
  : PaymentCycleCountOutputType




  // Custom InputTypes

  /**
   * PaymentCycleCountOutputType without action
   */
  export type PaymentCycleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycleCountOutputType
     * 
    **/
    select?: PaymentCycleCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    external_id: number | null
  }

  export type AccountSumAggregateOutputType = {
    external_id: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    cpf_cnpj: string | null
    market_name: string | null
    email: string | null
    phone: string | null
    whatsapp: string | null
    logo: string | null
    person_type: PersonType | null
    site: string | null
    social_reason: string | null
    facebook_url: string | null
    instagram_url: string | null
    banner: string | null
    gender: GenderType | null
    street: string | null
    number: string | null
    district: string | null
    country: string | null
    state: string | null
    complement: string | null
    zipcode: string | null
    plan_id: string | null
    created_at: Date | null
    updated_at: Date | null
    domain: string | null
    isActive: boolean | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    cpf_cnpj: string | null
    market_name: string | null
    email: string | null
    phone: string | null
    whatsapp: string | null
    logo: string | null
    person_type: PersonType | null
    site: string | null
    social_reason: string | null
    facebook_url: string | null
    instagram_url: string | null
    banner: string | null
    gender: GenderType | null
    street: string | null
    number: string | null
    district: string | null
    country: string | null
    state: string | null
    complement: string | null
    zipcode: string | null
    plan_id: string | null
    created_at: Date | null
    updated_at: Date | null
    domain: string | null
    isActive: boolean | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    cpf_cnpj: number
    market_name: number
    email: number
    phone: number
    whatsapp: number
    logo: number
    person_type: number
    site: number
    social_reason: number
    facebook_url: number
    instagram_url: number
    banner: number
    gender: number
    street: number
    number: number
    district: number
    country: number
    state: number
    complement: number
    zipcode: number
    plan_id: number
    created_at: number
    updated_at: number
    domain: number
    isActive: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    external_id?: true
  }

  export type AccountSumAggregateInputType = {
    external_id?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    cpf_cnpj?: true
    market_name?: true
    email?: true
    phone?: true
    whatsapp?: true
    logo?: true
    person_type?: true
    site?: true
    social_reason?: true
    facebook_url?: true
    instagram_url?: true
    banner?: true
    gender?: true
    street?: true
    number?: true
    district?: true
    country?: true
    state?: true
    complement?: true
    zipcode?: true
    plan_id?: true
    created_at?: true
    updated_at?: true
    domain?: true
    isActive?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    cpf_cnpj?: true
    market_name?: true
    email?: true
    phone?: true
    whatsapp?: true
    logo?: true
    person_type?: true
    site?: true
    social_reason?: true
    facebook_url?: true
    instagram_url?: true
    banner?: true
    gender?: true
    street?: true
    number?: true
    district?: true
    country?: true
    state?: true
    complement?: true
    zipcode?: true
    plan_id?: true
    created_at?: true
    updated_at?: true
    domain?: true
    isActive?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    cpf_cnpj?: true
    market_name?: true
    email?: true
    phone?: true
    whatsapp?: true
    logo?: true
    person_type?: true
    site?: true
    social_reason?: true
    facebook_url?: true
    instagram_url?: true
    banner?: true
    gender?: true
    street?: true
    number?: true
    district?: true
    country?: true
    state?: true
    complement?: true
    zipcode?: true
    plan_id?: true
    created_at?: true
    updated_at?: true
    domain?: true
    isActive?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    external_id: number
    name: string
    cpf_cnpj: string | null
    market_name: string
    email: string
    phone: string | null
    whatsapp: string | null
    logo: string | null
    person_type: PersonType
    site: string | null
    social_reason: string | null
    facebook_url: string | null
    instagram_url: string | null
    banner: string | null
    gender: GenderType
    street: string
    number: string
    district: string
    country: string
    state: string
    complement: string | null
    zipcode: string
    plan_id: string | null
    created_at: Date
    updated_at: Date
    domain: string
    isActive: boolean
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    cpf_cnpj?: boolean
    market_name?: boolean
    email?: boolean
    phone?: boolean
    whatsapp?: boolean
    logo?: boolean
    person_type?: boolean
    site?: boolean
    social_reason?: boolean
    facebook_url?: boolean
    instagram_url?: boolean
    banner?: boolean
    gender?: boolean
    campaign?: boolean | CampaignFindManyArgs
    street?: boolean
    number?: boolean
    district?: boolean
    country?: boolean
    state?: boolean
    complement?: boolean
    zipcode?: boolean
    plan_id?: boolean
    plan?: boolean | PlanArgs
    subscription?: boolean | SubscriptionFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    order?: boolean | OrderFindManyArgs
    account_activities?: boolean | AccountActivitiesFindManyArgs
    account_users?: boolean | AccountUserFindManyArgs
    domain?: boolean
    StockLabel?: boolean | StockLabelFindManyArgs
    account_configuration?: boolean | AccountConfigurationArgs
    isActive?: boolean
    _count?: boolean | AccountCountOutputTypeArgs
  }

  export type AccountInclude = {
    campaign?: boolean | CampaignFindManyArgs
    plan?: boolean | PlanArgs
    subscription?: boolean | SubscriptionFindManyArgs
    order?: boolean | OrderFindManyArgs
    account_activities?: boolean | AccountActivitiesFindManyArgs
    account_users?: boolean | AccountUserFindManyArgs
    StockLabel?: boolean | StockLabelFindManyArgs
    account_configuration?: boolean | AccountConfigurationArgs
    _count?: boolean | AccountCountOutputTypeArgs
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account  & {
    [P in TrueKeys<S['include']>]:
        P extends 'campaign' ? Array < CampaignGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'plan' ? PlanGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'order' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_users' ? Array < AccountUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'StockLabel' ? Array < StockLabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_configuration' ? AccountConfigurationGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends '_count' ? AccountCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'campaign' ? Array < CampaignGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'plan' ? PlanGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'order' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_users' ? Array < AccountUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'StockLabel' ? Array < StockLabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_configuration' ? AccountConfigurationGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends '_count' ? AccountCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Account ? Account[P] : never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find one Account that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    campaign<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>| Null>, PrismaPromise<Array<CampaignGetPayload<T>>| Null>>;

    plan<T extends PlanArgs = {}>(args?: Subset<T, PlanArgs>): CheckSelect<T, Prisma__PlanClient<Plan | Null>, Prisma__PlanClient<PlanGetPayload<T> | Null>>;

    subscription<T extends SubscriptionFindManyArgs = {}>(args?: Subset<T, SubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscription>| Null>, PrismaPromise<Array<SubscriptionGetPayload<T>>| Null>>;

    order<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    account_activities<T extends AccountActivitiesFindManyArgs = {}>(args?: Subset<T, AccountActivitiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountActivities>| Null>, PrismaPromise<Array<AccountActivitiesGetPayload<T>>| Null>>;

    account_users<T extends AccountUserFindManyArgs = {}>(args?: Subset<T, AccountUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountUser>| Null>, PrismaPromise<Array<AccountUserGetPayload<T>>| Null>>;

    StockLabel<T extends StockLabelFindManyArgs = {}>(args?: Subset<T, StockLabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StockLabel>| Null>, PrismaPromise<Array<StockLabelGetPayload<T>>| Null>>;

    account_configuration<T extends AccountConfigurationArgs = {}>(args?: Subset<T, AccountConfigurationArgs>): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration | Null>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }

  /**
   * Account: findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account: findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account: findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = AccountFindUniqueArgsBase
      

  /**
   * Account: findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = AccountFindFirstArgsBase
      

  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model AccountConfiguration
   */


  export type AggregateAccountConfiguration = {
    _count: AccountConfigurationCountAggregateOutputType | null
    _min: AccountConfigurationMinAggregateOutputType | null
    _max: AccountConfigurationMaxAggregateOutputType | null
  }

  export type AccountConfigurationMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    banner_market_url: string | null
    header_color: string | null
  }

  export type AccountConfigurationMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    banner_market_url: string | null
    header_color: string | null
  }

  export type AccountConfigurationCountAggregateOutputType = {
    id: number
    account_id: number
    banner_market_url: number
    header_color: number
    _all: number
  }


  export type AccountConfigurationMinAggregateInputType = {
    id?: true
    account_id?: true
    banner_market_url?: true
    header_color?: true
  }

  export type AccountConfigurationMaxAggregateInputType = {
    id?: true
    account_id?: true
    banner_market_url?: true
    header_color?: true
  }

  export type AccountConfigurationCountAggregateInputType = {
    id?: true
    account_id?: true
    banner_market_url?: true
    header_color?: true
    _all?: true
  }

  export type AccountConfigurationAggregateArgs = {
    /**
     * Filter which AccountConfiguration to aggregate.
     * 
    **/
    where?: AccountConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountConfigurations
    **/
    _count?: true | AccountConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountConfigurationMaxAggregateInputType
  }

  export type GetAccountConfigurationAggregateType<T extends AccountConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountConfiguration[P]>
      : GetScalarType<T[P], AggregateAccountConfiguration[P]>
  }




  export type AccountConfigurationGroupByArgs = {
    where?: AccountConfigurationWhereInput
    orderBy?: Enumerable<AccountConfigurationOrderByWithAggregationInput>
    by: Array<AccountConfigurationScalarFieldEnum>
    having?: AccountConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountConfigurationCountAggregateInputType | true
    _min?: AccountConfigurationMinAggregateInputType
    _max?: AccountConfigurationMaxAggregateInputType
  }


  export type AccountConfigurationGroupByOutputType = {
    id: string
    account_id: string
    banner_market_url: string | null
    header_color: string | null
    _count: AccountConfigurationCountAggregateOutputType | null
    _min: AccountConfigurationMinAggregateOutputType | null
    _max: AccountConfigurationMaxAggregateOutputType | null
  }

  type GetAccountConfigurationGroupByPayload<T extends AccountConfigurationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], AccountConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type AccountConfigurationSelect = {
    id?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    banner_market_url?: boolean
    header_color?: boolean
  }

  export type AccountConfigurationInclude = {
    account?: boolean | AccountArgs
  }

  export type AccountConfigurationGetPayload<
    S extends boolean | null | undefined | AccountConfigurationArgs,
    U = keyof S
      > = S extends true
        ? AccountConfiguration
    : S extends undefined
    ? never
    : S extends AccountConfigurationArgs | AccountConfigurationFindManyArgs
    ?'include' extends U
    ? AccountConfiguration  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AccountConfiguration ? AccountConfiguration[P] : never
  } 
    : AccountConfiguration
  : AccountConfiguration


  type AccountConfigurationCountArgs = Merge<
    Omit<AccountConfigurationFindManyArgs, 'select' | 'include'> & {
      select?: AccountConfigurationCountAggregateInputType | true
    }
  >

  export interface AccountConfigurationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AccountConfiguration that matches the filter.
     * @param {AccountConfigurationFindUniqueArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountConfigurationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountConfigurationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountConfiguration'> extends True ? CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration | null, null>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T> | null, null>>

    /**
     * Find the first AccountConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationFindFirstArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountConfigurationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountConfigurationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountConfiguration'> extends True ? CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration | null, null>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T> | null, null>>

    /**
     * Find zero or more AccountConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountConfigurations
     * const accountConfigurations = await prisma.accountConfiguration.findMany()
     * 
     * // Get first 10 AccountConfigurations
     * const accountConfigurations = await prisma.accountConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountConfigurationWithIdOnly = await prisma.accountConfiguration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountConfigurationFindManyArgs>(
      args?: SelectSubset<T, AccountConfigurationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountConfiguration>>, PrismaPromise<Array<AccountConfigurationGetPayload<T>>>>

    /**
     * Create a AccountConfiguration.
     * @param {AccountConfigurationCreateArgs} args - Arguments to create a AccountConfiguration.
     * @example
     * // Create one AccountConfiguration
     * const AccountConfiguration = await prisma.accountConfiguration.create({
     *   data: {
     *     // ... data to create a AccountConfiguration
     *   }
     * })
     * 
    **/
    create<T extends AccountConfigurationCreateArgs>(
      args: SelectSubset<T, AccountConfigurationCreateArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Create many AccountConfigurations.
     *     @param {AccountConfigurationCreateManyArgs} args - Arguments to create many AccountConfigurations.
     *     @example
     *     // Create many AccountConfigurations
     *     const accountConfiguration = await prisma.accountConfiguration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountConfigurationCreateManyArgs>(
      args?: SelectSubset<T, AccountConfigurationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccountConfiguration.
     * @param {AccountConfigurationDeleteArgs} args - Arguments to delete one AccountConfiguration.
     * @example
     * // Delete one AccountConfiguration
     * const AccountConfiguration = await prisma.accountConfiguration.delete({
     *   where: {
     *     // ... filter to delete one AccountConfiguration
     *   }
     * })
     * 
    **/
    delete<T extends AccountConfigurationDeleteArgs>(
      args: SelectSubset<T, AccountConfigurationDeleteArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Update one AccountConfiguration.
     * @param {AccountConfigurationUpdateArgs} args - Arguments to update one AccountConfiguration.
     * @example
     * // Update one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountConfigurationUpdateArgs>(
      args: SelectSubset<T, AccountConfigurationUpdateArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Delete zero or more AccountConfigurations.
     * @param {AccountConfigurationDeleteManyArgs} args - Arguments to filter AccountConfigurations to delete.
     * @example
     * // Delete a few AccountConfigurations
     * const { count } = await prisma.accountConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountConfigurationDeleteManyArgs>(
      args?: SelectSubset<T, AccountConfigurationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountConfigurations
     * const accountConfiguration = await prisma.accountConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountConfigurationUpdateManyArgs>(
      args: SelectSubset<T, AccountConfigurationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountConfiguration.
     * @param {AccountConfigurationUpsertArgs} args - Arguments to update or create a AccountConfiguration.
     * @example
     * // Update or create a AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.upsert({
     *   create: {
     *     // ... data to create a AccountConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountConfiguration we want to update
     *   }
     * })
    **/
    upsert<T extends AccountConfigurationUpsertArgs>(
      args: SelectSubset<T, AccountConfigurationUpsertArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Find one AccountConfiguration that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountConfigurationFindUniqueOrThrowArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountConfigurationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountConfigurationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Find the first AccountConfiguration that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationFindFirstOrThrowArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountConfigurationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountConfigurationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Count the number of AccountConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationCountArgs} args - Arguments to filter AccountConfigurations to count.
     * @example
     * // Count the number of AccountConfigurations
     * const count = await prisma.accountConfiguration.count({
     *   where: {
     *     // ... the filter for the AccountConfigurations we want to count
     *   }
     * })
    **/
    count<T extends AccountConfigurationCountArgs>(
      args?: Subset<T, AccountConfigurationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountConfigurationAggregateArgs>(args: Subset<T, AccountConfigurationAggregateArgs>): PrismaPromise<GetAccountConfigurationAggregateType<T>>

    /**
     * Group by AccountConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: AccountConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountConfigurationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountConfigurationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AccountConfiguration base type for findUnique actions
   */
  export type AccountConfigurationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter, which AccountConfiguration to fetch.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
  }

  /**
   * AccountConfiguration: findUnique
   */
  export interface AccountConfigurationFindUniqueArgs extends AccountConfigurationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountConfiguration base type for findFirst actions
   */
  export type AccountConfigurationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter, which AccountConfiguration to fetch.
     * 
    **/
    where?: AccountConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountConfigurations.
     * 
    **/
    cursor?: AccountConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountConfigurations.
     * 
    **/
    distinct?: Enumerable<AccountConfigurationScalarFieldEnum>
  }

  /**
   * AccountConfiguration: findFirst
   */
  export interface AccountConfigurationFindFirstArgs extends AccountConfigurationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountConfiguration findMany
   */
  export type AccountConfigurationFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter, which AccountConfigurations to fetch.
     * 
    **/
    where?: AccountConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountConfigurations.
     * 
    **/
    cursor?: AccountConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountConfigurations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountConfigurationScalarFieldEnum>
  }


  /**
   * AccountConfiguration create
   */
  export type AccountConfigurationCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * The data needed to create a AccountConfiguration.
     * 
    **/
    data: XOR<AccountConfigurationCreateInput, AccountConfigurationUncheckedCreateInput>
  }


  /**
   * AccountConfiguration createMany
   */
  export type AccountConfigurationCreateManyArgs = {
    /**
     * The data used to create many AccountConfigurations.
     * 
    **/
    data: Enumerable<AccountConfigurationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AccountConfiguration update
   */
  export type AccountConfigurationUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * The data needed to update a AccountConfiguration.
     * 
    **/
    data: XOR<AccountConfigurationUpdateInput, AccountConfigurationUncheckedUpdateInput>
    /**
     * Choose, which AccountConfiguration to update.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
  }


  /**
   * AccountConfiguration updateMany
   */
  export type AccountConfigurationUpdateManyArgs = {
    /**
     * The data used to update AccountConfigurations.
     * 
    **/
    data: XOR<AccountConfigurationUpdateManyMutationInput, AccountConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which AccountConfigurations to update
     * 
    **/
    where?: AccountConfigurationWhereInput
  }


  /**
   * AccountConfiguration upsert
   */
  export type AccountConfigurationUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * The filter to search for the AccountConfiguration to update in case it exists.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
    /**
     * In case the AccountConfiguration found by the `where` argument doesn't exist, create a new AccountConfiguration with this data.
     * 
    **/
    create: XOR<AccountConfigurationCreateInput, AccountConfigurationUncheckedCreateInput>
    /**
     * In case the AccountConfiguration was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountConfigurationUpdateInput, AccountConfigurationUncheckedUpdateInput>
  }


  /**
   * AccountConfiguration delete
   */
  export type AccountConfigurationDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter which AccountConfiguration to delete.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
  }


  /**
   * AccountConfiguration deleteMany
   */
  export type AccountConfigurationDeleteManyArgs = {
    /**
     * Filter which AccountConfigurations to delete
     * 
    **/
    where?: AccountConfigurationWhereInput
  }


  /**
   * AccountConfiguration: findUniqueOrThrow
   */
  export type AccountConfigurationFindUniqueOrThrowArgs = AccountConfigurationFindUniqueArgsBase
      

  /**
   * AccountConfiguration: findFirstOrThrow
   */
  export type AccountConfigurationFindFirstOrThrowArgs = AccountConfigurationFindFirstArgsBase
      

  /**
   * AccountConfiguration without action
   */
  export type AccountConfigurationArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
  }



  /**
   * Model AccountActivities
   */


  export type AggregateAccountActivities = {
    _count: AccountActivitiesCountAggregateOutputType | null
    _min: AccountActivitiesMinAggregateOutputType | null
    _max: AccountActivitiesMaxAggregateOutputType | null
  }

  export type AccountActivitiesMinAggregateOutputType = {
    account_id: string | null
    activities_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountActivitiesMaxAggregateOutputType = {
    account_id: string | null
    activities_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountActivitiesCountAggregateOutputType = {
    account_id: number
    activities_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AccountActivitiesMinAggregateInputType = {
    account_id?: true
    activities_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountActivitiesMaxAggregateInputType = {
    account_id?: true
    activities_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountActivitiesCountAggregateInputType = {
    account_id?: true
    activities_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AccountActivitiesAggregateArgs = {
    /**
     * Filter which AccountActivities to aggregate.
     * 
    **/
    where?: AccountActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountActivities
    **/
    _count?: true | AccountActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountActivitiesMaxAggregateInputType
  }

  export type GetAccountActivitiesAggregateType<T extends AccountActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountActivities[P]>
      : GetScalarType<T[P], AggregateAccountActivities[P]>
  }




  export type AccountActivitiesGroupByArgs = {
    where?: AccountActivitiesWhereInput
    orderBy?: Enumerable<AccountActivitiesOrderByWithAggregationInput>
    by: Array<AccountActivitiesScalarFieldEnum>
    having?: AccountActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountActivitiesCountAggregateInputType | true
    _min?: AccountActivitiesMinAggregateInputType
    _max?: AccountActivitiesMaxAggregateInputType
  }


  export type AccountActivitiesGroupByOutputType = {
    account_id: string
    activities_id: string
    created_at: Date
    updated_at: Date
    _count: AccountActivitiesCountAggregateOutputType | null
    _min: AccountActivitiesMinAggregateOutputType | null
    _max: AccountActivitiesMaxAggregateOutputType | null
  }

  type GetAccountActivitiesGroupByPayload<T extends AccountActivitiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AccountActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type AccountActivitiesSelect = {
    account_id?: boolean
    account?: boolean | AccountArgs
    activities_id?: boolean
    activities?: boolean | ActivitiesArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type AccountActivitiesInclude = {
    account?: boolean | AccountArgs
    activities?: boolean | ActivitiesArgs
  }

  export type AccountActivitiesGetPayload<
    S extends boolean | null | undefined | AccountActivitiesArgs,
    U = keyof S
      > = S extends true
        ? AccountActivities
    : S extends undefined
    ? never
    : S extends AccountActivitiesArgs | AccountActivitiesFindManyArgs
    ?'include' extends U
    ? AccountActivities  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'activities' ? ActivitiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'activities' ? ActivitiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AccountActivities ? AccountActivities[P] : never
  } 
    : AccountActivities
  : AccountActivities


  type AccountActivitiesCountArgs = Merge<
    Omit<AccountActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: AccountActivitiesCountAggregateInputType | true
    }
  >

  export interface AccountActivitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AccountActivities that matches the filter.
     * @param {AccountActivitiesFindUniqueArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountActivitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountActivitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountActivities'> extends True ? CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities | null, null>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T> | null, null>>

    /**
     * Find the first AccountActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesFindFirstArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountActivitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountActivitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountActivities'> extends True ? CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities | null, null>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T> | null, null>>

    /**
     * Find zero or more AccountActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountActivities
     * const accountActivities = await prisma.accountActivities.findMany()
     * 
     * // Get first 10 AccountActivities
     * const accountActivities = await prisma.accountActivities.findMany({ take: 10 })
     * 
     * // Only select the `account_id`
     * const accountActivitiesWithAccount_idOnly = await prisma.accountActivities.findMany({ select: { account_id: true } })
     * 
    **/
    findMany<T extends AccountActivitiesFindManyArgs>(
      args?: SelectSubset<T, AccountActivitiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountActivities>>, PrismaPromise<Array<AccountActivitiesGetPayload<T>>>>

    /**
     * Create a AccountActivities.
     * @param {AccountActivitiesCreateArgs} args - Arguments to create a AccountActivities.
     * @example
     * // Create one AccountActivities
     * const AccountActivities = await prisma.accountActivities.create({
     *   data: {
     *     // ... data to create a AccountActivities
     *   }
     * })
     * 
    **/
    create<T extends AccountActivitiesCreateArgs>(
      args: SelectSubset<T, AccountActivitiesCreateArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Create many AccountActivities.
     *     @param {AccountActivitiesCreateManyArgs} args - Arguments to create many AccountActivities.
     *     @example
     *     // Create many AccountActivities
     *     const accountActivities = await prisma.accountActivities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountActivitiesCreateManyArgs>(
      args?: SelectSubset<T, AccountActivitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccountActivities.
     * @param {AccountActivitiesDeleteArgs} args - Arguments to delete one AccountActivities.
     * @example
     * // Delete one AccountActivities
     * const AccountActivities = await prisma.accountActivities.delete({
     *   where: {
     *     // ... filter to delete one AccountActivities
     *   }
     * })
     * 
    **/
    delete<T extends AccountActivitiesDeleteArgs>(
      args: SelectSubset<T, AccountActivitiesDeleteArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Update one AccountActivities.
     * @param {AccountActivitiesUpdateArgs} args - Arguments to update one AccountActivities.
     * @example
     * // Update one AccountActivities
     * const accountActivities = await prisma.accountActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountActivitiesUpdateArgs>(
      args: SelectSubset<T, AccountActivitiesUpdateArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Delete zero or more AccountActivities.
     * @param {AccountActivitiesDeleteManyArgs} args - Arguments to filter AccountActivities to delete.
     * @example
     * // Delete a few AccountActivities
     * const { count } = await prisma.accountActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountActivitiesDeleteManyArgs>(
      args?: SelectSubset<T, AccountActivitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountActivities
     * const accountActivities = await prisma.accountActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountActivitiesUpdateManyArgs>(
      args: SelectSubset<T, AccountActivitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountActivities.
     * @param {AccountActivitiesUpsertArgs} args - Arguments to update or create a AccountActivities.
     * @example
     * // Update or create a AccountActivities
     * const accountActivities = await prisma.accountActivities.upsert({
     *   create: {
     *     // ... data to create a AccountActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountActivities we want to update
     *   }
     * })
    **/
    upsert<T extends AccountActivitiesUpsertArgs>(
      args: SelectSubset<T, AccountActivitiesUpsertArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Find one AccountActivities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountActivitiesFindUniqueOrThrowArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountActivitiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountActivitiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Find the first AccountActivities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesFindFirstOrThrowArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountActivitiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountActivitiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Count the number of AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesCountArgs} args - Arguments to filter AccountActivities to count.
     * @example
     * // Count the number of AccountActivities
     * const count = await prisma.accountActivities.count({
     *   where: {
     *     // ... the filter for the AccountActivities we want to count
     *   }
     * })
    **/
    count<T extends AccountActivitiesCountArgs>(
      args?: Subset<T, AccountActivitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountActivitiesAggregateArgs>(args: Subset<T, AccountActivitiesAggregateArgs>): PrismaPromise<GetAccountActivitiesAggregateType<T>>

    /**
     * Group by AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: AccountActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountActivitiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountActivitiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    activities<T extends ActivitiesArgs = {}>(args?: Subset<T, ActivitiesArgs>): CheckSelect<T, Prisma__ActivitiesClient<Activities | Null>, Prisma__ActivitiesClient<ActivitiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AccountActivities base type for findUnique actions
   */
  export type AccountActivitiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter, which AccountActivities to fetch.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
  }

  /**
   * AccountActivities: findUnique
   */
  export interface AccountActivitiesFindUniqueArgs extends AccountActivitiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountActivities base type for findFirst actions
   */
  export type AccountActivitiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter, which AccountActivities to fetch.
     * 
    **/
    where?: AccountActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountActivities.
     * 
    **/
    cursor?: AccountActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountActivities.
     * 
    **/
    distinct?: Enumerable<AccountActivitiesScalarFieldEnum>
  }

  /**
   * AccountActivities: findFirst
   */
  export interface AccountActivitiesFindFirstArgs extends AccountActivitiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountActivities findMany
   */
  export type AccountActivitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter, which AccountActivities to fetch.
     * 
    **/
    where?: AccountActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountActivities.
     * 
    **/
    cursor?: AccountActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountActivitiesScalarFieldEnum>
  }


  /**
   * AccountActivities create
   */
  export type AccountActivitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * The data needed to create a AccountActivities.
     * 
    **/
    data: XOR<AccountActivitiesCreateInput, AccountActivitiesUncheckedCreateInput>
  }


  /**
   * AccountActivities createMany
   */
  export type AccountActivitiesCreateManyArgs = {
    /**
     * The data used to create many AccountActivities.
     * 
    **/
    data: Enumerable<AccountActivitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AccountActivities update
   */
  export type AccountActivitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * The data needed to update a AccountActivities.
     * 
    **/
    data: XOR<AccountActivitiesUpdateInput, AccountActivitiesUncheckedUpdateInput>
    /**
     * Choose, which AccountActivities to update.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
  }


  /**
   * AccountActivities updateMany
   */
  export type AccountActivitiesUpdateManyArgs = {
    /**
     * The data used to update AccountActivities.
     * 
    **/
    data: XOR<AccountActivitiesUpdateManyMutationInput, AccountActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which AccountActivities to update
     * 
    **/
    where?: AccountActivitiesWhereInput
  }


  /**
   * AccountActivities upsert
   */
  export type AccountActivitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * The filter to search for the AccountActivities to update in case it exists.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
    /**
     * In case the AccountActivities found by the `where` argument doesn't exist, create a new AccountActivities with this data.
     * 
    **/
    create: XOR<AccountActivitiesCreateInput, AccountActivitiesUncheckedCreateInput>
    /**
     * In case the AccountActivities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountActivitiesUpdateInput, AccountActivitiesUncheckedUpdateInput>
  }


  /**
   * AccountActivities delete
   */
  export type AccountActivitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter which AccountActivities to delete.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
  }


  /**
   * AccountActivities deleteMany
   */
  export type AccountActivitiesDeleteManyArgs = {
    /**
     * Filter which AccountActivities to delete
     * 
    **/
    where?: AccountActivitiesWhereInput
  }


  /**
   * AccountActivities: findUniqueOrThrow
   */
  export type AccountActivitiesFindUniqueOrThrowArgs = AccountActivitiesFindUniqueArgsBase
      

  /**
   * AccountActivities: findFirstOrThrow
   */
  export type AccountActivitiesFindFirstOrThrowArgs = AccountActivitiesFindFirstArgsBase
      

  /**
   * AccountActivities without action
   */
  export type AccountActivitiesArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
  }



  /**
   * Model Activities
   */


  export type AggregateActivities = {
    _count: ActivitiesCountAggregateOutputType | null
    _min: ActivitiesMinAggregateOutputType | null
    _max: ActivitiesMaxAggregateOutputType | null
  }

  export type ActivitiesMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivitiesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivitiesCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivitiesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivitiesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivitiesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivitiesAggregateArgs = {
    /**
     * Filter which Activities to aggregate.
     * 
    **/
    where?: ActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivitiesMaxAggregateInputType
  }

  export type GetActivitiesAggregateType<T extends ActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivities[P]>
      : GetScalarType<T[P], AggregateActivities[P]>
  }




  export type ActivitiesGroupByArgs = {
    where?: ActivitiesWhereInput
    orderBy?: Enumerable<ActivitiesOrderByWithAggregationInput>
    by: Array<ActivitiesScalarFieldEnum>
    having?: ActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivitiesCountAggregateInputType | true
    _min?: ActivitiesMinAggregateInputType
    _max?: ActivitiesMaxAggregateInputType
  }


  export type ActivitiesGroupByOutputType = {
    id: string
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: ActivitiesCountAggregateOutputType | null
    _min: ActivitiesMinAggregateOutputType | null
    _max: ActivitiesMaxAggregateOutputType | null
  }

  type GetActivitiesGroupByPayload<T extends ActivitiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], ActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type ActivitiesSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_activities?: boolean | AccountActivitiesFindManyArgs
    _count?: boolean | ActivitiesCountOutputTypeArgs
  }

  export type ActivitiesInclude = {
    account_activities?: boolean | AccountActivitiesFindManyArgs
    _count?: boolean | ActivitiesCountOutputTypeArgs
  }

  export type ActivitiesGetPayload<
    S extends boolean | null | undefined | ActivitiesArgs,
    U = keyof S
      > = S extends true
        ? Activities
    : S extends undefined
    ? never
    : S extends ActivitiesArgs | ActivitiesFindManyArgs
    ?'include' extends U
    ? Activities  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ActivitiesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ActivitiesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Activities ? Activities[P] : never
  } 
    : Activities
  : Activities


  type ActivitiesCountArgs = Merge<
    Omit<ActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: ActivitiesCountAggregateInputType | true
    }
  >

  export interface ActivitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Activities that matches the filter.
     * @param {ActivitiesFindUniqueArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Activities'> extends True ? CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__ActivitiesClient<Activities | null, null>, Prisma__ActivitiesClient<ActivitiesGetPayload<T> | null, null>>

    /**
     * Find the first Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesFindFirstArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Activities'> extends True ? CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__ActivitiesClient<Activities | null, null>, Prisma__ActivitiesClient<ActivitiesGetPayload<T> | null, null>>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activities.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activitiesWithIdOnly = await prisma.activities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivitiesFindManyArgs>(
      args?: SelectSubset<T, ActivitiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Activities>>, PrismaPromise<Array<ActivitiesGetPayload<T>>>>

    /**
     * Create a Activities.
     * @param {ActivitiesCreateArgs} args - Arguments to create a Activities.
     * @example
     * // Create one Activities
     * const Activities = await prisma.activities.create({
     *   data: {
     *     // ... data to create a Activities
     *   }
     * })
     * 
    **/
    create<T extends ActivitiesCreateArgs>(
      args: SelectSubset<T, ActivitiesCreateArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Create many Activities.
     *     @param {ActivitiesCreateManyArgs} args - Arguments to create many Activities.
     *     @example
     *     // Create many Activities
     *     const activities = await prisma.activities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivitiesCreateManyArgs>(
      args?: SelectSubset<T, ActivitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Activities.
     * @param {ActivitiesDeleteArgs} args - Arguments to delete one Activities.
     * @example
     * // Delete one Activities
     * const Activities = await prisma.activities.delete({
     *   where: {
     *     // ... filter to delete one Activities
     *   }
     * })
     * 
    **/
    delete<T extends ActivitiesDeleteArgs>(
      args: SelectSubset<T, ActivitiesDeleteArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Update one Activities.
     * @param {ActivitiesUpdateArgs} args - Arguments to update one Activities.
     * @example
     * // Update one Activities
     * const activities = await prisma.activities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivitiesUpdateArgs>(
      args: SelectSubset<T, ActivitiesUpdateArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Delete zero or more Activities.
     * @param {ActivitiesDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivitiesDeleteManyArgs>(
      args?: SelectSubset<T, ActivitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activities = await prisma.activities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivitiesUpdateManyArgs>(
      args: SelectSubset<T, ActivitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Activities.
     * @param {ActivitiesUpsertArgs} args - Arguments to update or create a Activities.
     * @example
     * // Update or create a Activities
     * const activities = await prisma.activities.upsert({
     *   create: {
     *     // ... data to create a Activities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activities we want to update
     *   }
     * })
    **/
    upsert<T extends ActivitiesUpsertArgs>(
      args: SelectSubset<T, ActivitiesUpsertArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Find one Activities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ActivitiesFindUniqueOrThrowArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivitiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ActivitiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Find the first Activities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesFindFirstOrThrowArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivitiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActivitiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activities.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivitiesCountArgs>(
      args?: Subset<T, ActivitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivitiesAggregateArgs>(args: Subset<T, ActivitiesAggregateArgs>): PrismaPromise<GetActivitiesAggregateType<T>>

    /**
     * Group by Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: ActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivitiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Activities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivitiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account_activities<T extends AccountActivitiesFindManyArgs = {}>(args?: Subset<T, AccountActivitiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountActivities>| Null>, PrismaPromise<Array<AccountActivitiesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Activities base type for findUnique actions
   */
  export type ActivitiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where: ActivitiesWhereUniqueInput
  }

  /**
   * Activities: findUnique
   */
  export interface ActivitiesFindUniqueArgs extends ActivitiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activities base type for findFirst actions
   */
  export type ActivitiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where?: ActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     * 
    **/
    cursor?: ActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     * 
    **/
    distinct?: Enumerable<ActivitiesScalarFieldEnum>
  }

  /**
   * Activities: findFirst
   */
  export interface ActivitiesFindFirstArgs extends ActivitiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activities findMany
   */
  export type ActivitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where?: ActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     * 
    **/
    cursor?: ActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActivitiesScalarFieldEnum>
  }


  /**
   * Activities create
   */
  export type ActivitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * The data needed to create a Activities.
     * 
    **/
    data: XOR<ActivitiesCreateInput, ActivitiesUncheckedCreateInput>
  }


  /**
   * Activities createMany
   */
  export type ActivitiesCreateManyArgs = {
    /**
     * The data used to create many Activities.
     * 
    **/
    data: Enumerable<ActivitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Activities update
   */
  export type ActivitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * The data needed to update a Activities.
     * 
    **/
    data: XOR<ActivitiesUpdateInput, ActivitiesUncheckedUpdateInput>
    /**
     * Choose, which Activities to update.
     * 
    **/
    where: ActivitiesWhereUniqueInput
  }


  /**
   * Activities updateMany
   */
  export type ActivitiesUpdateManyArgs = {
    /**
     * The data used to update Activities.
     * 
    **/
    data: XOR<ActivitiesUpdateManyMutationInput, ActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     * 
    **/
    where?: ActivitiesWhereInput
  }


  /**
   * Activities upsert
   */
  export type ActivitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * The filter to search for the Activities to update in case it exists.
     * 
    **/
    where: ActivitiesWhereUniqueInput
    /**
     * In case the Activities found by the `where` argument doesn't exist, create a new Activities with this data.
     * 
    **/
    create: XOR<ActivitiesCreateInput, ActivitiesUncheckedCreateInput>
    /**
     * In case the Activities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActivitiesUpdateInput, ActivitiesUncheckedUpdateInput>
  }


  /**
   * Activities delete
   */
  export type ActivitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter which Activities to delete.
     * 
    **/
    where: ActivitiesWhereUniqueInput
  }


  /**
   * Activities deleteMany
   */
  export type ActivitiesDeleteManyArgs = {
    /**
     * Filter which Activities to delete
     * 
    **/
    where?: ActivitiesWhereInput
  }


  /**
   * Activities: findUniqueOrThrow
   */
  export type ActivitiesFindUniqueOrThrowArgs = ActivitiesFindUniqueArgsBase
      

  /**
   * Activities: findFirstOrThrow
   */
  export type ActivitiesFindFirstOrThrowArgs = ActivitiesFindFirstArgsBase
      

  /**
   * Activities without action
   */
  export type ActivitiesArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    whatsapp: string | null
    phone: string | null
    cpf_cnpj: string | null
    street: string | null
    number: string | null
    district: string | null
    country: string | null
    state: string | null
    complement: string | null
    city: string | null
    zipcode: string | null
    photo: string | null
    gender: GenderType | null
    birthdate: Date | null
    google_id: string | null
    apple_id: string | null
    facebook_id: string | null
    created_at: Date | null
    updated_at: Date | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    whatsapp: string | null
    phone: string | null
    cpf_cnpj: string | null
    street: string | null
    number: string | null
    district: string | null
    country: string | null
    state: string | null
    complement: string | null
    city: string | null
    zipcode: string | null
    photo: string | null
    gender: GenderType | null
    birthdate: Date | null
    google_id: string | null
    apple_id: string | null
    facebook_id: string | null
    created_at: Date | null
    updated_at: Date | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    whatsapp: number
    phone: number
    cpf_cnpj: number
    street: number
    number: number
    district: number
    country: number
    state: number
    complement: number
    city: number
    zipcode: number
    photo: number
    gender: number
    birthdate: number
    google_id: number
    apple_id: number
    facebook_id: number
    created_at: number
    updated_at: number
    lastLogin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    whatsapp?: true
    phone?: true
    cpf_cnpj?: true
    street?: true
    number?: true
    district?: true
    country?: true
    state?: true
    complement?: true
    city?: true
    zipcode?: true
    photo?: true
    gender?: true
    birthdate?: true
    google_id?: true
    apple_id?: true
    facebook_id?: true
    created_at?: true
    updated_at?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    whatsapp?: true
    phone?: true
    cpf_cnpj?: true
    street?: true
    number?: true
    district?: true
    country?: true
    state?: true
    complement?: true
    city?: true
    zipcode?: true
    photo?: true
    gender?: true
    birthdate?: true
    google_id?: true
    apple_id?: true
    facebook_id?: true
    created_at?: true
    updated_at?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    whatsapp?: true
    phone?: true
    cpf_cnpj?: true
    street?: true
    number?: true
    district?: true
    country?: true
    state?: true
    complement?: true
    city?: true
    zipcode?: true
    photo?: true
    gender?: true
    birthdate?: true
    google_id?: true
    apple_id?: true
    facebook_id?: true
    created_at?: true
    updated_at?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    whatsapp: string | null
    phone: string | null
    cpf_cnpj: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement: string | null
    city: string
    zipcode: string
    photo: string | null
    gender: GenderType
    birthdate: Date | null
    google_id: string | null
    apple_id: string | null
    facebook_id: string | null
    created_at: Date
    updated_at: Date
    lastLogin: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    whatsapp?: boolean
    phone?: boolean
    cpf_cnpj?: boolean
    street?: boolean
    number?: boolean
    district?: boolean
    country?: boolean
    state?: boolean
    complement?: boolean
    city?: boolean
    zipcode?: boolean
    photo?: boolean
    gender?: boolean
    birthdate?: boolean
    google_id?: boolean
    apple_id?: boolean
    facebook_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    lastLogin?: boolean
    device_user?: boolean | DeviceUserFindManyArgs
    account_user?: boolean | AccountUserFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    device_user?: boolean | DeviceUserFindManyArgs
    account_user?: boolean | AccountUserFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_user' ? Array < AccountUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_user' ? Array < AccountUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device_user<T extends DeviceUserFindManyArgs = {}>(args?: Subset<T, DeviceUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceUser>| Null>, PrismaPromise<Array<DeviceUserGetPayload<T>>| Null>>;

    account_user<T extends AccountUserFindManyArgs = {}>(args?: Subset<T, AccountUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountUser>| Null>, PrismaPromise<Array<AccountUserGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model AccountUser
   */


  export type AggregateAccountUser = {
    _count: AccountUserCountAggregateOutputType | null
    _min: AccountUserMinAggregateOutputType | null
    _max: AccountUserMaxAggregateOutputType | null
  }

  export type AccountUserMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    user_id: string | null
    role_id: string | null
  }

  export type AccountUserMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    user_id: string | null
    role_id: string | null
  }

  export type AccountUserCountAggregateOutputType = {
    id: number
    account_id: number
    user_id: number
    role_id: number
    _all: number
  }


  export type AccountUserMinAggregateInputType = {
    id?: true
    account_id?: true
    user_id?: true
    role_id?: true
  }

  export type AccountUserMaxAggregateInputType = {
    id?: true
    account_id?: true
    user_id?: true
    role_id?: true
  }

  export type AccountUserCountAggregateInputType = {
    id?: true
    account_id?: true
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type AccountUserAggregateArgs = {
    /**
     * Filter which AccountUser to aggregate.
     * 
    **/
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountUsers
    **/
    _count?: true | AccountUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountUserMaxAggregateInputType
  }

  export type GetAccountUserAggregateType<T extends AccountUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountUser[P]>
      : GetScalarType<T[P], AggregateAccountUser[P]>
  }




  export type AccountUserGroupByArgs = {
    where?: AccountUserWhereInput
    orderBy?: Enumerable<AccountUserOrderByWithAggregationInput>
    by: Array<AccountUserScalarFieldEnum>
    having?: AccountUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountUserCountAggregateInputType | true
    _min?: AccountUserMinAggregateInputType
    _max?: AccountUserMaxAggregateInputType
  }


  export type AccountUserGroupByOutputType = {
    id: string
    account_id: string
    user_id: string
    role_id: string
    _count: AccountUserCountAggregateOutputType | null
    _min: AccountUserMinAggregateOutputType | null
    _max: AccountUserMaxAggregateOutputType | null
  }

  type GetAccountUserGroupByPayload<T extends AccountUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountUserGroupByOutputType[P]>
            : GetScalarType<T[P], AccountUserGroupByOutputType[P]>
        }
      >
    >


  export type AccountUserSelect = {
    id?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    user_id?: boolean
    user?: boolean | UserArgs
    role_id?: boolean
    role?: boolean | RoleArgs
    campaigns?: boolean | CampaignFindManyArgs
    _count?: boolean | AccountUserCountOutputTypeArgs
  }

  export type AccountUserInclude = {
    account?: boolean | AccountArgs
    user?: boolean | UserArgs
    role?: boolean | RoleArgs
    campaigns?: boolean | CampaignFindManyArgs
    _count?: boolean | AccountUserCountOutputTypeArgs
  }

  export type AccountUserGetPayload<
    S extends boolean | null | undefined | AccountUserArgs,
    U = keyof S
      > = S extends true
        ? AccountUser
    : S extends undefined
    ? never
    : S extends AccountUserArgs | AccountUserFindManyArgs
    ?'include' extends U
    ? AccountUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'role' ? RoleGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'campaigns' ? Array < CampaignGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? AccountUserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'role' ? RoleGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'campaigns' ? Array < CampaignGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? AccountUserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AccountUser ? AccountUser[P] : never
  } 
    : AccountUser
  : AccountUser


  type AccountUserCountArgs = Merge<
    Omit<AccountUserFindManyArgs, 'select' | 'include'> & {
      select?: AccountUserCountAggregateInputType | true
    }
  >

  export interface AccountUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AccountUser that matches the filter.
     * @param {AccountUserFindUniqueArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountUser'> extends True ? CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>> : CheckSelect<T, Prisma__AccountUserClient<AccountUser | null, null>, Prisma__AccountUserClient<AccountUserGetPayload<T> | null, null>>

    /**
     * Find the first AccountUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindFirstArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountUser'> extends True ? CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>> : CheckSelect<T, Prisma__AccountUserClient<AccountUser | null, null>, Prisma__AccountUserClient<AccountUserGetPayload<T> | null, null>>

    /**
     * Find zero or more AccountUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountUsers
     * const accountUsers = await prisma.accountUser.findMany()
     * 
     * // Get first 10 AccountUsers
     * const accountUsers = await prisma.accountUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountUserWithIdOnly = await prisma.accountUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountUserFindManyArgs>(
      args?: SelectSubset<T, AccountUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountUser>>, PrismaPromise<Array<AccountUserGetPayload<T>>>>

    /**
     * Create a AccountUser.
     * @param {AccountUserCreateArgs} args - Arguments to create a AccountUser.
     * @example
     * // Create one AccountUser
     * const AccountUser = await prisma.accountUser.create({
     *   data: {
     *     // ... data to create a AccountUser
     *   }
     * })
     * 
    **/
    create<T extends AccountUserCreateArgs>(
      args: SelectSubset<T, AccountUserCreateArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Create many AccountUsers.
     *     @param {AccountUserCreateManyArgs} args - Arguments to create many AccountUsers.
     *     @example
     *     // Create many AccountUsers
     *     const accountUser = await prisma.accountUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountUserCreateManyArgs>(
      args?: SelectSubset<T, AccountUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccountUser.
     * @param {AccountUserDeleteArgs} args - Arguments to delete one AccountUser.
     * @example
     * // Delete one AccountUser
     * const AccountUser = await prisma.accountUser.delete({
     *   where: {
     *     // ... filter to delete one AccountUser
     *   }
     * })
     * 
    **/
    delete<T extends AccountUserDeleteArgs>(
      args: SelectSubset<T, AccountUserDeleteArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Update one AccountUser.
     * @param {AccountUserUpdateArgs} args - Arguments to update one AccountUser.
     * @example
     * // Update one AccountUser
     * const accountUser = await prisma.accountUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUserUpdateArgs>(
      args: SelectSubset<T, AccountUserUpdateArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Delete zero or more AccountUsers.
     * @param {AccountUserDeleteManyArgs} args - Arguments to filter AccountUsers to delete.
     * @example
     * // Delete a few AccountUsers
     * const { count } = await prisma.accountUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountUserDeleteManyArgs>(
      args?: SelectSubset<T, AccountUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountUsers
     * const accountUser = await prisma.accountUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUserUpdateManyArgs>(
      args: SelectSubset<T, AccountUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountUser.
     * @param {AccountUserUpsertArgs} args - Arguments to update or create a AccountUser.
     * @example
     * // Update or create a AccountUser
     * const accountUser = await prisma.accountUser.upsert({
     *   create: {
     *     // ... data to create a AccountUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountUser we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUserUpsertArgs>(
      args: SelectSubset<T, AccountUserUpsertArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Find one AccountUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountUserFindUniqueOrThrowArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Find the first AccountUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindFirstOrThrowArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Count the number of AccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserCountArgs} args - Arguments to filter AccountUsers to count.
     * @example
     * // Count the number of AccountUsers
     * const count = await prisma.accountUser.count({
     *   where: {
     *     // ... the filter for the AccountUsers we want to count
     *   }
     * })
    **/
    count<T extends AccountUserCountArgs>(
      args?: Subset<T, AccountUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountUserAggregateArgs>(args: Subset<T, AccountUserAggregateArgs>): PrismaPromise<GetAccountUserAggregateType<T>>

    /**
     * Group by AccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountUserGroupByArgs['orderBy'] }
        : { orderBy?: AccountUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountUserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | Null>, Prisma__RoleClient<RoleGetPayload<T> | Null>>;

    campaigns<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>| Null>, PrismaPromise<Array<CampaignGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AccountUser base type for findUnique actions
   */
  export type AccountUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter, which AccountUser to fetch.
     * 
    **/
    where: AccountUserWhereUniqueInput
  }

  /**
   * AccountUser: findUnique
   */
  export interface AccountUserFindUniqueArgs extends AccountUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountUser base type for findFirst actions
   */
  export type AccountUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter, which AccountUser to fetch.
     * 
    **/
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountUsers.
     * 
    **/
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountUsers.
     * 
    **/
    distinct?: Enumerable<AccountUserScalarFieldEnum>
  }

  /**
   * AccountUser: findFirst
   */
  export interface AccountUserFindFirstArgs extends AccountUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountUser findMany
   */
  export type AccountUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter, which AccountUsers to fetch.
     * 
    **/
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountUsers.
     * 
    **/
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountUserScalarFieldEnum>
  }


  /**
   * AccountUser create
   */
  export type AccountUserCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * The data needed to create a AccountUser.
     * 
    **/
    data: XOR<AccountUserCreateInput, AccountUserUncheckedCreateInput>
  }


  /**
   * AccountUser createMany
   */
  export type AccountUserCreateManyArgs = {
    /**
     * The data used to create many AccountUsers.
     * 
    **/
    data: Enumerable<AccountUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AccountUser update
   */
  export type AccountUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * The data needed to update a AccountUser.
     * 
    **/
    data: XOR<AccountUserUpdateInput, AccountUserUncheckedUpdateInput>
    /**
     * Choose, which AccountUser to update.
     * 
    **/
    where: AccountUserWhereUniqueInput
  }


  /**
   * AccountUser updateMany
   */
  export type AccountUserUpdateManyArgs = {
    /**
     * The data used to update AccountUsers.
     * 
    **/
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyInput>
    /**
     * Filter which AccountUsers to update
     * 
    **/
    where?: AccountUserWhereInput
  }


  /**
   * AccountUser upsert
   */
  export type AccountUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * The filter to search for the AccountUser to update in case it exists.
     * 
    **/
    where: AccountUserWhereUniqueInput
    /**
     * In case the AccountUser found by the `where` argument doesn't exist, create a new AccountUser with this data.
     * 
    **/
    create: XOR<AccountUserCreateInput, AccountUserUncheckedCreateInput>
    /**
     * In case the AccountUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUserUpdateInput, AccountUserUncheckedUpdateInput>
  }


  /**
   * AccountUser delete
   */
  export type AccountUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter which AccountUser to delete.
     * 
    **/
    where: AccountUserWhereUniqueInput
  }


  /**
   * AccountUser deleteMany
   */
  export type AccountUserDeleteManyArgs = {
    /**
     * Filter which AccountUsers to delete
     * 
    **/
    where?: AccountUserWhereInput
  }


  /**
   * AccountUser: findUniqueOrThrow
   */
  export type AccountUserFindUniqueOrThrowArgs = AccountUserFindUniqueArgsBase
      

  /**
   * AccountUser: findFirstOrThrow
   */
  export type AccountUserFindFirstOrThrowArgs = AccountUserFindFirstArgsBase
      

  /**
   * AccountUser without action
   */
  export type AccountUserArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
  }



  /**
   * Model Permision
   */


  export type AggregatePermision = {
    _count: PermisionCountAggregateOutputType | null
    _min: PermisionMinAggregateOutputType | null
    _max: PermisionMaxAggregateOutputType | null
  }

  export type PermisionMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type PermisionMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type PermisionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PermisionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PermisionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PermisionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PermisionAggregateArgs = {
    /**
     * Filter which Permision to aggregate.
     * 
    **/
    where?: PermisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PermisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permisions
    **/
    _count?: true | PermisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermisionMaxAggregateInputType
  }

  export type GetPermisionAggregateType<T extends PermisionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermision[P]>
      : GetScalarType<T[P], AggregatePermision[P]>
  }




  export type PermisionGroupByArgs = {
    where?: PermisionWhereInput
    orderBy?: Enumerable<PermisionOrderByWithAggregationInput>
    by: Array<PermisionScalarFieldEnum>
    having?: PermisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermisionCountAggregateInputType | true
    _min?: PermisionMinAggregateInputType
    _max?: PermisionMaxAggregateInputType
  }


  export type PermisionGroupByOutputType = {
    id: string
    name: string
    _count: PermisionCountAggregateOutputType | null
    _min: PermisionMinAggregateOutputType | null
    _max: PermisionMaxAggregateOutputType | null
  }

  type GetPermisionGroupByPayload<T extends PermisionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PermisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermisionGroupByOutputType[P]>
            : GetScalarType<T[P], PermisionGroupByOutputType[P]>
        }
      >
    >


  export type PermisionSelect = {
    id?: boolean
    name?: boolean
    RolePermission?: boolean | RolePermissionFindManyArgs
    _count?: boolean | PermisionCountOutputTypeArgs
  }

  export type PermisionInclude = {
    RolePermission?: boolean | RolePermissionFindManyArgs
    _count?: boolean | PermisionCountOutputTypeArgs
  }

  export type PermisionGetPayload<
    S extends boolean | null | undefined | PermisionArgs,
    U = keyof S
      > = S extends true
        ? Permision
    : S extends undefined
    ? never
    : S extends PermisionArgs | PermisionFindManyArgs
    ?'include' extends U
    ? Permision  & {
    [P in TrueKeys<S['include']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PermisionCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PermisionCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Permision ? Permision[P] : never
  } 
    : Permision
  : Permision


  type PermisionCountArgs = Merge<
    Omit<PermisionFindManyArgs, 'select' | 'include'> & {
      select?: PermisionCountAggregateInputType | true
    }
  >

  export interface PermisionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Permision that matches the filter.
     * @param {PermisionFindUniqueArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermisionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermisionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permision'> extends True ? CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>> : CheckSelect<T, Prisma__PermisionClient<Permision | null, null>, Prisma__PermisionClient<PermisionGetPayload<T> | null, null>>

    /**
     * Find the first Permision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionFindFirstArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermisionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermisionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permision'> extends True ? CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>> : CheckSelect<T, Prisma__PermisionClient<Permision | null, null>, Prisma__PermisionClient<PermisionGetPayload<T> | null, null>>

    /**
     * Find zero or more Permisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permisions
     * const permisions = await prisma.permision.findMany()
     * 
     * // Get first 10 Permisions
     * const permisions = await prisma.permision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permisionWithIdOnly = await prisma.permision.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermisionFindManyArgs>(
      args?: SelectSubset<T, PermisionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Permision>>, PrismaPromise<Array<PermisionGetPayload<T>>>>

    /**
     * Create a Permision.
     * @param {PermisionCreateArgs} args - Arguments to create a Permision.
     * @example
     * // Create one Permision
     * const Permision = await prisma.permision.create({
     *   data: {
     *     // ... data to create a Permision
     *   }
     * })
     * 
    **/
    create<T extends PermisionCreateArgs>(
      args: SelectSubset<T, PermisionCreateArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Create many Permisions.
     *     @param {PermisionCreateManyArgs} args - Arguments to create many Permisions.
     *     @example
     *     // Create many Permisions
     *     const permision = await prisma.permision.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermisionCreateManyArgs>(
      args?: SelectSubset<T, PermisionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Permision.
     * @param {PermisionDeleteArgs} args - Arguments to delete one Permision.
     * @example
     * // Delete one Permision
     * const Permision = await prisma.permision.delete({
     *   where: {
     *     // ... filter to delete one Permision
     *   }
     * })
     * 
    **/
    delete<T extends PermisionDeleteArgs>(
      args: SelectSubset<T, PermisionDeleteArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Update one Permision.
     * @param {PermisionUpdateArgs} args - Arguments to update one Permision.
     * @example
     * // Update one Permision
     * const permision = await prisma.permision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermisionUpdateArgs>(
      args: SelectSubset<T, PermisionUpdateArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Delete zero or more Permisions.
     * @param {PermisionDeleteManyArgs} args - Arguments to filter Permisions to delete.
     * @example
     * // Delete a few Permisions
     * const { count } = await prisma.permision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermisionDeleteManyArgs>(
      args?: SelectSubset<T, PermisionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permisions
     * const permision = await prisma.permision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermisionUpdateManyArgs>(
      args: SelectSubset<T, PermisionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Permision.
     * @param {PermisionUpsertArgs} args - Arguments to update or create a Permision.
     * @example
     * // Update or create a Permision
     * const permision = await prisma.permision.upsert({
     *   create: {
     *     // ... data to create a Permision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permision we want to update
     *   }
     * })
    **/
    upsert<T extends PermisionUpsertArgs>(
      args: SelectSubset<T, PermisionUpsertArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Find one Permision that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PermisionFindUniqueOrThrowArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermisionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PermisionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Find the first Permision that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionFindFirstOrThrowArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermisionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PermisionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Count the number of Permisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionCountArgs} args - Arguments to filter Permisions to count.
     * @example
     * // Count the number of Permisions
     * const count = await prisma.permision.count({
     *   where: {
     *     // ... the filter for the Permisions we want to count
     *   }
     * })
    **/
    count<T extends PermisionCountArgs>(
      args?: Subset<T, PermisionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermisionAggregateArgs>(args: Subset<T, PermisionAggregateArgs>): PrismaPromise<GetPermisionAggregateType<T>>

    /**
     * Group by Permision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermisionGroupByArgs['orderBy'] }
        : { orderBy?: PermisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermisionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Permision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermisionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RolePermission<T extends RolePermissionFindManyArgs = {}>(args?: Subset<T, RolePermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RolePermission>| Null>, PrismaPromise<Array<RolePermissionGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Permision base type for findUnique actions
   */
  export type PermisionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter, which Permision to fetch.
     * 
    **/
    where: PermisionWhereUniqueInput
  }

  /**
   * Permision: findUnique
   */
  export interface PermisionFindUniqueArgs extends PermisionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permision base type for findFirst actions
   */
  export type PermisionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter, which Permision to fetch.
     * 
    **/
    where?: PermisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisions.
     * 
    **/
    cursor?: PermisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisions.
     * 
    **/
    distinct?: Enumerable<PermisionScalarFieldEnum>
  }

  /**
   * Permision: findFirst
   */
  export interface PermisionFindFirstArgs extends PermisionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permision findMany
   */
  export type PermisionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter, which Permisions to fetch.
     * 
    **/
    where?: PermisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permisions.
     * 
    **/
    cursor?: PermisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PermisionScalarFieldEnum>
  }


  /**
   * Permision create
   */
  export type PermisionCreateArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * The data needed to create a Permision.
     * 
    **/
    data: XOR<PermisionCreateInput, PermisionUncheckedCreateInput>
  }


  /**
   * Permision createMany
   */
  export type PermisionCreateManyArgs = {
    /**
     * The data used to create many Permisions.
     * 
    **/
    data: Enumerable<PermisionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Permision update
   */
  export type PermisionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * The data needed to update a Permision.
     * 
    **/
    data: XOR<PermisionUpdateInput, PermisionUncheckedUpdateInput>
    /**
     * Choose, which Permision to update.
     * 
    **/
    where: PermisionWhereUniqueInput
  }


  /**
   * Permision updateMany
   */
  export type PermisionUpdateManyArgs = {
    /**
     * The data used to update Permisions.
     * 
    **/
    data: XOR<PermisionUpdateManyMutationInput, PermisionUncheckedUpdateManyInput>
    /**
     * Filter which Permisions to update
     * 
    **/
    where?: PermisionWhereInput
  }


  /**
   * Permision upsert
   */
  export type PermisionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * The filter to search for the Permision to update in case it exists.
     * 
    **/
    where: PermisionWhereUniqueInput
    /**
     * In case the Permision found by the `where` argument doesn't exist, create a new Permision with this data.
     * 
    **/
    create: XOR<PermisionCreateInput, PermisionUncheckedCreateInput>
    /**
     * In case the Permision was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PermisionUpdateInput, PermisionUncheckedUpdateInput>
  }


  /**
   * Permision delete
   */
  export type PermisionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter which Permision to delete.
     * 
    **/
    where: PermisionWhereUniqueInput
  }


  /**
   * Permision deleteMany
   */
  export type PermisionDeleteManyArgs = {
    /**
     * Filter which Permisions to delete
     * 
    **/
    where?: PermisionWhereInput
  }


  /**
   * Permision: findUniqueOrThrow
   */
  export type PermisionFindUniqueOrThrowArgs = PermisionFindUniqueArgsBase
      

  /**
   * Permision: findFirstOrThrow
   */
  export type PermisionFindFirstOrThrowArgs = PermisionFindFirstArgsBase
      

  /**
   * Permision without action
   */
  export type PermisionArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
  }



  /**
   * Model RolePermission
   */


  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    role_id: string | null
    permission_id: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    role_id: string | null
    permission_id: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    role_id: number
    permission_id: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type RolePermissionCountAggregateInputType = {
    role_id?: true
    permission_id?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs = {
    /**
     * Filter which RolePermission to aggregate.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs = {
    where?: RolePermissionWhereInput
    orderBy?: Enumerable<RolePermissionOrderByWithAggregationInput>
    by: Array<RolePermissionScalarFieldEnum>
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }


  export type RolePermissionGroupByOutputType = {
    role_id: string
    permission_id: string
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect = {
    role_id?: boolean
    role?: boolean | RoleArgs
    permission_id?: boolean
    permission?: boolean | PermisionArgs
  }

  export type RolePermissionInclude = {
    role?: boolean | RoleArgs
    permission?: boolean | PermisionArgs
  }

  export type RolePermissionGetPayload<
    S extends boolean | null | undefined | RolePermissionArgs,
    U = keyof S
      > = S extends true
        ? RolePermission
    : S extends undefined
    ? never
    : S extends RolePermissionArgs | RolePermissionFindManyArgs
    ?'include' extends U
    ? RolePermission  & {
    [P in TrueKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'permission' ? PermisionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'role' ? RoleGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'permission' ? PermisionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RolePermission ? RolePermission[P] : never
  } 
    : RolePermission
  : RolePermission


  type RolePermissionCountArgs = Merge<
    Omit<RolePermissionFindManyArgs, 'select' | 'include'> & {
      select?: RolePermissionCountAggregateInputType | true
    }
  >

  export interface RolePermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolePermissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolePermissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RolePermission'> extends True ? CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionClient<RolePermission | null, null>, Prisma__RolePermissionClient<RolePermissionGetPayload<T> | null, null>>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolePermissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolePermissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RolePermission'> extends True ? CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionClient<RolePermission | null, null>, Prisma__RolePermissionClient<RolePermissionGetPayload<T> | null, null>>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const rolePermissionWithRole_idOnly = await prisma.rolePermission.findMany({ select: { role_id: true } })
     * 
    **/
    findMany<T extends RolePermissionFindManyArgs>(
      args?: SelectSubset<T, RolePermissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RolePermission>>, PrismaPromise<Array<RolePermissionGetPayload<T>>>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
    **/
    create<T extends RolePermissionCreateArgs>(
      args: SelectSubset<T, RolePermissionCreateArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Create many RolePermissions.
     *     @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     *     @example
     *     // Create many RolePermissions
     *     const rolePermission = await prisma.rolePermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolePermissionCreateManyArgs>(
      args?: SelectSubset<T, RolePermissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
    **/
    delete<T extends RolePermissionDeleteArgs>(
      args: SelectSubset<T, RolePermissionDeleteArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolePermissionUpdateArgs>(
      args: SelectSubset<T, RolePermissionUpdateArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolePermissionDeleteManyArgs>(
      args?: SelectSubset<T, RolePermissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolePermissionUpdateManyArgs>(
      args: SelectSubset<T, RolePermissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
    **/
    upsert<T extends RolePermissionUpsertArgs>(
      args: SelectSubset<T, RolePermissionUpsertArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Find one RolePermission that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolePermissionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | Null>, Prisma__RoleClient<RoleGetPayload<T> | Null>>;

    permission<T extends PermisionArgs = {}>(args?: Subset<T, PermisionArgs>): CheckSelect<T, Prisma__PermisionClient<Permision | Null>, Prisma__PermisionClient<PermisionGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RolePermission base type for findUnique actions
   */
  export type RolePermissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter, which RolePermission to fetch.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission: findUnique
   */
  export interface RolePermissionFindUniqueArgs extends RolePermissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RolePermission base type for findFirst actions
   */
  export type RolePermissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter, which RolePermission to fetch.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     * 
    **/
    distinct?: Enumerable<RolePermissionScalarFieldEnum>
  }

  /**
   * RolePermission: findFirst
   */
  export interface RolePermissionFindFirstArgs extends RolePermissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter, which RolePermissions to fetch.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolePermissionScalarFieldEnum>
  }


  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The data needed to create a RolePermission.
     * 
    **/
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }


  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs = {
    /**
     * The data used to create many RolePermissions.
     * 
    **/
    data: Enumerable<RolePermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The data needed to update a RolePermission.
     * 
    **/
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs = {
    /**
     * The data used to update RolePermissions.
     * 
    **/
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     * 
    **/
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     * 
    **/
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     * 
    **/
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }


  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter which RolePermission to delete.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs = {
    /**
     * Filter which RolePermissions to delete
     * 
    **/
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission: findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs = RolePermissionFindUniqueArgsBase
      

  /**
   * RolePermission: findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs = RolePermissionFindFirstArgsBase
      

  /**
   * RolePermission without action
   */
  export type RolePermissionArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: Array<RoleScalarFieldEnum>
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: string
    name: string
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    name?: boolean
    RolePermission?: boolean | RolePermissionFindManyArgs
    AccountUser?: boolean | AccountUserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleInclude = {
    RolePermission?: boolean | RolePermissionFindManyArgs
    AccountUser?: boolean | AccountUserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role  & {
    [P in TrueKeys<S['include']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'AccountUser' ? Array < AccountUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'AccountUser' ? Array < AccountUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Role ? Role[P] : never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null, null>, Prisma__RoleClient<RoleGetPayload<T> | null, null>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null, null>, Prisma__RoleClient<RoleGetPayload<T> | null, null>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Find one Role that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RolePermission<T extends RolePermissionFindManyArgs = {}>(args?: Subset<T, RolePermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RolePermission>| Null>, PrismaPromise<Array<RolePermissionGetPayload<T>>| Null>>;

    AccountUser<T extends AccountUserFindManyArgs = {}>(args?: Subset<T, AccountUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountUser>| Null>, PrismaPromise<Array<AccountUserGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where: RoleWhereUniqueInput
  }

  /**
   * Role: findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role: findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     * 
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     * 
    **/
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     * 
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     * 
    **/
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     * 
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     * 
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role: findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = RoleFindUniqueArgsBase
      

  /**
   * Role: findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = RoleFindFirstArgsBase
      

  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
  }



  /**
   * Model Campaign
   */


  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    percentage_discount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    percentage_discount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    percentage_discount: number | null
    start_date: Date | null
    expiration_date: Date | null
    type_id: string | null
    account_id: string | null
    account_user_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    percentage_discount: number | null
    start_date: Date | null
    expiration_date: Date | null
    type_id: string | null
    account_id: string | null
    account_user_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    percentage_discount: number
    start_date: number
    expiration_date: number
    type_id: number
    account_id: number
    account_user_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    percentage_discount?: true
  }

  export type CampaignSumAggregateInputType = {
    percentage_discount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    percentage_discount?: true
    start_date?: true
    expiration_date?: true
    type_id?: true
    account_id?: true
    account_user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    percentage_discount?: true
    start_date?: true
    expiration_date?: true
    type_id?: true
    account_id?: true
    account_user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    percentage_discount?: true
    start_date?: true
    expiration_date?: true
    type_id?: true
    account_id?: true
    account_user_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CampaignAggregateArgs = {
    /**
     * Filter which Campaign to aggregate.
     * 
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs = {
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithAggregationInput>
    by: Array<CampaignScalarFieldEnum>
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }


  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    percentage_discount: number | null
    start_date: Date | null
    expiration_date: Date | null
    type_id: string
    account_id: string
    account_user_id: string
    created_at: Date
    updated_at: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    percentage_discount?: boolean
    start_date?: boolean
    expiration_date?: boolean
    type_id?: boolean
    campaign_type?: boolean | CampaignTypeArgs
    account?: boolean | AccountArgs
    account_id?: boolean
    account_user_id?: boolean
    account_user?: boolean | AccountUserArgs
    created_at?: boolean
    updated_at?: boolean
    label_campaign?: boolean | LabelCampaignFindManyArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }

  export type CampaignInclude = {
    campaign_type?: boolean | CampaignTypeArgs
    account?: boolean | AccountArgs
    account_user?: boolean | AccountUserArgs
    label_campaign?: boolean | LabelCampaignFindManyArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }

  export type CampaignGetPayload<
    S extends boolean | null | undefined | CampaignArgs,
    U = keyof S
      > = S extends true
        ? Campaign
    : S extends undefined
    ? never
    : S extends CampaignArgs | CampaignFindManyArgs
    ?'include' extends U
    ? Campaign  & {
    [P in TrueKeys<S['include']>]:
        P extends 'campaign_type' ? CampaignTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account_user' ? AccountUserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'label_campaign' ? Array < LabelCampaignGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'campaign_type' ? CampaignTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account_user' ? AccountUserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'label_campaign' ? Array < LabelCampaignGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Campaign ? Campaign[P] : never
  } 
    : Campaign
  : Campaign


  type CampaignCountArgs = Merge<
    Omit<CampaignFindManyArgs, 'select' | 'include'> & {
      select?: CampaignCountAggregateInputType | true
    }
  >

  export interface CampaignDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Campaign'> extends True ? CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>> : CheckSelect<T, Prisma__CampaignClient<Campaign | null, null>, Prisma__CampaignClient<CampaignGetPayload<T> | null, null>>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Campaign'> extends True ? CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>> : CheckSelect<T, Prisma__CampaignClient<Campaign | null, null>, Prisma__CampaignClient<CampaignGetPayload<T> | null, null>>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignFindManyArgs>(
      args?: SelectSubset<T, CampaignFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Campaign>>, PrismaPromise<Array<CampaignGetPayload<T>>>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
    **/
    create<T extends CampaignCreateArgs>(
      args: SelectSubset<T, CampaignCreateArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Create many Campaigns.
     *     @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     *     @example
     *     // Create many Campaigns
     *     const campaign = await prisma.campaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignCreateManyArgs>(
      args?: SelectSubset<T, CampaignCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
    **/
    delete<T extends CampaignDeleteArgs>(
      args: SelectSubset<T, CampaignDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignUpdateArgs>(
      args: SelectSubset<T, CampaignUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignDeleteManyArgs>(
      args?: SelectSubset<T, CampaignDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignUpdateManyArgs>(
      args: SelectSubset<T, CampaignUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignUpsertArgs>(
      args: SelectSubset<T, CampaignUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Find one Campaign that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Find the first Campaign that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    campaign_type<T extends CampaignTypeArgs = {}>(args?: Subset<T, CampaignTypeArgs>): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | Null>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    account_user<T extends AccountUserArgs = {}>(args?: Subset<T, AccountUserArgs>): CheckSelect<T, Prisma__AccountUserClient<AccountUser | Null>, Prisma__AccountUserClient<AccountUserGetPayload<T> | Null>>;

    label_campaign<T extends LabelCampaignFindManyArgs = {}>(args?: Subset<T, LabelCampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LabelCampaign>| Null>, PrismaPromise<Array<LabelCampaignGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Campaign base type for findUnique actions
   */
  export type CampaignFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     * 
    **/
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign: findUnique
   */
  export interface CampaignFindUniqueArgs extends CampaignFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign base type for findFirst actions
   */
  export type CampaignFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     * 
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     * 
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     * 
    **/
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }

  /**
   * Campaign: findFirst
   */
  export interface CampaignFindFirstArgs extends CampaignFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter, which Campaigns to fetch.
     * 
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     * 
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign create
   */
  export type CampaignCreateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * The data needed to create a Campaign.
     * 
    **/
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }


  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs = {
    /**
     * The data used to create many Campaigns.
     * 
    **/
    data: Enumerable<CampaignCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Campaign update
   */
  export type CampaignUpdateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * The data needed to update a Campaign.
     * 
    **/
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     * 
    **/
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs = {
    /**
     * The data used to update Campaigns.
     * 
    **/
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     * 
    **/
    where?: CampaignWhereInput
  }


  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     * 
    **/
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     * 
    **/
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }


  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter which Campaign to delete.
     * 
    **/
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs = {
    /**
     * Filter which Campaigns to delete
     * 
    **/
    where?: CampaignWhereInput
  }


  /**
   * Campaign: findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs = CampaignFindUniqueArgsBase
      

  /**
   * Campaign: findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs = CampaignFindFirstArgsBase
      

  /**
   * Campaign without action
   */
  export type CampaignArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
  }



  /**
   * Model CampaignType
   */


  export type AggregateCampaignType = {
    _count: CampaignTypeCountAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  export type CampaignTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type CampaignTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type CampaignTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type CampaignTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type CampaignTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type CampaignTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type CampaignTypeAggregateArgs = {
    /**
     * Filter which CampaignType to aggregate.
     * 
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignTypes
    **/
    _count?: true | CampaignTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTypeMaxAggregateInputType
  }

  export type GetCampaignTypeAggregateType<T extends CampaignTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignType[P]>
      : GetScalarType<T[P], AggregateCampaignType[P]>
  }




  export type CampaignTypeGroupByArgs = {
    where?: CampaignTypeWhereInput
    orderBy?: Enumerable<CampaignTypeOrderByWithAggregationInput>
    by: Array<CampaignTypeScalarFieldEnum>
    having?: CampaignTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTypeCountAggregateInputType | true
    _min?: CampaignTypeMinAggregateInputType
    _max?: CampaignTypeMaxAggregateInputType
  }


  export type CampaignTypeGroupByOutputType = {
    id: string
    name: string
    slug: string
    _count: CampaignTypeCountAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  type GetCampaignTypeGroupByPayload<T extends CampaignTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CampaignTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
        }
      >
    >


  export type CampaignTypeSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    Campaign?: boolean | CampaignFindManyArgs
    _count?: boolean | CampaignTypeCountOutputTypeArgs
  }

  export type CampaignTypeInclude = {
    Campaign?: boolean | CampaignFindManyArgs
    _count?: boolean | CampaignTypeCountOutputTypeArgs
  }

  export type CampaignTypeGetPayload<
    S extends boolean | null | undefined | CampaignTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignType
    : S extends undefined
    ? never
    : S extends CampaignTypeArgs | CampaignTypeFindManyArgs
    ?'include' extends U
    ? CampaignType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Campaign' ? Array < CampaignGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignTypeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Campaign' ? Array < CampaignGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignTypeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof CampaignType ? CampaignType[P] : never
  } 
    : CampaignType
  : CampaignType


  type CampaignTypeCountArgs = Merge<
    Omit<CampaignTypeFindManyArgs, 'select' | 'include'> & {
      select?: CampaignTypeCountAggregateInputType | true
    }
  >

  export interface CampaignTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CampaignType that matches the filter.
     * @param {CampaignTypeFindUniqueArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignType'> extends True ? CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>> : CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null, null>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null, null>>

    /**
     * Find the first CampaignType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindFirstArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignType'> extends True ? CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>> : CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null, null>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null, null>>

    /**
     * Find zero or more CampaignTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany()
     * 
     * // Get first 10 CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignTypeWithIdOnly = await prisma.campaignType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignTypeFindManyArgs>(
      args?: SelectSubset<T, CampaignTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CampaignType>>, PrismaPromise<Array<CampaignTypeGetPayload<T>>>>

    /**
     * Create a CampaignType.
     * @param {CampaignTypeCreateArgs} args - Arguments to create a CampaignType.
     * @example
     * // Create one CampaignType
     * const CampaignType = await prisma.campaignType.create({
     *   data: {
     *     // ... data to create a CampaignType
     *   }
     * })
     * 
    **/
    create<T extends CampaignTypeCreateArgs>(
      args: SelectSubset<T, CampaignTypeCreateArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Create many CampaignTypes.
     *     @param {CampaignTypeCreateManyArgs} args - Arguments to create many CampaignTypes.
     *     @example
     *     // Create many CampaignTypes
     *     const campaignType = await prisma.campaignType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignTypeCreateManyArgs>(
      args?: SelectSubset<T, CampaignTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignType.
     * @param {CampaignTypeDeleteArgs} args - Arguments to delete one CampaignType.
     * @example
     * // Delete one CampaignType
     * const CampaignType = await prisma.campaignType.delete({
     *   where: {
     *     // ... filter to delete one CampaignType
     *   }
     * })
     * 
    **/
    delete<T extends CampaignTypeDeleteArgs>(
      args: SelectSubset<T, CampaignTypeDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Update one CampaignType.
     * @param {CampaignTypeUpdateArgs} args - Arguments to update one CampaignType.
     * @example
     * // Update one CampaignType
     * const campaignType = await prisma.campaignType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignTypeUpdateArgs>(
      args: SelectSubset<T, CampaignTypeUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Delete zero or more CampaignTypes.
     * @param {CampaignTypeDeleteManyArgs} args - Arguments to filter CampaignTypes to delete.
     * @example
     * // Delete a few CampaignTypes
     * const { count } = await prisma.campaignType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignTypeDeleteManyArgs>(
      args?: SelectSubset<T, CampaignTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTypes
     * const campaignType = await prisma.campaignType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignTypeUpdateManyArgs>(
      args: SelectSubset<T, CampaignTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignType.
     * @param {CampaignTypeUpsertArgs} args - Arguments to update or create a CampaignType.
     * @example
     * // Update or create a CampaignType
     * const campaignType = await prisma.campaignType.upsert({
     *   create: {
     *     // ... data to create a CampaignType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignType we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignTypeUpsertArgs>(
      args: SelectSubset<T, CampaignTypeUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Find one CampaignType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CampaignTypeFindUniqueOrThrowArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Find the first CampaignType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindFirstOrThrowArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Count the number of CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeCountArgs} args - Arguments to filter CampaignTypes to count.
     * @example
     * // Count the number of CampaignTypes
     * const count = await prisma.campaignType.count({
     *   where: {
     *     // ... the filter for the CampaignTypes we want to count
     *   }
     * })
    **/
    count<T extends CampaignTypeCountArgs>(
      args?: Subset<T, CampaignTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTypeAggregateArgs>(args: Subset<T, CampaignTypeAggregateArgs>): PrismaPromise<GetCampaignTypeAggregateType<T>>

    /**
     * Group by CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignTypeGroupByArgs['orderBy'] }
        : { orderBy?: CampaignTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTypeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignTypeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Campaign<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>| Null>, PrismaPromise<Array<CampaignGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CampaignType base type for findUnique actions
   */
  export type CampaignTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter, which CampaignType to fetch.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
  }

  /**
   * CampaignType: findUnique
   */
  export interface CampaignTypeFindUniqueArgs extends CampaignTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignType base type for findFirst actions
   */
  export type CampaignTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter, which CampaignType to fetch.
     * 
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTypes.
     * 
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTypes.
     * 
    **/
    distinct?: Enumerable<CampaignTypeScalarFieldEnum>
  }

  /**
   * CampaignType: findFirst
   */
  export interface CampaignTypeFindFirstArgs extends CampaignTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignType findMany
   */
  export type CampaignTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter, which CampaignTypes to fetch.
     * 
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignTypes.
     * 
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CampaignTypeScalarFieldEnum>
  }


  /**
   * CampaignType create
   */
  export type CampaignTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * The data needed to create a CampaignType.
     * 
    **/
    data: XOR<CampaignTypeCreateInput, CampaignTypeUncheckedCreateInput>
  }


  /**
   * CampaignType createMany
   */
  export type CampaignTypeCreateManyArgs = {
    /**
     * The data used to create many CampaignTypes.
     * 
    **/
    data: Enumerable<CampaignTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignType update
   */
  export type CampaignTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * The data needed to update a CampaignType.
     * 
    **/
    data: XOR<CampaignTypeUpdateInput, CampaignTypeUncheckedUpdateInput>
    /**
     * Choose, which CampaignType to update.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
  }


  /**
   * CampaignType updateMany
   */
  export type CampaignTypeUpdateManyArgs = {
    /**
     * The data used to update CampaignTypes.
     * 
    **/
    data: XOR<CampaignTypeUpdateManyMutationInput, CampaignTypeUncheckedUpdateManyInput>
    /**
     * Filter which CampaignTypes to update
     * 
    **/
    where?: CampaignTypeWhereInput
  }


  /**
   * CampaignType upsert
   */
  export type CampaignTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * The filter to search for the CampaignType to update in case it exists.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
    /**
     * In case the CampaignType found by the `where` argument doesn't exist, create a new CampaignType with this data.
     * 
    **/
    create: XOR<CampaignTypeCreateInput, CampaignTypeUncheckedCreateInput>
    /**
     * In case the CampaignType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CampaignTypeUpdateInput, CampaignTypeUncheckedUpdateInput>
  }


  /**
   * CampaignType delete
   */
  export type CampaignTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter which CampaignType to delete.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
  }


  /**
   * CampaignType deleteMany
   */
  export type CampaignTypeDeleteManyArgs = {
    /**
     * Filter which CampaignTypes to delete
     * 
    **/
    where?: CampaignTypeWhereInput
  }


  /**
   * CampaignType: findUniqueOrThrow
   */
  export type CampaignTypeFindUniqueOrThrowArgs = CampaignTypeFindUniqueArgsBase
      

  /**
   * CampaignType: findFirstOrThrow
   */
  export type CampaignTypeFindFirstOrThrowArgs = CampaignTypeFindFirstArgsBase
      

  /**
   * CampaignType without action
   */
  export type CampaignTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
  }



  /**
   * Model Coupon
   */


  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    discount_value: number | null
    min_value: number | null
    max_value: number | null
  }

  export type CouponSumAggregateOutputType = {
    discount_value: number | null
    min_value: number | null
    max_value: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    dicount_type: CouponDiscountType | null
    discount_value: number | null
    couponUse_type: CouponUseType | null
    inital_date: Date | null
    expiration_date: Date | null
    min_value: number | null
    max_value: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    dicount_type: CouponDiscountType | null
    discount_value: number | null
    couponUse_type: CouponUseType | null
    inital_date: Date | null
    expiration_date: Date | null
    min_value: number | null
    max_value: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    dicount_type: number
    discount_value: number
    couponUse_type: number
    inital_date: number
    expiration_date: number
    min_value: number
    max_value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    discount_value?: true
    min_value?: true
    max_value?: true
  }

  export type CouponSumAggregateInputType = {
    discount_value?: true
    min_value?: true
    max_value?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    dicount_type?: true
    discount_value?: true
    couponUse_type?: true
    inital_date?: true
    expiration_date?: true
    min_value?: true
    max_value?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    dicount_type?: true
    discount_value?: true
    couponUse_type?: true
    inital_date?: true
    expiration_date?: true
    min_value?: true
    max_value?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    dicount_type?: true
    discount_value?: true
    couponUse_type?: true
    inital_date?: true
    expiration_date?: true
    min_value?: true
    max_value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CouponAggregateArgs = {
    /**
     * Filter which Coupon to aggregate.
     * 
    **/
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs = {
    where?: CouponWhereInput
    orderBy?: Enumerable<CouponOrderByWithAggregationInput>
    by: Array<CouponScalarFieldEnum>
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }


  export type CouponGroupByOutputType = {
    id: string
    code: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date: Date
    expiration_date: Date | null
    min_value: number | null
    max_value: number | null
    created_at: Date
    updated_at: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect = {
    id?: boolean
    code?: boolean
    dicount_type?: boolean
    discount_value?: boolean
    couponUse_type?: boolean
    inital_date?: boolean
    expiration_date?: boolean
    min_value?: boolean
    max_value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CouponGetPayload<
    S extends boolean | null | undefined | CouponArgs,
    U = keyof S
      > = S extends true
        ? Coupon
    : S extends undefined
    ? never
    : S extends CouponArgs | CouponFindManyArgs
    ?'include' extends U
    ? Coupon 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Coupon ? Coupon[P] : never
  } 
    : Coupon
  : Coupon


  type CouponCountArgs = Merge<
    Omit<CouponFindManyArgs, 'select' | 'include'> & {
      select?: CouponCountAggregateInputType | true
    }
  >

  export interface CouponDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CouponFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CouponFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Coupon'> extends True ? CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>> : CheckSelect<T, Prisma__CouponClient<Coupon | null, null>, Prisma__CouponClient<CouponGetPayload<T> | null, null>>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CouponFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CouponFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Coupon'> extends True ? CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>> : CheckSelect<T, Prisma__CouponClient<Coupon | null, null>, Prisma__CouponClient<CouponGetPayload<T> | null, null>>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CouponFindManyArgs>(
      args?: SelectSubset<T, CouponFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Coupon>>, PrismaPromise<Array<CouponGetPayload<T>>>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
    **/
    create<T extends CouponCreateArgs>(
      args: SelectSubset<T, CouponCreateArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Create many Coupons.
     *     @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     *     @example
     *     // Create many Coupons
     *     const coupon = await prisma.coupon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CouponCreateManyArgs>(
      args?: SelectSubset<T, CouponCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
    **/
    delete<T extends CouponDeleteArgs>(
      args: SelectSubset<T, CouponDeleteArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CouponUpdateArgs>(
      args: SelectSubset<T, CouponUpdateArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CouponDeleteManyArgs>(
      args?: SelectSubset<T, CouponDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CouponUpdateManyArgs>(
      args: SelectSubset<T, CouponUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
    **/
    upsert<T extends CouponUpsertArgs>(
      args: SelectSubset<T, CouponUpsertArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Find one Coupon that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CouponFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Find the first Coupon that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CouponFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CouponClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Coupon base type for findUnique actions
   */
  export type CouponFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Filter, which Coupon to fetch.
     * 
    **/
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon: findUnique
   */
  export interface CouponFindUniqueArgs extends CouponFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coupon base type for findFirst actions
   */
  export type CouponFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Filter, which Coupon to fetch.
     * 
    **/
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     * 
    **/
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     * 
    **/
    distinct?: Enumerable<CouponScalarFieldEnum>
  }

  /**
   * Coupon: findFirst
   */
  export interface CouponFindFirstArgs extends CouponFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Filter, which Coupons to fetch.
     * 
    **/
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     * 
    **/
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CouponScalarFieldEnum>
  }


  /**
   * Coupon create
   */
  export type CouponCreateArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * The data needed to create a Coupon.
     * 
    **/
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }


  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs = {
    /**
     * The data used to create many Coupons.
     * 
    **/
    data: Enumerable<CouponCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Coupon update
   */
  export type CouponUpdateArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * The data needed to update a Coupon.
     * 
    **/
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     * 
    **/
    where: CouponWhereUniqueInput
  }


  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs = {
    /**
     * The data used to update Coupons.
     * 
    **/
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     * 
    **/
    where?: CouponWhereInput
  }


  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     * 
    **/
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     * 
    **/
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }


  /**
   * Coupon delete
   */
  export type CouponDeleteArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Filter which Coupon to delete.
     * 
    **/
    where: CouponWhereUniqueInput
  }


  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs = {
    /**
     * Filter which Coupons to delete
     * 
    **/
    where?: CouponWhereInput
  }


  /**
   * Coupon: findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs = CouponFindUniqueArgsBase
      

  /**
   * Coupon: findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs = CouponFindFirstArgsBase
      

  /**
   * Coupon without action
   */
  export type CouponArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
  }



  /**
   * Model Label
   */


  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelAvgAggregateOutputType = {
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
  }

  export type LabelSumAggregateOutputType = {
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
  }

  export type LabelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type_id: string | null
    country_id: string | null
    region_id: string | null
    harvest: string | null
    wine_type_id: string | null
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
    is_active: boolean | null
    stock: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type_id: string | null
    country_id: string | null
    region_id: string | null
    harvest: string | null
    wine_type_id: string | null
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
    is_active: boolean | null
    stock: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type_id: number
    country_id: number
    region_id: number
    harvest: number
    wine_type_id: number
    alcohol_percentage: number
    price: number
    promotional_price: number
    is_active: number
    stock: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LabelAvgAggregateInputType = {
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
  }

  export type LabelSumAggregateInputType = {
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
  }

  export type LabelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type_id?: true
    country_id?: true
    region_id?: true
    harvest?: true
    wine_type_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
    is_active?: true
    stock?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type_id?: true
    country_id?: true
    region_id?: true
    harvest?: true
    wine_type_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
    is_active?: true
    stock?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type_id?: true
    country_id?: true
    region_id?: true
    harvest?: true
    wine_type_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
    is_active?: true
    stock?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LabelAggregateArgs = {
    /**
     * Filter which Label to aggregate.
     * 
    **/
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs = {
    where?: LabelWhereInput
    orderBy?: Enumerable<LabelOrderByWithAggregationInput>
    by: Array<LabelScalarFieldEnum>
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _avg?: LabelAvgAggregateInputType
    _sum?: LabelSumAggregateInputType
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }


  export type LabelGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest: string | null
    wine_type_id: string
    alcohol_percentage: Decimal | null
    price: number
    promotional_price: number | null
    is_active: boolean
    stock: boolean
    created_at: Date
    updated_at: Date
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    labelType?: boolean | LabelTypeArgs
    country_id?: boolean
    country?: boolean | CountryArgs
    region_id?: boolean
    region?: boolean | RegionArgs
    harvest?: boolean
    wine_type_id?: boolean
    wine_type?: boolean | WineTypeArgs
    alcohol_percentage?: boolean
    price?: boolean
    promotional_price?: boolean
    is_active?: boolean
    stock?: boolean
    created_at?: boolean
    updated_at?: boolean
    label_grape?: boolean | LabelGrapeFindManyArgs
    order_label?: boolean | OrderLabelFindManyArgs
    label_campaign?: boolean | LabelCampaignFindManyArgs
    StockLabel?: boolean | StockLabelFindManyArgs
    StockHistory?: boolean | StockHistoryFindManyArgs
    _count?: boolean | LabelCountOutputTypeArgs
  }

  export type LabelInclude = {
    labelType?: boolean | LabelTypeArgs
    country?: boolean | CountryArgs
    region?: boolean | RegionArgs
    wine_type?: boolean | WineTypeArgs
    label_grape?: boolean | LabelGrapeFindManyArgs
    order_label?: boolean | OrderLabelFindManyArgs
    label_campaign?: boolean | LabelCampaignFindManyArgs
    StockLabel?: boolean | StockLabelFindManyArgs
    StockHistory?: boolean | StockHistoryFindManyArgs
    _count?: boolean | LabelCountOutputTypeArgs
  }

  export type LabelGetPayload<
    S extends boolean | null | undefined | LabelArgs,
    U = keyof S
      > = S extends true
        ? Label
    : S extends undefined
    ? never
    : S extends LabelArgs | LabelFindManyArgs
    ?'include' extends U
    ? Label  & {
    [P in TrueKeys<S['include']>]:
        P extends 'labelType' ? LabelTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'country' ? CountryGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'region' ? RegionGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'wine_type' ? WineTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'label_grape' ? Array < LabelGrapeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'order_label' ? Array < OrderLabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'label_campaign' ? Array < LabelCampaignGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'StockLabel' ? Array < StockLabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'StockHistory' ? Array < StockHistoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? LabelCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'labelType' ? LabelTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'country' ? CountryGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'region' ? RegionGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'wine_type' ? WineTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'label_grape' ? Array < LabelGrapeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'order_label' ? Array < OrderLabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'label_campaign' ? Array < LabelCampaignGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'StockLabel' ? Array < StockLabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'StockHistory' ? Array < StockHistoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? LabelCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Label ? Label[P] : never
  } 
    : Label
  : Label


  type LabelCountArgs = Merge<
    Omit<LabelFindManyArgs, 'select' | 'include'> & {
      select?: LabelCountAggregateInputType | true
    }
  >

  export interface LabelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LabelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LabelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Label'> extends True ? CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>> : CheckSelect<T, Prisma__LabelClient<Label | null, null>, Prisma__LabelClient<LabelGetPayload<T> | null, null>>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LabelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LabelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Label'> extends True ? CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>> : CheckSelect<T, Prisma__LabelClient<Label | null, null>, Prisma__LabelClient<LabelGetPayload<T> | null, null>>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LabelFindManyArgs>(
      args?: SelectSubset<T, LabelFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Label>>, PrismaPromise<Array<LabelGetPayload<T>>>>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
    **/
    create<T extends LabelCreateArgs>(
      args: SelectSubset<T, LabelCreateArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Create many Labels.
     *     @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     *     @example
     *     // Create many Labels
     *     const label = await prisma.label.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LabelCreateManyArgs>(
      args?: SelectSubset<T, LabelCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
    **/
    delete<T extends LabelDeleteArgs>(
      args: SelectSubset<T, LabelDeleteArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LabelUpdateArgs>(
      args: SelectSubset<T, LabelUpdateArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LabelDeleteManyArgs>(
      args?: SelectSubset<T, LabelDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LabelUpdateManyArgs>(
      args: SelectSubset<T, LabelUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
    **/
    upsert<T extends LabelUpsertArgs>(
      args: SelectSubset<T, LabelUpsertArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Find one Label that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LabelFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Find the first Label that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LabelFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LabelClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    labelType<T extends LabelTypeArgs = {}>(args?: Subset<T, LabelTypeArgs>): CheckSelect<T, Prisma__LabelTypeClient<LabelType | Null>, Prisma__LabelTypeClient<LabelTypeGetPayload<T> | Null>>;

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | Null>, Prisma__CountryClient<CountryGetPayload<T> | Null>>;

    region<T extends RegionArgs = {}>(args?: Subset<T, RegionArgs>): CheckSelect<T, Prisma__RegionClient<Region | Null>, Prisma__RegionClient<RegionGetPayload<T> | Null>>;

    wine_type<T extends WineTypeArgs = {}>(args?: Subset<T, WineTypeArgs>): CheckSelect<T, Prisma__WineTypeClient<WineType | Null>, Prisma__WineTypeClient<WineTypeGetPayload<T> | Null>>;

    label_grape<T extends LabelGrapeFindManyArgs = {}>(args?: Subset<T, LabelGrapeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LabelGrape>| Null>, PrismaPromise<Array<LabelGrapeGetPayload<T>>| Null>>;

    order_label<T extends OrderLabelFindManyArgs = {}>(args?: Subset<T, OrderLabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderLabel>| Null>, PrismaPromise<Array<OrderLabelGetPayload<T>>| Null>>;

    label_campaign<T extends LabelCampaignFindManyArgs = {}>(args?: Subset<T, LabelCampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LabelCampaign>| Null>, PrismaPromise<Array<LabelCampaignGetPayload<T>>| Null>>;

    StockLabel<T extends StockLabelFindManyArgs = {}>(args?: Subset<T, StockLabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StockLabel>| Null>, PrismaPromise<Array<StockLabelGetPayload<T>>| Null>>;

    StockHistory<T extends StockHistoryFindManyArgs = {}>(args?: Subset<T, StockHistoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StockHistory>| Null>, PrismaPromise<Array<StockHistoryGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Label base type for findUnique actions
   */
  export type LabelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Filter, which Label to fetch.
     * 
    **/
    where: LabelWhereUniqueInput
  }

  /**
   * Label: findUnique
   */
  export interface LabelFindUniqueArgs extends LabelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Label base type for findFirst actions
   */
  export type LabelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Filter, which Label to fetch.
     * 
    **/
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     * 
    **/
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     * 
    **/
    distinct?: Enumerable<LabelScalarFieldEnum>
  }

  /**
   * Label: findFirst
   */
  export interface LabelFindFirstArgs extends LabelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Label findMany
   */
  export type LabelFindManyArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Filter, which Labels to fetch.
     * 
    **/
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     * 
    **/
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LabelScalarFieldEnum>
  }


  /**
   * Label create
   */
  export type LabelCreateArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * The data needed to create a Label.
     * 
    **/
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }


  /**
   * Label createMany
   */
  export type LabelCreateManyArgs = {
    /**
     * The data used to create many Labels.
     * 
    **/
    data: Enumerable<LabelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Label update
   */
  export type LabelUpdateArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * The data needed to update a Label.
     * 
    **/
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     * 
    **/
    where: LabelWhereUniqueInput
  }


  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs = {
    /**
     * The data used to update Labels.
     * 
    **/
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     * 
    **/
    where?: LabelWhereInput
  }


  /**
   * Label upsert
   */
  export type LabelUpsertArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * The filter to search for the Label to update in case it exists.
     * 
    **/
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     * 
    **/
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }


  /**
   * Label delete
   */
  export type LabelDeleteArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Filter which Label to delete.
     * 
    **/
    where: LabelWhereUniqueInput
  }


  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs = {
    /**
     * Filter which Labels to delete
     * 
    **/
    where?: LabelWhereInput
  }


  /**
   * Label: findUniqueOrThrow
   */
  export type LabelFindUniqueOrThrowArgs = LabelFindUniqueArgsBase
      

  /**
   * Label: findFirstOrThrow
   */
  export type LabelFindFirstOrThrowArgs = LabelFindFirstArgsBase
      

  /**
   * Label without action
   */
  export type LabelArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
  }



  /**
   * Model LabelCampaign
   */


  export type AggregateLabelCampaign = {
    _count: LabelCampaignCountAggregateOutputType | null
    _min: LabelCampaignMinAggregateOutputType | null
    _max: LabelCampaignMaxAggregateOutputType | null
  }

  export type LabelCampaignMinAggregateOutputType = {
    label_id: string | null
    campaign_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelCampaignMaxAggregateOutputType = {
    label_id: string | null
    campaign_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelCampaignCountAggregateOutputType = {
    label_id: number
    campaign_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LabelCampaignMinAggregateInputType = {
    label_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelCampaignMaxAggregateInputType = {
    label_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelCampaignCountAggregateInputType = {
    label_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LabelCampaignAggregateArgs = {
    /**
     * Filter which LabelCampaign to aggregate.
     * 
    **/
    where?: LabelCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelCampaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelCampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LabelCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelCampaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelCampaigns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabelCampaigns
    **/
    _count?: true | LabelCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelCampaignMaxAggregateInputType
  }

  export type GetLabelCampaignAggregateType<T extends LabelCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateLabelCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabelCampaign[P]>
      : GetScalarType<T[P], AggregateLabelCampaign[P]>
  }




  export type LabelCampaignGroupByArgs = {
    where?: LabelCampaignWhereInput
    orderBy?: Enumerable<LabelCampaignOrderByWithAggregationInput>
    by: Array<LabelCampaignScalarFieldEnum>
    having?: LabelCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCampaignCountAggregateInputType | true
    _min?: LabelCampaignMinAggregateInputType
    _max?: LabelCampaignMaxAggregateInputType
  }


  export type LabelCampaignGroupByOutputType = {
    label_id: string
    campaign_id: string
    created_at: Date
    updated_at: Date
    _count: LabelCampaignCountAggregateOutputType | null
    _min: LabelCampaignMinAggregateOutputType | null
    _max: LabelCampaignMaxAggregateOutputType | null
  }

  type GetLabelCampaignGroupByPayload<T extends LabelCampaignGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LabelCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], LabelCampaignGroupByOutputType[P]>
        }
      >
    >


  export type LabelCampaignSelect = {
    label_id?: boolean
    label?: boolean | LabelArgs
    campaign_id?: boolean
    campaign?: boolean | CampaignArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type LabelCampaignInclude = {
    label?: boolean | LabelArgs
    campaign?: boolean | CampaignArgs
  }

  export type LabelCampaignGetPayload<
    S extends boolean | null | undefined | LabelCampaignArgs,
    U = keyof S
      > = S extends true
        ? LabelCampaign
    : S extends undefined
    ? never
    : S extends LabelCampaignArgs | LabelCampaignFindManyArgs
    ?'include' extends U
    ? LabelCampaign  & {
    [P in TrueKeys<S['include']>]:
        P extends 'label' ? LabelGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'campaign' ? CampaignGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'label' ? LabelGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'campaign' ? CampaignGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof LabelCampaign ? LabelCampaign[P] : never
  } 
    : LabelCampaign
  : LabelCampaign


  type LabelCampaignCountArgs = Merge<
    Omit<LabelCampaignFindManyArgs, 'select' | 'include'> & {
      select?: LabelCampaignCountAggregateInputType | true
    }
  >

  export interface LabelCampaignDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one LabelCampaign that matches the filter.
     * @param {LabelCampaignFindUniqueArgs} args - Arguments to find a LabelCampaign
     * @example
     * // Get one LabelCampaign
     * const labelCampaign = await prisma.labelCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LabelCampaignFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LabelCampaignFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LabelCampaign'> extends True ? CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>> : CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign | null, null>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T> | null, null>>

    /**
     * Find the first LabelCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCampaignFindFirstArgs} args - Arguments to find a LabelCampaign
     * @example
     * // Get one LabelCampaign
     * const labelCampaign = await prisma.labelCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LabelCampaignFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LabelCampaignFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LabelCampaign'> extends True ? CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>> : CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign | null, null>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T> | null, null>>

    /**
     * Find zero or more LabelCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabelCampaigns
     * const labelCampaigns = await prisma.labelCampaign.findMany()
     * 
     * // Get first 10 LabelCampaigns
     * const labelCampaigns = await prisma.labelCampaign.findMany({ take: 10 })
     * 
     * // Only select the `label_id`
     * const labelCampaignWithLabel_idOnly = await prisma.labelCampaign.findMany({ select: { label_id: true } })
     * 
    **/
    findMany<T extends LabelCampaignFindManyArgs>(
      args?: SelectSubset<T, LabelCampaignFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LabelCampaign>>, PrismaPromise<Array<LabelCampaignGetPayload<T>>>>

    /**
     * Create a LabelCampaign.
     * @param {LabelCampaignCreateArgs} args - Arguments to create a LabelCampaign.
     * @example
     * // Create one LabelCampaign
     * const LabelCampaign = await prisma.labelCampaign.create({
     *   data: {
     *     // ... data to create a LabelCampaign
     *   }
     * })
     * 
    **/
    create<T extends LabelCampaignCreateArgs>(
      args: SelectSubset<T, LabelCampaignCreateArgs>
    ): CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>>

    /**
     * Create many LabelCampaigns.
     *     @param {LabelCampaignCreateManyArgs} args - Arguments to create many LabelCampaigns.
     *     @example
     *     // Create many LabelCampaigns
     *     const labelCampaign = await prisma.labelCampaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LabelCampaignCreateManyArgs>(
      args?: SelectSubset<T, LabelCampaignCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LabelCampaign.
     * @param {LabelCampaignDeleteArgs} args - Arguments to delete one LabelCampaign.
     * @example
     * // Delete one LabelCampaign
     * const LabelCampaign = await prisma.labelCampaign.delete({
     *   where: {
     *     // ... filter to delete one LabelCampaign
     *   }
     * })
     * 
    **/
    delete<T extends LabelCampaignDeleteArgs>(
      args: SelectSubset<T, LabelCampaignDeleteArgs>
    ): CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>>

    /**
     * Update one LabelCampaign.
     * @param {LabelCampaignUpdateArgs} args - Arguments to update one LabelCampaign.
     * @example
     * // Update one LabelCampaign
     * const labelCampaign = await prisma.labelCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LabelCampaignUpdateArgs>(
      args: SelectSubset<T, LabelCampaignUpdateArgs>
    ): CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>>

    /**
     * Delete zero or more LabelCampaigns.
     * @param {LabelCampaignDeleteManyArgs} args - Arguments to filter LabelCampaigns to delete.
     * @example
     * // Delete a few LabelCampaigns
     * const { count } = await prisma.labelCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LabelCampaignDeleteManyArgs>(
      args?: SelectSubset<T, LabelCampaignDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabelCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabelCampaigns
     * const labelCampaign = await prisma.labelCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LabelCampaignUpdateManyArgs>(
      args: SelectSubset<T, LabelCampaignUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LabelCampaign.
     * @param {LabelCampaignUpsertArgs} args - Arguments to update or create a LabelCampaign.
     * @example
     * // Update or create a LabelCampaign
     * const labelCampaign = await prisma.labelCampaign.upsert({
     *   create: {
     *     // ... data to create a LabelCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabelCampaign we want to update
     *   }
     * })
    **/
    upsert<T extends LabelCampaignUpsertArgs>(
      args: SelectSubset<T, LabelCampaignUpsertArgs>
    ): CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>>

    /**
     * Find one LabelCampaign that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LabelCampaignFindUniqueOrThrowArgs} args - Arguments to find a LabelCampaign
     * @example
     * // Get one LabelCampaign
     * const labelCampaign = await prisma.labelCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LabelCampaignFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LabelCampaignFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>>

    /**
     * Find the first LabelCampaign that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCampaignFindFirstOrThrowArgs} args - Arguments to find a LabelCampaign
     * @example
     * // Get one LabelCampaign
     * const labelCampaign = await prisma.labelCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LabelCampaignFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LabelCampaignFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelCampaignClient<LabelCampaign>, Prisma__LabelCampaignClient<LabelCampaignGetPayload<T>>>

    /**
     * Count the number of LabelCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCampaignCountArgs} args - Arguments to filter LabelCampaigns to count.
     * @example
     * // Count the number of LabelCampaigns
     * const count = await prisma.labelCampaign.count({
     *   where: {
     *     // ... the filter for the LabelCampaigns we want to count
     *   }
     * })
    **/
    count<T extends LabelCampaignCountArgs>(
      args?: Subset<T, LabelCampaignCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabelCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelCampaignAggregateArgs>(args: Subset<T, LabelCampaignAggregateArgs>): PrismaPromise<GetLabelCampaignAggregateType<T>>

    /**
     * Group by LabelCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelCampaignGroupByArgs['orderBy'] }
        : { orderBy?: LabelCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelCampaignGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LabelCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LabelCampaignClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    label<T extends LabelArgs = {}>(args?: Subset<T, LabelArgs>): CheckSelect<T, Prisma__LabelClient<Label | Null>, Prisma__LabelClient<LabelGetPayload<T> | Null>>;

    campaign<T extends CampaignArgs = {}>(args?: Subset<T, CampaignArgs>): CheckSelect<T, Prisma__CampaignClient<Campaign | Null>, Prisma__CampaignClient<CampaignGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LabelCampaign base type for findUnique actions
   */
  export type LabelCampaignFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
    /**
     * Filter, which LabelCampaign to fetch.
     * 
    **/
    where: LabelCampaignWhereUniqueInput
  }

  /**
   * LabelCampaign: findUnique
   */
  export interface LabelCampaignFindUniqueArgs extends LabelCampaignFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LabelCampaign base type for findFirst actions
   */
  export type LabelCampaignFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
    /**
     * Filter, which LabelCampaign to fetch.
     * 
    **/
    where?: LabelCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelCampaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelCampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabelCampaigns.
     * 
    **/
    cursor?: LabelCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelCampaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelCampaigns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabelCampaigns.
     * 
    **/
    distinct?: Enumerable<LabelCampaignScalarFieldEnum>
  }

  /**
   * LabelCampaign: findFirst
   */
  export interface LabelCampaignFindFirstArgs extends LabelCampaignFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LabelCampaign findMany
   */
  export type LabelCampaignFindManyArgs = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
    /**
     * Filter, which LabelCampaigns to fetch.
     * 
    **/
    where?: LabelCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelCampaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelCampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabelCampaigns.
     * 
    **/
    cursor?: LabelCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelCampaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelCampaigns.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LabelCampaignScalarFieldEnum>
  }


  /**
   * LabelCampaign create
   */
  export type LabelCampaignCreateArgs = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
    /**
     * The data needed to create a LabelCampaign.
     * 
    **/
    data: XOR<LabelCampaignCreateInput, LabelCampaignUncheckedCreateInput>
  }


  /**
   * LabelCampaign createMany
   */
  export type LabelCampaignCreateManyArgs = {
    /**
     * The data used to create many LabelCampaigns.
     * 
    **/
    data: Enumerable<LabelCampaignCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LabelCampaign update
   */
  export type LabelCampaignUpdateArgs = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
    /**
     * The data needed to update a LabelCampaign.
     * 
    **/
    data: XOR<LabelCampaignUpdateInput, LabelCampaignUncheckedUpdateInput>
    /**
     * Choose, which LabelCampaign to update.
     * 
    **/
    where: LabelCampaignWhereUniqueInput
  }


  /**
   * LabelCampaign updateMany
   */
  export type LabelCampaignUpdateManyArgs = {
    /**
     * The data used to update LabelCampaigns.
     * 
    **/
    data: XOR<LabelCampaignUpdateManyMutationInput, LabelCampaignUncheckedUpdateManyInput>
    /**
     * Filter which LabelCampaigns to update
     * 
    **/
    where?: LabelCampaignWhereInput
  }


  /**
   * LabelCampaign upsert
   */
  export type LabelCampaignUpsertArgs = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
    /**
     * The filter to search for the LabelCampaign to update in case it exists.
     * 
    **/
    where: LabelCampaignWhereUniqueInput
    /**
     * In case the LabelCampaign found by the `where` argument doesn't exist, create a new LabelCampaign with this data.
     * 
    **/
    create: XOR<LabelCampaignCreateInput, LabelCampaignUncheckedCreateInput>
    /**
     * In case the LabelCampaign was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LabelCampaignUpdateInput, LabelCampaignUncheckedUpdateInput>
  }


  /**
   * LabelCampaign delete
   */
  export type LabelCampaignDeleteArgs = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
    /**
     * Filter which LabelCampaign to delete.
     * 
    **/
    where: LabelCampaignWhereUniqueInput
  }


  /**
   * LabelCampaign deleteMany
   */
  export type LabelCampaignDeleteManyArgs = {
    /**
     * Filter which LabelCampaigns to delete
     * 
    **/
    where?: LabelCampaignWhereInput
  }


  /**
   * LabelCampaign: findUniqueOrThrow
   */
  export type LabelCampaignFindUniqueOrThrowArgs = LabelCampaignFindUniqueArgsBase
      

  /**
   * LabelCampaign: findFirstOrThrow
   */
  export type LabelCampaignFindFirstOrThrowArgs = LabelCampaignFindFirstArgsBase
      

  /**
   * LabelCampaign without action
   */
  export type LabelCampaignArgs = {
    /**
     * Select specific fields to fetch from the LabelCampaign
     * 
    **/
    select?: LabelCampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelCampaignInclude | null
  }



  /**
   * Model LabelGrape
   */


  export type AggregateLabelGrape = {
    _count: LabelGrapeCountAggregateOutputType | null
    _min: LabelGrapeMinAggregateOutputType | null
    _max: LabelGrapeMaxAggregateOutputType | null
  }

  export type LabelGrapeMinAggregateOutputType = {
    label_id: string | null
    grape_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelGrapeMaxAggregateOutputType = {
    label_id: string | null
    grape_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelGrapeCountAggregateOutputType = {
    label_id: number
    grape_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LabelGrapeMinAggregateInputType = {
    label_id?: true
    grape_id?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelGrapeMaxAggregateInputType = {
    label_id?: true
    grape_id?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelGrapeCountAggregateInputType = {
    label_id?: true
    grape_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LabelGrapeAggregateArgs = {
    /**
     * Filter which LabelGrape to aggregate.
     * 
    **/
    where?: LabelGrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelGrapes to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelGrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LabelGrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelGrapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelGrapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabelGrapes
    **/
    _count?: true | LabelGrapeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelGrapeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelGrapeMaxAggregateInputType
  }

  export type GetLabelGrapeAggregateType<T extends LabelGrapeAggregateArgs> = {
        [P in keyof T & keyof AggregateLabelGrape]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabelGrape[P]>
      : GetScalarType<T[P], AggregateLabelGrape[P]>
  }




  export type LabelGrapeGroupByArgs = {
    where?: LabelGrapeWhereInput
    orderBy?: Enumerable<LabelGrapeOrderByWithAggregationInput>
    by: Array<LabelGrapeScalarFieldEnum>
    having?: LabelGrapeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelGrapeCountAggregateInputType | true
    _min?: LabelGrapeMinAggregateInputType
    _max?: LabelGrapeMaxAggregateInputType
  }


  export type LabelGrapeGroupByOutputType = {
    label_id: string
    grape_id: string
    created_at: Date
    updated_at: Date
    _count: LabelGrapeCountAggregateOutputType | null
    _min: LabelGrapeMinAggregateOutputType | null
    _max: LabelGrapeMaxAggregateOutputType | null
  }

  type GetLabelGrapeGroupByPayload<T extends LabelGrapeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LabelGrapeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGrapeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGrapeGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGrapeGroupByOutputType[P]>
        }
      >
    >


  export type LabelGrapeSelect = {
    label_id?: boolean
    label?: boolean | LabelArgs
    grape_id?: boolean
    grape?: boolean | GrapeArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type LabelGrapeInclude = {
    label?: boolean | LabelArgs
    grape?: boolean | GrapeArgs
  }

  export type LabelGrapeGetPayload<
    S extends boolean | null | undefined | LabelGrapeArgs,
    U = keyof S
      > = S extends true
        ? LabelGrape
    : S extends undefined
    ? never
    : S extends LabelGrapeArgs | LabelGrapeFindManyArgs
    ?'include' extends U
    ? LabelGrape  & {
    [P in TrueKeys<S['include']>]:
        P extends 'label' ? LabelGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'grape' ? GrapeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'label' ? LabelGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'grape' ? GrapeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof LabelGrape ? LabelGrape[P] : never
  } 
    : LabelGrape
  : LabelGrape


  type LabelGrapeCountArgs = Merge<
    Omit<LabelGrapeFindManyArgs, 'select' | 'include'> & {
      select?: LabelGrapeCountAggregateInputType | true
    }
  >

  export interface LabelGrapeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one LabelGrape that matches the filter.
     * @param {LabelGrapeFindUniqueArgs} args - Arguments to find a LabelGrape
     * @example
     * // Get one LabelGrape
     * const labelGrape = await prisma.labelGrape.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LabelGrapeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LabelGrapeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LabelGrape'> extends True ? CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>> : CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape | null, null>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T> | null, null>>

    /**
     * Find the first LabelGrape that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGrapeFindFirstArgs} args - Arguments to find a LabelGrape
     * @example
     * // Get one LabelGrape
     * const labelGrape = await prisma.labelGrape.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LabelGrapeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LabelGrapeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LabelGrape'> extends True ? CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>> : CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape | null, null>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T> | null, null>>

    /**
     * Find zero or more LabelGrapes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGrapeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabelGrapes
     * const labelGrapes = await prisma.labelGrape.findMany()
     * 
     * // Get first 10 LabelGrapes
     * const labelGrapes = await prisma.labelGrape.findMany({ take: 10 })
     * 
     * // Only select the `label_id`
     * const labelGrapeWithLabel_idOnly = await prisma.labelGrape.findMany({ select: { label_id: true } })
     * 
    **/
    findMany<T extends LabelGrapeFindManyArgs>(
      args?: SelectSubset<T, LabelGrapeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LabelGrape>>, PrismaPromise<Array<LabelGrapeGetPayload<T>>>>

    /**
     * Create a LabelGrape.
     * @param {LabelGrapeCreateArgs} args - Arguments to create a LabelGrape.
     * @example
     * // Create one LabelGrape
     * const LabelGrape = await prisma.labelGrape.create({
     *   data: {
     *     // ... data to create a LabelGrape
     *   }
     * })
     * 
    **/
    create<T extends LabelGrapeCreateArgs>(
      args: SelectSubset<T, LabelGrapeCreateArgs>
    ): CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>>

    /**
     * Create many LabelGrapes.
     *     @param {LabelGrapeCreateManyArgs} args - Arguments to create many LabelGrapes.
     *     @example
     *     // Create many LabelGrapes
     *     const labelGrape = await prisma.labelGrape.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LabelGrapeCreateManyArgs>(
      args?: SelectSubset<T, LabelGrapeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LabelGrape.
     * @param {LabelGrapeDeleteArgs} args - Arguments to delete one LabelGrape.
     * @example
     * // Delete one LabelGrape
     * const LabelGrape = await prisma.labelGrape.delete({
     *   where: {
     *     // ... filter to delete one LabelGrape
     *   }
     * })
     * 
    **/
    delete<T extends LabelGrapeDeleteArgs>(
      args: SelectSubset<T, LabelGrapeDeleteArgs>
    ): CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>>

    /**
     * Update one LabelGrape.
     * @param {LabelGrapeUpdateArgs} args - Arguments to update one LabelGrape.
     * @example
     * // Update one LabelGrape
     * const labelGrape = await prisma.labelGrape.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LabelGrapeUpdateArgs>(
      args: SelectSubset<T, LabelGrapeUpdateArgs>
    ): CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>>

    /**
     * Delete zero or more LabelGrapes.
     * @param {LabelGrapeDeleteManyArgs} args - Arguments to filter LabelGrapes to delete.
     * @example
     * // Delete a few LabelGrapes
     * const { count } = await prisma.labelGrape.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LabelGrapeDeleteManyArgs>(
      args?: SelectSubset<T, LabelGrapeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabelGrapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGrapeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabelGrapes
     * const labelGrape = await prisma.labelGrape.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LabelGrapeUpdateManyArgs>(
      args: SelectSubset<T, LabelGrapeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LabelGrape.
     * @param {LabelGrapeUpsertArgs} args - Arguments to update or create a LabelGrape.
     * @example
     * // Update or create a LabelGrape
     * const labelGrape = await prisma.labelGrape.upsert({
     *   create: {
     *     // ... data to create a LabelGrape
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabelGrape we want to update
     *   }
     * })
    **/
    upsert<T extends LabelGrapeUpsertArgs>(
      args: SelectSubset<T, LabelGrapeUpsertArgs>
    ): CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>>

    /**
     * Find one LabelGrape that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LabelGrapeFindUniqueOrThrowArgs} args - Arguments to find a LabelGrape
     * @example
     * // Get one LabelGrape
     * const labelGrape = await prisma.labelGrape.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LabelGrapeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LabelGrapeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>>

    /**
     * Find the first LabelGrape that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGrapeFindFirstOrThrowArgs} args - Arguments to find a LabelGrape
     * @example
     * // Get one LabelGrape
     * const labelGrape = await prisma.labelGrape.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LabelGrapeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LabelGrapeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelGrapeClient<LabelGrape>, Prisma__LabelGrapeClient<LabelGrapeGetPayload<T>>>

    /**
     * Count the number of LabelGrapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGrapeCountArgs} args - Arguments to filter LabelGrapes to count.
     * @example
     * // Count the number of LabelGrapes
     * const count = await prisma.labelGrape.count({
     *   where: {
     *     // ... the filter for the LabelGrapes we want to count
     *   }
     * })
    **/
    count<T extends LabelGrapeCountArgs>(
      args?: Subset<T, LabelGrapeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelGrapeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabelGrape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGrapeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelGrapeAggregateArgs>(args: Subset<T, LabelGrapeAggregateArgs>): PrismaPromise<GetLabelGrapeAggregateType<T>>

    /**
     * Group by LabelGrape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGrapeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGrapeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGrapeGroupByArgs['orderBy'] }
        : { orderBy?: LabelGrapeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGrapeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGrapeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LabelGrape.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LabelGrapeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    label<T extends LabelArgs = {}>(args?: Subset<T, LabelArgs>): CheckSelect<T, Prisma__LabelClient<Label | Null>, Prisma__LabelClient<LabelGetPayload<T> | Null>>;

    grape<T extends GrapeArgs = {}>(args?: Subset<T, GrapeArgs>): CheckSelect<T, Prisma__GrapeClient<Grape | Null>, Prisma__GrapeClient<GrapeGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LabelGrape base type for findUnique actions
   */
  export type LabelGrapeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
    /**
     * Filter, which LabelGrape to fetch.
     * 
    **/
    where: LabelGrapeWhereUniqueInput
  }

  /**
   * LabelGrape: findUnique
   */
  export interface LabelGrapeFindUniqueArgs extends LabelGrapeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LabelGrape base type for findFirst actions
   */
  export type LabelGrapeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
    /**
     * Filter, which LabelGrape to fetch.
     * 
    **/
    where?: LabelGrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelGrapes to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelGrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabelGrapes.
     * 
    **/
    cursor?: LabelGrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelGrapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelGrapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabelGrapes.
     * 
    **/
    distinct?: Enumerable<LabelGrapeScalarFieldEnum>
  }

  /**
   * LabelGrape: findFirst
   */
  export interface LabelGrapeFindFirstArgs extends LabelGrapeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LabelGrape findMany
   */
  export type LabelGrapeFindManyArgs = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
    /**
     * Filter, which LabelGrapes to fetch.
     * 
    **/
    where?: LabelGrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelGrapes to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelGrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabelGrapes.
     * 
    **/
    cursor?: LabelGrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelGrapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelGrapes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LabelGrapeScalarFieldEnum>
  }


  /**
   * LabelGrape create
   */
  export type LabelGrapeCreateArgs = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
    /**
     * The data needed to create a LabelGrape.
     * 
    **/
    data: XOR<LabelGrapeCreateInput, LabelGrapeUncheckedCreateInput>
  }


  /**
   * LabelGrape createMany
   */
  export type LabelGrapeCreateManyArgs = {
    /**
     * The data used to create many LabelGrapes.
     * 
    **/
    data: Enumerable<LabelGrapeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LabelGrape update
   */
  export type LabelGrapeUpdateArgs = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
    /**
     * The data needed to update a LabelGrape.
     * 
    **/
    data: XOR<LabelGrapeUpdateInput, LabelGrapeUncheckedUpdateInput>
    /**
     * Choose, which LabelGrape to update.
     * 
    **/
    where: LabelGrapeWhereUniqueInput
  }


  /**
   * LabelGrape updateMany
   */
  export type LabelGrapeUpdateManyArgs = {
    /**
     * The data used to update LabelGrapes.
     * 
    **/
    data: XOR<LabelGrapeUpdateManyMutationInput, LabelGrapeUncheckedUpdateManyInput>
    /**
     * Filter which LabelGrapes to update
     * 
    **/
    where?: LabelGrapeWhereInput
  }


  /**
   * LabelGrape upsert
   */
  export type LabelGrapeUpsertArgs = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
    /**
     * The filter to search for the LabelGrape to update in case it exists.
     * 
    **/
    where: LabelGrapeWhereUniqueInput
    /**
     * In case the LabelGrape found by the `where` argument doesn't exist, create a new LabelGrape with this data.
     * 
    **/
    create: XOR<LabelGrapeCreateInput, LabelGrapeUncheckedCreateInput>
    /**
     * In case the LabelGrape was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LabelGrapeUpdateInput, LabelGrapeUncheckedUpdateInput>
  }


  /**
   * LabelGrape delete
   */
  export type LabelGrapeDeleteArgs = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
    /**
     * Filter which LabelGrape to delete.
     * 
    **/
    where: LabelGrapeWhereUniqueInput
  }


  /**
   * LabelGrape deleteMany
   */
  export type LabelGrapeDeleteManyArgs = {
    /**
     * Filter which LabelGrapes to delete
     * 
    **/
    where?: LabelGrapeWhereInput
  }


  /**
   * LabelGrape: findUniqueOrThrow
   */
  export type LabelGrapeFindUniqueOrThrowArgs = LabelGrapeFindUniqueArgsBase
      

  /**
   * LabelGrape: findFirstOrThrow
   */
  export type LabelGrapeFindFirstOrThrowArgs = LabelGrapeFindFirstArgsBase
      

  /**
   * LabelGrape without action
   */
  export type LabelGrapeArgs = {
    /**
     * Select specific fields to fetch from the LabelGrape
     * 
    **/
    select?: LabelGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelGrapeInclude | null
  }



  /**
   * Model Grape
   */


  export type AggregateGrape = {
    _count: GrapeCountAggregateOutputType | null
    _min: GrapeMinAggregateOutputType | null
    _max: GrapeMaxAggregateOutputType | null
  }

  export type GrapeMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type GrapeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type GrapeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updatedAt: number
    _all: number
  }


  export type GrapeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updatedAt?: true
  }

  export type GrapeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updatedAt?: true
  }

  export type GrapeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updatedAt?: true
    _all?: true
  }

  export type GrapeAggregateArgs = {
    /**
     * Filter which Grape to aggregate.
     * 
    **/
    where?: GrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grapes to fetch.
     * 
    **/
    orderBy?: Enumerable<GrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grapes
    **/
    _count?: true | GrapeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrapeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrapeMaxAggregateInputType
  }

  export type GetGrapeAggregateType<T extends GrapeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrape]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrape[P]>
      : GetScalarType<T[P], AggregateGrape[P]>
  }




  export type GrapeGroupByArgs = {
    where?: GrapeWhereInput
    orderBy?: Enumerable<GrapeOrderByWithAggregationInput>
    by: Array<GrapeScalarFieldEnum>
    having?: GrapeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrapeCountAggregateInputType | true
    _min?: GrapeMinAggregateInputType
    _max?: GrapeMaxAggregateInputType
  }


  export type GrapeGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updatedAt: Date
    _count: GrapeCountAggregateOutputType | null
    _min: GrapeMinAggregateOutputType | null
    _max: GrapeMaxAggregateOutputType | null
  }

  type GetGrapeGroupByPayload<T extends GrapeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GrapeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrapeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrapeGroupByOutputType[P]>
            : GetScalarType<T[P], GrapeGroupByOutputType[P]>
        }
      >
    >


  export type GrapeSelect = {
    id?: boolean
    name?: boolean
    LabelGrape?: boolean | LabelGrapeFindManyArgs
    created_at?: boolean
    updatedAt?: boolean
    _count?: boolean | GrapeCountOutputTypeArgs
  }

  export type GrapeInclude = {
    LabelGrape?: boolean | LabelGrapeFindManyArgs
    _count?: boolean | GrapeCountOutputTypeArgs
  }

  export type GrapeGetPayload<
    S extends boolean | null | undefined | GrapeArgs,
    U = keyof S
      > = S extends true
        ? Grape
    : S extends undefined
    ? never
    : S extends GrapeArgs | GrapeFindManyArgs
    ?'include' extends U
    ? Grape  & {
    [P in TrueKeys<S['include']>]:
        P extends 'LabelGrape' ? Array < LabelGrapeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? GrapeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'LabelGrape' ? Array < LabelGrapeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? GrapeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Grape ? Grape[P] : never
  } 
    : Grape
  : Grape


  type GrapeCountArgs = Merge<
    Omit<GrapeFindManyArgs, 'select' | 'include'> & {
      select?: GrapeCountAggregateInputType | true
    }
  >

  export interface GrapeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Grape that matches the filter.
     * @param {GrapeFindUniqueArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GrapeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GrapeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Grape'> extends True ? CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>> : CheckSelect<T, Prisma__GrapeClient<Grape | null, null>, Prisma__GrapeClient<GrapeGetPayload<T> | null, null>>

    /**
     * Find the first Grape that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeFindFirstArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GrapeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GrapeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Grape'> extends True ? CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>> : CheckSelect<T, Prisma__GrapeClient<Grape | null, null>, Prisma__GrapeClient<GrapeGetPayload<T> | null, null>>

    /**
     * Find zero or more Grapes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grapes
     * const grapes = await prisma.grape.findMany()
     * 
     * // Get first 10 Grapes
     * const grapes = await prisma.grape.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grapeWithIdOnly = await prisma.grape.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GrapeFindManyArgs>(
      args?: SelectSubset<T, GrapeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Grape>>, PrismaPromise<Array<GrapeGetPayload<T>>>>

    /**
     * Create a Grape.
     * @param {GrapeCreateArgs} args - Arguments to create a Grape.
     * @example
     * // Create one Grape
     * const Grape = await prisma.grape.create({
     *   data: {
     *     // ... data to create a Grape
     *   }
     * })
     * 
    **/
    create<T extends GrapeCreateArgs>(
      args: SelectSubset<T, GrapeCreateArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Create many Grapes.
     *     @param {GrapeCreateManyArgs} args - Arguments to create many Grapes.
     *     @example
     *     // Create many Grapes
     *     const grape = await prisma.grape.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GrapeCreateManyArgs>(
      args?: SelectSubset<T, GrapeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Grape.
     * @param {GrapeDeleteArgs} args - Arguments to delete one Grape.
     * @example
     * // Delete one Grape
     * const Grape = await prisma.grape.delete({
     *   where: {
     *     // ... filter to delete one Grape
     *   }
     * })
     * 
    **/
    delete<T extends GrapeDeleteArgs>(
      args: SelectSubset<T, GrapeDeleteArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Update one Grape.
     * @param {GrapeUpdateArgs} args - Arguments to update one Grape.
     * @example
     * // Update one Grape
     * const grape = await prisma.grape.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GrapeUpdateArgs>(
      args: SelectSubset<T, GrapeUpdateArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Delete zero or more Grapes.
     * @param {GrapeDeleteManyArgs} args - Arguments to filter Grapes to delete.
     * @example
     * // Delete a few Grapes
     * const { count } = await prisma.grape.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GrapeDeleteManyArgs>(
      args?: SelectSubset<T, GrapeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grapes
     * const grape = await prisma.grape.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GrapeUpdateManyArgs>(
      args: SelectSubset<T, GrapeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Grape.
     * @param {GrapeUpsertArgs} args - Arguments to update or create a Grape.
     * @example
     * // Update or create a Grape
     * const grape = await prisma.grape.upsert({
     *   create: {
     *     // ... data to create a Grape
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grape we want to update
     *   }
     * })
    **/
    upsert<T extends GrapeUpsertArgs>(
      args: SelectSubset<T, GrapeUpsertArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Find one Grape that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GrapeFindUniqueOrThrowArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GrapeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GrapeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Find the first Grape that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeFindFirstOrThrowArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GrapeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GrapeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Count the number of Grapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeCountArgs} args - Arguments to filter Grapes to count.
     * @example
     * // Count the number of Grapes
     * const count = await prisma.grape.count({
     *   where: {
     *     // ... the filter for the Grapes we want to count
     *   }
     * })
    **/
    count<T extends GrapeCountArgs>(
      args?: Subset<T, GrapeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrapeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrapeAggregateArgs>(args: Subset<T, GrapeAggregateArgs>): PrismaPromise<GetGrapeAggregateType<T>>

    /**
     * Group by Grape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GrapeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GrapeGroupByArgs['orderBy'] }
        : { orderBy?: GrapeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GrapeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrapeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Grape.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GrapeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    LabelGrape<T extends LabelGrapeFindManyArgs = {}>(args?: Subset<T, LabelGrapeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LabelGrape>| Null>, PrismaPromise<Array<LabelGrapeGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Grape base type for findUnique actions
   */
  export type GrapeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter, which Grape to fetch.
     * 
    **/
    where: GrapeWhereUniqueInput
  }

  /**
   * Grape: findUnique
   */
  export interface GrapeFindUniqueArgs extends GrapeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Grape base type for findFirst actions
   */
  export type GrapeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter, which Grape to fetch.
     * 
    **/
    where?: GrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grapes to fetch.
     * 
    **/
    orderBy?: Enumerable<GrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grapes.
     * 
    **/
    cursor?: GrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grapes.
     * 
    **/
    distinct?: Enumerable<GrapeScalarFieldEnum>
  }

  /**
   * Grape: findFirst
   */
  export interface GrapeFindFirstArgs extends GrapeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Grape findMany
   */
  export type GrapeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter, which Grapes to fetch.
     * 
    **/
    where?: GrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grapes to fetch.
     * 
    **/
    orderBy?: Enumerable<GrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grapes.
     * 
    **/
    cursor?: GrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grapes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GrapeScalarFieldEnum>
  }


  /**
   * Grape create
   */
  export type GrapeCreateArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * The data needed to create a Grape.
     * 
    **/
    data: XOR<GrapeCreateInput, GrapeUncheckedCreateInput>
  }


  /**
   * Grape createMany
   */
  export type GrapeCreateManyArgs = {
    /**
     * The data used to create many Grapes.
     * 
    **/
    data: Enumerable<GrapeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Grape update
   */
  export type GrapeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * The data needed to update a Grape.
     * 
    **/
    data: XOR<GrapeUpdateInput, GrapeUncheckedUpdateInput>
    /**
     * Choose, which Grape to update.
     * 
    **/
    where: GrapeWhereUniqueInput
  }


  /**
   * Grape updateMany
   */
  export type GrapeUpdateManyArgs = {
    /**
     * The data used to update Grapes.
     * 
    **/
    data: XOR<GrapeUpdateManyMutationInput, GrapeUncheckedUpdateManyInput>
    /**
     * Filter which Grapes to update
     * 
    **/
    where?: GrapeWhereInput
  }


  /**
   * Grape upsert
   */
  export type GrapeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * The filter to search for the Grape to update in case it exists.
     * 
    **/
    where: GrapeWhereUniqueInput
    /**
     * In case the Grape found by the `where` argument doesn't exist, create a new Grape with this data.
     * 
    **/
    create: XOR<GrapeCreateInput, GrapeUncheckedCreateInput>
    /**
     * In case the Grape was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GrapeUpdateInput, GrapeUncheckedUpdateInput>
  }


  /**
   * Grape delete
   */
  export type GrapeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter which Grape to delete.
     * 
    **/
    where: GrapeWhereUniqueInput
  }


  /**
   * Grape deleteMany
   */
  export type GrapeDeleteManyArgs = {
    /**
     * Filter which Grapes to delete
     * 
    **/
    where?: GrapeWhereInput
  }


  /**
   * Grape: findUniqueOrThrow
   */
  export type GrapeFindUniqueOrThrowArgs = GrapeFindUniqueArgsBase
      

  /**
   * Grape: findFirstOrThrow
   */
  export type GrapeFindFirstOrThrowArgs = GrapeFindFirstArgsBase
      

  /**
   * Grape without action
   */
  export type GrapeArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
  }



  /**
   * Model LabelType
   */


  export type AggregateLabelType = {
    _count: LabelTypeCountAggregateOutputType | null
    _min: LabelTypeMinAggregateOutputType | null
    _max: LabelTypeMaxAggregateOutputType | null
  }

  export type LabelTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LabelTypeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LabelTypeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelTypeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type LabelTypeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LabelTypeAggregateArgs = {
    /**
     * Filter which LabelType to aggregate.
     * 
    **/
    where?: LabelTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LabelTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabelTypes
    **/
    _count?: true | LabelTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelTypeMaxAggregateInputType
  }

  export type GetLabelTypeAggregateType<T extends LabelTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLabelType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabelType[P]>
      : GetScalarType<T[P], AggregateLabelType[P]>
  }




  export type LabelTypeGroupByArgs = {
    where?: LabelTypeWhereInput
    orderBy?: Enumerable<LabelTypeOrderByWithAggregationInput>
    by: Array<LabelTypeScalarFieldEnum>
    having?: LabelTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelTypeCountAggregateInputType | true
    _min?: LabelTypeMinAggregateInputType
    _max?: LabelTypeMaxAggregateInputType
  }


  export type LabelTypeGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updated_at: Date
    _count: LabelTypeCountAggregateOutputType | null
    _min: LabelTypeMinAggregateOutputType | null
    _max: LabelTypeMaxAggregateOutputType | null
  }

  type GetLabelTypeGroupByPayload<T extends LabelTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LabelTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LabelTypeGroupByOutputType[P]>
        }
      >
    >


  export type LabelTypeSelect = {
    id?: boolean
    name?: boolean
    labels?: boolean | LabelFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | LabelTypeCountOutputTypeArgs
  }

  export type LabelTypeInclude = {
    labels?: boolean | LabelFindManyArgs
    _count?: boolean | LabelTypeCountOutputTypeArgs
  }

  export type LabelTypeGetPayload<
    S extends boolean | null | undefined | LabelTypeArgs,
    U = keyof S
      > = S extends true
        ? LabelType
    : S extends undefined
    ? never
    : S extends LabelTypeArgs | LabelTypeFindManyArgs
    ?'include' extends U
    ? LabelType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? LabelTypeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? LabelTypeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof LabelType ? LabelType[P] : never
  } 
    : LabelType
  : LabelType


  type LabelTypeCountArgs = Merge<
    Omit<LabelTypeFindManyArgs, 'select' | 'include'> & {
      select?: LabelTypeCountAggregateInputType | true
    }
  >

  export interface LabelTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one LabelType that matches the filter.
     * @param {LabelTypeFindUniqueArgs} args - Arguments to find a LabelType
     * @example
     * // Get one LabelType
     * const labelType = await prisma.labelType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LabelTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LabelTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LabelType'> extends True ? CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>> : CheckSelect<T, Prisma__LabelTypeClient<LabelType | null, null>, Prisma__LabelTypeClient<LabelTypeGetPayload<T> | null, null>>

    /**
     * Find the first LabelType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelTypeFindFirstArgs} args - Arguments to find a LabelType
     * @example
     * // Get one LabelType
     * const labelType = await prisma.labelType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LabelTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LabelTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LabelType'> extends True ? CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>> : CheckSelect<T, Prisma__LabelTypeClient<LabelType | null, null>, Prisma__LabelTypeClient<LabelTypeGetPayload<T> | null, null>>

    /**
     * Find zero or more LabelTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabelTypes
     * const labelTypes = await prisma.labelType.findMany()
     * 
     * // Get first 10 LabelTypes
     * const labelTypes = await prisma.labelType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelTypeWithIdOnly = await prisma.labelType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LabelTypeFindManyArgs>(
      args?: SelectSubset<T, LabelTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LabelType>>, PrismaPromise<Array<LabelTypeGetPayload<T>>>>

    /**
     * Create a LabelType.
     * @param {LabelTypeCreateArgs} args - Arguments to create a LabelType.
     * @example
     * // Create one LabelType
     * const LabelType = await prisma.labelType.create({
     *   data: {
     *     // ... data to create a LabelType
     *   }
     * })
     * 
    **/
    create<T extends LabelTypeCreateArgs>(
      args: SelectSubset<T, LabelTypeCreateArgs>
    ): CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>>

    /**
     * Create many LabelTypes.
     *     @param {LabelTypeCreateManyArgs} args - Arguments to create many LabelTypes.
     *     @example
     *     // Create many LabelTypes
     *     const labelType = await prisma.labelType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LabelTypeCreateManyArgs>(
      args?: SelectSubset<T, LabelTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LabelType.
     * @param {LabelTypeDeleteArgs} args - Arguments to delete one LabelType.
     * @example
     * // Delete one LabelType
     * const LabelType = await prisma.labelType.delete({
     *   where: {
     *     // ... filter to delete one LabelType
     *   }
     * })
     * 
    **/
    delete<T extends LabelTypeDeleteArgs>(
      args: SelectSubset<T, LabelTypeDeleteArgs>
    ): CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>>

    /**
     * Update one LabelType.
     * @param {LabelTypeUpdateArgs} args - Arguments to update one LabelType.
     * @example
     * // Update one LabelType
     * const labelType = await prisma.labelType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LabelTypeUpdateArgs>(
      args: SelectSubset<T, LabelTypeUpdateArgs>
    ): CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>>

    /**
     * Delete zero or more LabelTypes.
     * @param {LabelTypeDeleteManyArgs} args - Arguments to filter LabelTypes to delete.
     * @example
     * // Delete a few LabelTypes
     * const { count } = await prisma.labelType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LabelTypeDeleteManyArgs>(
      args?: SelectSubset<T, LabelTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabelTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabelTypes
     * const labelType = await prisma.labelType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LabelTypeUpdateManyArgs>(
      args: SelectSubset<T, LabelTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LabelType.
     * @param {LabelTypeUpsertArgs} args - Arguments to update or create a LabelType.
     * @example
     * // Update or create a LabelType
     * const labelType = await prisma.labelType.upsert({
     *   create: {
     *     // ... data to create a LabelType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabelType we want to update
     *   }
     * })
    **/
    upsert<T extends LabelTypeUpsertArgs>(
      args: SelectSubset<T, LabelTypeUpsertArgs>
    ): CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>>

    /**
     * Find one LabelType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {LabelTypeFindUniqueOrThrowArgs} args - Arguments to find a LabelType
     * @example
     * // Get one LabelType
     * const labelType = await prisma.labelType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LabelTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LabelTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>>

    /**
     * Find the first LabelType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelTypeFindFirstOrThrowArgs} args - Arguments to find a LabelType
     * @example
     * // Get one LabelType
     * const labelType = await prisma.labelType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LabelTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LabelTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__LabelTypeClient<LabelType>, Prisma__LabelTypeClient<LabelTypeGetPayload<T>>>

    /**
     * Count the number of LabelTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelTypeCountArgs} args - Arguments to filter LabelTypes to count.
     * @example
     * // Count the number of LabelTypes
     * const count = await prisma.labelType.count({
     *   where: {
     *     // ... the filter for the LabelTypes we want to count
     *   }
     * })
    **/
    count<T extends LabelTypeCountArgs>(
      args?: Subset<T, LabelTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabelType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelTypeAggregateArgs>(args: Subset<T, LabelTypeAggregateArgs>): PrismaPromise<GetLabelTypeAggregateType<T>>

    /**
     * Group by LabelType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelTypeGroupByArgs['orderBy'] }
        : { orderBy?: LabelTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelTypeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LabelType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LabelTypeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    labels<T extends LabelFindManyArgs = {}>(args?: Subset<T, LabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Label>| Null>, PrismaPromise<Array<LabelGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LabelType base type for findUnique actions
   */
  export type LabelTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
    /**
     * Filter, which LabelType to fetch.
     * 
    **/
    where: LabelTypeWhereUniqueInput
  }

  /**
   * LabelType: findUnique
   */
  export interface LabelTypeFindUniqueArgs extends LabelTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LabelType base type for findFirst actions
   */
  export type LabelTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
    /**
     * Filter, which LabelType to fetch.
     * 
    **/
    where?: LabelTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabelTypes.
     * 
    **/
    cursor?: LabelTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabelTypes.
     * 
    **/
    distinct?: Enumerable<LabelTypeScalarFieldEnum>
  }

  /**
   * LabelType: findFirst
   */
  export interface LabelTypeFindFirstArgs extends LabelTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LabelType findMany
   */
  export type LabelTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
    /**
     * Filter, which LabelTypes to fetch.
     * 
    **/
    where?: LabelTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabelTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabelTypes.
     * 
    **/
    cursor?: LabelTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabelTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabelTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LabelTypeScalarFieldEnum>
  }


  /**
   * LabelType create
   */
  export type LabelTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
    /**
     * The data needed to create a LabelType.
     * 
    **/
    data: XOR<LabelTypeCreateInput, LabelTypeUncheckedCreateInput>
  }


  /**
   * LabelType createMany
   */
  export type LabelTypeCreateManyArgs = {
    /**
     * The data used to create many LabelTypes.
     * 
    **/
    data: Enumerable<LabelTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LabelType update
   */
  export type LabelTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
    /**
     * The data needed to update a LabelType.
     * 
    **/
    data: XOR<LabelTypeUpdateInput, LabelTypeUncheckedUpdateInput>
    /**
     * Choose, which LabelType to update.
     * 
    **/
    where: LabelTypeWhereUniqueInput
  }


  /**
   * LabelType updateMany
   */
  export type LabelTypeUpdateManyArgs = {
    /**
     * The data used to update LabelTypes.
     * 
    **/
    data: XOR<LabelTypeUpdateManyMutationInput, LabelTypeUncheckedUpdateManyInput>
    /**
     * Filter which LabelTypes to update
     * 
    **/
    where?: LabelTypeWhereInput
  }


  /**
   * LabelType upsert
   */
  export type LabelTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
    /**
     * The filter to search for the LabelType to update in case it exists.
     * 
    **/
    where: LabelTypeWhereUniqueInput
    /**
     * In case the LabelType found by the `where` argument doesn't exist, create a new LabelType with this data.
     * 
    **/
    create: XOR<LabelTypeCreateInput, LabelTypeUncheckedCreateInput>
    /**
     * In case the LabelType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LabelTypeUpdateInput, LabelTypeUncheckedUpdateInput>
  }


  /**
   * LabelType delete
   */
  export type LabelTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
    /**
     * Filter which LabelType to delete.
     * 
    **/
    where: LabelTypeWhereUniqueInput
  }


  /**
   * LabelType deleteMany
   */
  export type LabelTypeDeleteManyArgs = {
    /**
     * Filter which LabelTypes to delete
     * 
    **/
    where?: LabelTypeWhereInput
  }


  /**
   * LabelType: findUniqueOrThrow
   */
  export type LabelTypeFindUniqueOrThrowArgs = LabelTypeFindUniqueArgsBase
      

  /**
   * LabelType: findFirstOrThrow
   */
  export type LabelTypeFindFirstOrThrowArgs = LabelTypeFindFirstArgsBase
      

  /**
   * LabelType without action
   */
  export type LabelTypeArgs = {
    /**
     * Select specific fields to fetch from the LabelType
     * 
    **/
    select?: LabelTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelTypeInclude | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CountryAggregateArgs = {
    /**
     * Filter which Country to aggregate.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: Array<CountryScalarFieldEnum>
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: string
    name: string
    slug: string
    value: string
    created_at: Date
    updated_at: Date
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    value?: boolean
    states?: boolean | StateFindManyArgs
    labels?: boolean | LabelFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryInclude = {
    states?: boolean | StateFindManyArgs
    labels?: boolean | LabelFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryGetPayload<
    S extends boolean | null | undefined | CountryArgs,
    U = keyof S
      > = S extends true
        ? Country
    : S extends undefined
    ? never
    : S extends CountryArgs | CountryFindManyArgs
    ?'include' extends U
    ? Country  & {
    [P in TrueKeys<S['include']>]:
        P extends 'states' ? Array < StateGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'states' ? Array < StateGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Country ? Country[P] : never
  } 
    : Country
  : Country


  type CountryCountArgs = Merge<
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }
  >

  export interface CountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null, null>, Prisma__CountryClient<CountryGetPayload<T> | null, null>>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null, null>, Prisma__CountryClient<CountryGetPayload<T> | null, null>>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs>(
      args?: SelectSubset<T, CountryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Country>>, PrismaPromise<Array<CountryGetPayload<T>>>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs>(
      args: SelectSubset<T, CountryCreateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs>(
      args?: SelectSubset<T, CountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs>(
      args: SelectSubset<T, CountryDeleteArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs>(
      args: SelectSubset<T, CountryUpdateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs>(
      args?: SelectSubset<T, CountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs>(
      args: SelectSubset<T, CountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs>(
      args: SelectSubset<T, CountryUpsertArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Find one Country that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Find the first Country that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    states<T extends StateFindManyArgs = {}>(args?: Subset<T, StateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<State>| Null>, PrismaPromise<Array<StateGetPayload<T>>| Null>>;

    labels<T extends LabelFindManyArgs = {}>(args?: Subset<T, LabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Label>| Null>, PrismaPromise<Array<LabelGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Country base type for findUnique actions
   */
  export type CountryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where: CountryWhereUniqueInput
  }

  /**
   * Country: findUnique
   */
  export interface CountryFindUniqueArgs extends CountryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country base type for findFirst actions
   */
  export type CountryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     * 
    **/
    distinct?: Enumerable<CountryScalarFieldEnum>
  }

  /**
   * Country: findFirst
   */
  export interface CountryFindFirstArgs extends CountryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findMany
   */
  export type CountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Countries to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to create a Country.
     * 
    **/
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs = {
    /**
     * The data used to create many Countries.
     * 
    **/
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to update a Country.
     * 
    **/
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs = {
    /**
     * The data used to update Countries.
     * 
    **/
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The filter to search for the Country to update in case it exists.
     * 
    **/
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     * 
    **/
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter which Country to delete.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs = {
    /**
     * Filter which Countries to delete
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country: findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs = CountryFindUniqueArgsBase
      

  /**
   * Country: findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs = CountryFindFirstArgsBase
      

  /**
   * Country without action
   */
  export type CountryArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
  }



  /**
   * Model State
   */


  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    country_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    country_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    country_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StateMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    country_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    country_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    country_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StateAggregateArgs = {
    /**
     * Filter which State to aggregate.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs = {
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithAggregationInput>
    by: Array<StateScalarFieldEnum>
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }


  export type StateGroupByOutputType = {
    id: string
    name: string
    slug: string
    country_id: string
    created_at: Date
    updated_at: Date
    _count: StateCountAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    country_id?: boolean
    country?: boolean | CountryArgs
    regions?: boolean | RegionFindManyArgs
    cities?: boolean | CityFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateInclude = {
    country?: boolean | CountryArgs
    regions?: boolean | RegionFindManyArgs
    cities?: boolean | CityFindManyArgs
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateGetPayload<
    S extends boolean | null | undefined | StateArgs,
    U = keyof S
      > = S extends true
        ? State
    : S extends undefined
    ? never
    : S extends StateArgs | StateFindManyArgs
    ?'include' extends U
    ? State  & {
    [P in TrueKeys<S['include']>]:
        P extends 'country' ? CountryGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'regions' ? Array < RegionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'cities' ? Array < CityGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'country' ? CountryGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'regions' ? Array < RegionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'cities' ? Array < CityGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof State ? State[P] : never
  } 
    : State
  : State


  type StateCountArgs = Merge<
    Omit<StateFindManyArgs, 'select' | 'include'> & {
      select?: StateCountAggregateInputType | true
    }
  >

  export interface StateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null, null>, Prisma__StateClient<StateGetPayload<T> | null, null>>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null, null>, Prisma__StateClient<StateGetPayload<T> | null, null>>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StateFindManyArgs>(
      args?: SelectSubset<T, StateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<State>>, PrismaPromise<Array<StateGetPayload<T>>>>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends StateCreateArgs>(
      args: SelectSubset<T, StateCreateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Create many States.
     *     @param {StateCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const state = await prisma.state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StateCreateManyArgs>(
      args?: SelectSubset<T, StateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends StateDeleteArgs>(
      args: SelectSubset<T, StateDeleteArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateUpdateArgs>(
      args: SelectSubset<T, StateUpdateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateDeleteManyArgs>(
      args?: SelectSubset<T, StateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateUpdateManyArgs>(
      args: SelectSubset<T, StateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends StateUpsertArgs>(
      args: SelectSubset<T, StateUpsertArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Find one State that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StateFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Find the first State that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StateFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StateClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | Null>, Prisma__CountryClient<CountryGetPayload<T> | Null>>;

    regions<T extends RegionFindManyArgs = {}>(args?: Subset<T, RegionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Region>| Null>, PrismaPromise<Array<RegionGetPayload<T>>| Null>>;

    cities<T extends CityFindManyArgs = {}>(args?: Subset<T, CityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<City>| Null>, PrismaPromise<Array<CityGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * State base type for findUnique actions
   */
  export type StateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     * 
    **/
    where: StateWhereUniqueInput
  }

  /**
   * State: findUnique
   */
  export interface StateFindUniqueArgs extends StateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State base type for findFirst actions
   */
  export type StateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     * 
    **/
    distinct?: Enumerable<StateScalarFieldEnum>
  }

  /**
   * State: findFirst
   */
  export interface StateFindFirstArgs extends StateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State findMany
   */
  export type StateFindManyArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which States to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State create
   */
  export type StateCreateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to create a State.
     * 
    **/
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }


  /**
   * State createMany
   */
  export type StateCreateManyArgs = {
    /**
     * The data used to create many States.
     * 
    **/
    data: Enumerable<StateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * State update
   */
  export type StateUpdateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to update a State.
     * 
    **/
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State updateMany
   */
  export type StateUpdateManyArgs = {
    /**
     * The data used to update States.
     * 
    **/
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State upsert
   */
  export type StateUpsertArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The filter to search for the State to update in case it exists.
     * 
    **/
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     * 
    **/
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }


  /**
   * State delete
   */
  export type StateDeleteArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter which State to delete.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs = {
    /**
     * Filter which States to delete
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State: findUniqueOrThrow
   */
  export type StateFindUniqueOrThrowArgs = StateFindUniqueArgsBase
      

  /**
   * State: findFirstOrThrow
   */
  export type StateFindFirstOrThrowArgs = StateFindFirstArgsBase
      

  /**
   * State without action
   */
  export type StateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    state_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    state_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    state_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    state_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    state_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    state_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithAggregationInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: string
    name: string
    slug: string
    state_id: string
    created_at: Date
    updated_at: Date
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    state_id?: boolean
    state?: boolean | StateArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type CityInclude = {
    state?: boolean | StateArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof City ? City[P] : never
  } 
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null, null>, Prisma__CityClient<CityGetPayload<T> | null, null>>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null, null>, Prisma__CityClient<CityGetPayload<T> | null, null>>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Find one City that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Find the first City that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | Null>, Prisma__StateClient<StateGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * City base type for findUnique actions
   */
  export type CityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where: CityWhereUniqueInput
  }

  /**
   * City: findUnique
   */
  export interface CityFindUniqueArgs extends CityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City base type for findFirst actions
   */
  export type CityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     * 
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }

  /**
   * City: findFirst
   */
  export interface CityFindFirstArgs extends CityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     * 
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    /**
     * The data used to create many Cities.
     * 
    **/
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     * 
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    /**
     * The data used to update Cities.
     * 
    **/
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     * 
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     * 
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    /**
     * Filter which Cities to delete
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City: findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs = CityFindUniqueArgsBase
      

  /**
   * City: findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs = CityFindFirstArgsBase
      

  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
  }



  /**
   * Model Region
   */


  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionMinAggregateOutputType = {
    id: string | null
    state_id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RegionMaxAggregateOutputType = {
    id: string | null
    state_id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    state_id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RegionMinAggregateInputType = {
    id?: true
    state_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    state_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    state_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RegionAggregateArgs = {
    /**
     * Filter which Region to aggregate.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs = {
    where?: RegionWhereInput
    orderBy?: Enumerable<RegionOrderByWithAggregationInput>
    by: Array<RegionScalarFieldEnum>
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }


  export type RegionGroupByOutputType = {
    id: string
    state_id: string
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect = {
    id?: boolean
    state_id?: boolean
    state?: boolean | StateArgs
    name?: boolean
    slug?: boolean
    subregion?: boolean | SubRegionFindManyArgs
    labels?: boolean | LabelFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | RegionCountOutputTypeArgs
  }

  export type RegionInclude = {
    state?: boolean | StateArgs
    subregion?: boolean | SubRegionFindManyArgs
    labels?: boolean | LabelFindManyArgs
    _count?: boolean | RegionCountOutputTypeArgs
  }

  export type RegionGetPayload<
    S extends boolean | null | undefined | RegionArgs,
    U = keyof S
      > = S extends true
        ? Region
    : S extends undefined
    ? never
    : S extends RegionArgs | RegionFindManyArgs
    ?'include' extends U
    ? Region  & {
    [P in TrueKeys<S['include']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'subregion' ? Array < SubRegionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RegionCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'subregion' ? Array < SubRegionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RegionCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Region ? Region[P] : never
  } 
    : Region
  : Region


  type RegionCountArgs = Merge<
    Omit<RegionFindManyArgs, 'select' | 'include'> & {
      select?: RegionCountAggregateInputType | true
    }
  >

  export interface RegionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null, null>, Prisma__RegionClient<RegionGetPayload<T> | null, null>>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null, null>, Prisma__RegionClient<RegionGetPayload<T> | null, null>>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs>(
      args?: SelectSubset<T, RegionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Region>>, PrismaPromise<Array<RegionGetPayload<T>>>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs>(
      args: SelectSubset<T, RegionCreateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs>(
      args?: SelectSubset<T, RegionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs>(
      args: SelectSubset<T, RegionDeleteArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs>(
      args: SelectSubset<T, RegionUpdateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs>(
      args?: SelectSubset<T, RegionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs>(
      args: SelectSubset<T, RegionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs>(
      args: SelectSubset<T, RegionUpsertArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Find one Region that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RegionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Find the first Region that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RegionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | Null>, Prisma__StateClient<StateGetPayload<T> | Null>>;

    subregion<T extends SubRegionFindManyArgs = {}>(args?: Subset<T, SubRegionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SubRegion>| Null>, PrismaPromise<Array<SubRegionGetPayload<T>>| Null>>;

    labels<T extends LabelFindManyArgs = {}>(args?: Subset<T, LabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Label>| Null>, PrismaPromise<Array<LabelGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Region base type for findUnique actions
   */
  export type RegionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Region to fetch.
     * 
    **/
    where: RegionWhereUniqueInput
  }

  /**
   * Region: findUnique
   */
  export interface RegionFindUniqueArgs extends RegionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Region base type for findFirst actions
   */
  export type RegionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Region to fetch.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     * 
    **/
    distinct?: Enumerable<RegionScalarFieldEnum>
  }

  /**
   * Region: findFirst
   */
  export interface RegionFindFirstArgs extends RegionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Region findMany
   */
  export type RegionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Regions to fetch.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RegionScalarFieldEnum>
  }


  /**
   * Region create
   */
  export type RegionCreateArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The data needed to create a Region.
     * 
    **/
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }


  /**
   * Region createMany
   */
  export type RegionCreateManyArgs = {
    /**
     * The data used to create many Regions.
     * 
    **/
    data: Enumerable<RegionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Region update
   */
  export type RegionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The data needed to update a Region.
     * 
    **/
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     * 
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs = {
    /**
     * The data used to update Regions.
     * 
    **/
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     * 
    **/
    where?: RegionWhereInput
  }


  /**
   * Region upsert
   */
  export type RegionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The filter to search for the Region to update in case it exists.
     * 
    **/
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     * 
    **/
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }


  /**
   * Region delete
   */
  export type RegionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter which Region to delete.
     * 
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs = {
    /**
     * Filter which Regions to delete
     * 
    **/
    where?: RegionWhereInput
  }


  /**
   * Region: findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs = RegionFindUniqueArgsBase
      

  /**
   * Region: findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs = RegionFindFirstArgsBase
      

  /**
   * Region without action
   */
  export type RegionArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
  }



  /**
   * Model SubRegion
   */


  export type AggregateSubRegion = {
    _count: SubRegionCountAggregateOutputType | null
    _min: SubRegionMinAggregateOutputType | null
    _max: SubRegionMaxAggregateOutputType | null
  }

  export type SubRegionMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    region_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubRegionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    region_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubRegionCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    region_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubRegionMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    region_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SubRegionMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    region_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SubRegionCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    region_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubRegionAggregateArgs = {
    /**
     * Filter which SubRegion to aggregate.
     * 
    **/
    where?: SubRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubRegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubRegions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubRegions
    **/
    _count?: true | SubRegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubRegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubRegionMaxAggregateInputType
  }

  export type GetSubRegionAggregateType<T extends SubRegionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubRegion[P]>
      : GetScalarType<T[P], AggregateSubRegion[P]>
  }




  export type SubRegionGroupByArgs = {
    where?: SubRegionWhereInput
    orderBy?: Enumerable<SubRegionOrderByWithAggregationInput>
    by: Array<SubRegionScalarFieldEnum>
    having?: SubRegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubRegionCountAggregateInputType | true
    _min?: SubRegionMinAggregateInputType
    _max?: SubRegionMaxAggregateInputType
  }


  export type SubRegionGroupByOutputType = {
    id: string
    name: string
    slug: string
    region_id: string
    created_at: Date
    updated_at: Date
    _count: SubRegionCountAggregateOutputType | null
    _min: SubRegionMinAggregateOutputType | null
    _max: SubRegionMaxAggregateOutputType | null
  }

  type GetSubRegionGroupByPayload<T extends SubRegionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubRegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubRegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubRegionGroupByOutputType[P]>
            : GetScalarType<T[P], SubRegionGroupByOutputType[P]>
        }
      >
    >


  export type SubRegionSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    region_id?: boolean
    region?: boolean | RegionArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubRegionInclude = {
    region?: boolean | RegionArgs
  }

  export type SubRegionGetPayload<
    S extends boolean | null | undefined | SubRegionArgs,
    U = keyof S
      > = S extends true
        ? SubRegion
    : S extends undefined
    ? never
    : S extends SubRegionArgs | SubRegionFindManyArgs
    ?'include' extends U
    ? SubRegion  & {
    [P in TrueKeys<S['include']>]:
        P extends 'region' ? RegionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'region' ? RegionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SubRegion ? SubRegion[P] : never
  } 
    : SubRegion
  : SubRegion


  type SubRegionCountArgs = Merge<
    Omit<SubRegionFindManyArgs, 'select' | 'include'> & {
      select?: SubRegionCountAggregateInputType | true
    }
  >

  export interface SubRegionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SubRegion that matches the filter.
     * @param {SubRegionFindUniqueArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubRegionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubRegionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubRegion'> extends True ? CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>> : CheckSelect<T, Prisma__SubRegionClient<SubRegion | null, null>, Prisma__SubRegionClient<SubRegionGetPayload<T> | null, null>>

    /**
     * Find the first SubRegion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionFindFirstArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubRegionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubRegionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubRegion'> extends True ? CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>> : CheckSelect<T, Prisma__SubRegionClient<SubRegion | null, null>, Prisma__SubRegionClient<SubRegionGetPayload<T> | null, null>>

    /**
     * Find zero or more SubRegions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubRegions
     * const subRegions = await prisma.subRegion.findMany()
     * 
     * // Get first 10 SubRegions
     * const subRegions = await prisma.subRegion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subRegionWithIdOnly = await prisma.subRegion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubRegionFindManyArgs>(
      args?: SelectSubset<T, SubRegionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubRegion>>, PrismaPromise<Array<SubRegionGetPayload<T>>>>

    /**
     * Create a SubRegion.
     * @param {SubRegionCreateArgs} args - Arguments to create a SubRegion.
     * @example
     * // Create one SubRegion
     * const SubRegion = await prisma.subRegion.create({
     *   data: {
     *     // ... data to create a SubRegion
     *   }
     * })
     * 
    **/
    create<T extends SubRegionCreateArgs>(
      args: SelectSubset<T, SubRegionCreateArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Create many SubRegions.
     *     @param {SubRegionCreateManyArgs} args - Arguments to create many SubRegions.
     *     @example
     *     // Create many SubRegions
     *     const subRegion = await prisma.subRegion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubRegionCreateManyArgs>(
      args?: SelectSubset<T, SubRegionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubRegion.
     * @param {SubRegionDeleteArgs} args - Arguments to delete one SubRegion.
     * @example
     * // Delete one SubRegion
     * const SubRegion = await prisma.subRegion.delete({
     *   where: {
     *     // ... filter to delete one SubRegion
     *   }
     * })
     * 
    **/
    delete<T extends SubRegionDeleteArgs>(
      args: SelectSubset<T, SubRegionDeleteArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Update one SubRegion.
     * @param {SubRegionUpdateArgs} args - Arguments to update one SubRegion.
     * @example
     * // Update one SubRegion
     * const subRegion = await prisma.subRegion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubRegionUpdateArgs>(
      args: SelectSubset<T, SubRegionUpdateArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Delete zero or more SubRegions.
     * @param {SubRegionDeleteManyArgs} args - Arguments to filter SubRegions to delete.
     * @example
     * // Delete a few SubRegions
     * const { count } = await prisma.subRegion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubRegionDeleteManyArgs>(
      args?: SelectSubset<T, SubRegionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubRegions
     * const subRegion = await prisma.subRegion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubRegionUpdateManyArgs>(
      args: SelectSubset<T, SubRegionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubRegion.
     * @param {SubRegionUpsertArgs} args - Arguments to update or create a SubRegion.
     * @example
     * // Update or create a SubRegion
     * const subRegion = await prisma.subRegion.upsert({
     *   create: {
     *     // ... data to create a SubRegion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubRegion we want to update
     *   }
     * })
    **/
    upsert<T extends SubRegionUpsertArgs>(
      args: SelectSubset<T, SubRegionUpsertArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Find one SubRegion that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SubRegionFindUniqueOrThrowArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubRegionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubRegionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Find the first SubRegion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionFindFirstOrThrowArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubRegionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubRegionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Count the number of SubRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionCountArgs} args - Arguments to filter SubRegions to count.
     * @example
     * // Count the number of SubRegions
     * const count = await prisma.subRegion.count({
     *   where: {
     *     // ... the filter for the SubRegions we want to count
     *   }
     * })
    **/
    count<T extends SubRegionCountArgs>(
      args?: Subset<T, SubRegionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubRegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubRegion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubRegionAggregateArgs>(args: Subset<T, SubRegionAggregateArgs>): PrismaPromise<GetSubRegionAggregateType<T>>

    /**
     * Group by SubRegion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubRegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubRegionGroupByArgs['orderBy'] }
        : { orderBy?: SubRegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubRegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubRegionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubRegion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubRegionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    region<T extends RegionArgs = {}>(args?: Subset<T, RegionArgs>): CheckSelect<T, Prisma__RegionClient<Region | Null>, Prisma__RegionClient<RegionGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubRegion base type for findUnique actions
   */
  export type SubRegionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter, which SubRegion to fetch.
     * 
    **/
    where: SubRegionWhereUniqueInput
  }

  /**
   * SubRegion: findUnique
   */
  export interface SubRegionFindUniqueArgs extends SubRegionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubRegion base type for findFirst actions
   */
  export type SubRegionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter, which SubRegion to fetch.
     * 
    **/
    where?: SubRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubRegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubRegions.
     * 
    **/
    cursor?: SubRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubRegions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubRegions.
     * 
    **/
    distinct?: Enumerable<SubRegionScalarFieldEnum>
  }

  /**
   * SubRegion: findFirst
   */
  export interface SubRegionFindFirstArgs extends SubRegionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubRegion findMany
   */
  export type SubRegionFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter, which SubRegions to fetch.
     * 
    **/
    where?: SubRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubRegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubRegions.
     * 
    **/
    cursor?: SubRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubRegions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubRegionScalarFieldEnum>
  }


  /**
   * SubRegion create
   */
  export type SubRegionCreateArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * The data needed to create a SubRegion.
     * 
    **/
    data: XOR<SubRegionCreateInput, SubRegionUncheckedCreateInput>
  }


  /**
   * SubRegion createMany
   */
  export type SubRegionCreateManyArgs = {
    /**
     * The data used to create many SubRegions.
     * 
    **/
    data: Enumerable<SubRegionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubRegion update
   */
  export type SubRegionUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * The data needed to update a SubRegion.
     * 
    **/
    data: XOR<SubRegionUpdateInput, SubRegionUncheckedUpdateInput>
    /**
     * Choose, which SubRegion to update.
     * 
    **/
    where: SubRegionWhereUniqueInput
  }


  /**
   * SubRegion updateMany
   */
  export type SubRegionUpdateManyArgs = {
    /**
     * The data used to update SubRegions.
     * 
    **/
    data: XOR<SubRegionUpdateManyMutationInput, SubRegionUncheckedUpdateManyInput>
    /**
     * Filter which SubRegions to update
     * 
    **/
    where?: SubRegionWhereInput
  }


  /**
   * SubRegion upsert
   */
  export type SubRegionUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * The filter to search for the SubRegion to update in case it exists.
     * 
    **/
    where: SubRegionWhereUniqueInput
    /**
     * In case the SubRegion found by the `where` argument doesn't exist, create a new SubRegion with this data.
     * 
    **/
    create: XOR<SubRegionCreateInput, SubRegionUncheckedCreateInput>
    /**
     * In case the SubRegion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubRegionUpdateInput, SubRegionUncheckedUpdateInput>
  }


  /**
   * SubRegion delete
   */
  export type SubRegionDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter which SubRegion to delete.
     * 
    **/
    where: SubRegionWhereUniqueInput
  }


  /**
   * SubRegion deleteMany
   */
  export type SubRegionDeleteManyArgs = {
    /**
     * Filter which SubRegions to delete
     * 
    **/
    where?: SubRegionWhereInput
  }


  /**
   * SubRegion: findUniqueOrThrow
   */
  export type SubRegionFindUniqueOrThrowArgs = SubRegionFindUniqueArgsBase
      

  /**
   * SubRegion: findFirstOrThrow
   */
  export type SubRegionFindFirstOrThrowArgs = SubRegionFindFirstArgsBase
      

  /**
   * SubRegion without action
   */
  export type SubRegionArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
  }



  /**
   * Model WineType
   */


  export type AggregateWineType = {
    _count: WineTypeCountAggregateOutputType | null
    _min: WineTypeMinAggregateOutputType | null
    _max: WineTypeMaxAggregateOutputType | null
  }

  export type WineTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WineTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WineTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WineTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type WineTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type WineTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WineTypeAggregateArgs = {
    /**
     * Filter which WineType to aggregate.
     * 
    **/
    where?: WineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<WineTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WineTypes
    **/
    _count?: true | WineTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WineTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WineTypeMaxAggregateInputType
  }

  export type GetWineTypeAggregateType<T extends WineTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateWineType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWineType[P]>
      : GetScalarType<T[P], AggregateWineType[P]>
  }




  export type WineTypeGroupByArgs = {
    where?: WineTypeWhereInput
    orderBy?: Enumerable<WineTypeOrderByWithAggregationInput>
    by: Array<WineTypeScalarFieldEnum>
    having?: WineTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WineTypeCountAggregateInputType | true
    _min?: WineTypeMinAggregateInputType
    _max?: WineTypeMaxAggregateInputType
  }


  export type WineTypeGroupByOutputType = {
    id: string
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: WineTypeCountAggregateOutputType | null
    _min: WineTypeMinAggregateOutputType | null
    _max: WineTypeMaxAggregateOutputType | null
  }

  type GetWineTypeGroupByPayload<T extends WineTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WineTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WineTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WineTypeGroupByOutputType[P]>
            : GetScalarType<T[P], WineTypeGroupByOutputType[P]>
        }
      >
    >


  export type WineTypeSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    labels?: boolean | LabelFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | WineTypeCountOutputTypeArgs
  }

  export type WineTypeInclude = {
    labels?: boolean | LabelFindManyArgs
    _count?: boolean | WineTypeCountOutputTypeArgs
  }

  export type WineTypeGetPayload<
    S extends boolean | null | undefined | WineTypeArgs,
    U = keyof S
      > = S extends true
        ? WineType
    : S extends undefined
    ? never
    : S extends WineTypeArgs | WineTypeFindManyArgs
    ?'include' extends U
    ? WineType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? WineTypeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'labels' ? Array < LabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? WineTypeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof WineType ? WineType[P] : never
  } 
    : WineType
  : WineType


  type WineTypeCountArgs = Merge<
    Omit<WineTypeFindManyArgs, 'select' | 'include'> & {
      select?: WineTypeCountAggregateInputType | true
    }
  >

  export interface WineTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one WineType that matches the filter.
     * @param {WineTypeFindUniqueArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WineTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WineTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WineType'> extends True ? CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>> : CheckSelect<T, Prisma__WineTypeClient<WineType | null, null>, Prisma__WineTypeClient<WineTypeGetPayload<T> | null, null>>

    /**
     * Find the first WineType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeFindFirstArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WineTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WineTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WineType'> extends True ? CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>> : CheckSelect<T, Prisma__WineTypeClient<WineType | null, null>, Prisma__WineTypeClient<WineTypeGetPayload<T> | null, null>>

    /**
     * Find zero or more WineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WineTypes
     * const wineTypes = await prisma.wineType.findMany()
     * 
     * // Get first 10 WineTypes
     * const wineTypes = await prisma.wineType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wineTypeWithIdOnly = await prisma.wineType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WineTypeFindManyArgs>(
      args?: SelectSubset<T, WineTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WineType>>, PrismaPromise<Array<WineTypeGetPayload<T>>>>

    /**
     * Create a WineType.
     * @param {WineTypeCreateArgs} args - Arguments to create a WineType.
     * @example
     * // Create one WineType
     * const WineType = await prisma.wineType.create({
     *   data: {
     *     // ... data to create a WineType
     *   }
     * })
     * 
    **/
    create<T extends WineTypeCreateArgs>(
      args: SelectSubset<T, WineTypeCreateArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Create many WineTypes.
     *     @param {WineTypeCreateManyArgs} args - Arguments to create many WineTypes.
     *     @example
     *     // Create many WineTypes
     *     const wineType = await prisma.wineType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WineTypeCreateManyArgs>(
      args?: SelectSubset<T, WineTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WineType.
     * @param {WineTypeDeleteArgs} args - Arguments to delete one WineType.
     * @example
     * // Delete one WineType
     * const WineType = await prisma.wineType.delete({
     *   where: {
     *     // ... filter to delete one WineType
     *   }
     * })
     * 
    **/
    delete<T extends WineTypeDeleteArgs>(
      args: SelectSubset<T, WineTypeDeleteArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Update one WineType.
     * @param {WineTypeUpdateArgs} args - Arguments to update one WineType.
     * @example
     * // Update one WineType
     * const wineType = await prisma.wineType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WineTypeUpdateArgs>(
      args: SelectSubset<T, WineTypeUpdateArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Delete zero or more WineTypes.
     * @param {WineTypeDeleteManyArgs} args - Arguments to filter WineTypes to delete.
     * @example
     * // Delete a few WineTypes
     * const { count } = await prisma.wineType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WineTypeDeleteManyArgs>(
      args?: SelectSubset<T, WineTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WineTypes
     * const wineType = await prisma.wineType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WineTypeUpdateManyArgs>(
      args: SelectSubset<T, WineTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WineType.
     * @param {WineTypeUpsertArgs} args - Arguments to update or create a WineType.
     * @example
     * // Update or create a WineType
     * const wineType = await prisma.wineType.upsert({
     *   create: {
     *     // ... data to create a WineType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WineType we want to update
     *   }
     * })
    **/
    upsert<T extends WineTypeUpsertArgs>(
      args: SelectSubset<T, WineTypeUpsertArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Find one WineType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {WineTypeFindUniqueOrThrowArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WineTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WineTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Find the first WineType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeFindFirstOrThrowArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WineTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WineTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Count the number of WineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeCountArgs} args - Arguments to filter WineTypes to count.
     * @example
     * // Count the number of WineTypes
     * const count = await prisma.wineType.count({
     *   where: {
     *     // ... the filter for the WineTypes we want to count
     *   }
     * })
    **/
    count<T extends WineTypeCountArgs>(
      args?: Subset<T, WineTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WineTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WineTypeAggregateArgs>(args: Subset<T, WineTypeAggregateArgs>): PrismaPromise<GetWineTypeAggregateType<T>>

    /**
     * Group by WineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WineTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WineTypeGroupByArgs['orderBy'] }
        : { orderBy?: WineTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WineTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWineTypeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WineType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WineTypeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    labels<T extends LabelFindManyArgs = {}>(args?: Subset<T, LabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Label>| Null>, PrismaPromise<Array<LabelGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WineType base type for findUnique actions
   */
  export type WineTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter, which WineType to fetch.
     * 
    **/
    where: WineTypeWhereUniqueInput
  }

  /**
   * WineType: findUnique
   */
  export interface WineTypeFindUniqueArgs extends WineTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WineType base type for findFirst actions
   */
  export type WineTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter, which WineType to fetch.
     * 
    **/
    where?: WineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<WineTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WineTypes.
     * 
    **/
    cursor?: WineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WineTypes.
     * 
    **/
    distinct?: Enumerable<WineTypeScalarFieldEnum>
  }

  /**
   * WineType: findFirst
   */
  export interface WineTypeFindFirstArgs extends WineTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WineType findMany
   */
  export type WineTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter, which WineTypes to fetch.
     * 
    **/
    where?: WineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<WineTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WineTypes.
     * 
    **/
    cursor?: WineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WineTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WineTypeScalarFieldEnum>
  }


  /**
   * WineType create
   */
  export type WineTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * The data needed to create a WineType.
     * 
    **/
    data: XOR<WineTypeCreateInput, WineTypeUncheckedCreateInput>
  }


  /**
   * WineType createMany
   */
  export type WineTypeCreateManyArgs = {
    /**
     * The data used to create many WineTypes.
     * 
    **/
    data: Enumerable<WineTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WineType update
   */
  export type WineTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * The data needed to update a WineType.
     * 
    **/
    data: XOR<WineTypeUpdateInput, WineTypeUncheckedUpdateInput>
    /**
     * Choose, which WineType to update.
     * 
    **/
    where: WineTypeWhereUniqueInput
  }


  /**
   * WineType updateMany
   */
  export type WineTypeUpdateManyArgs = {
    /**
     * The data used to update WineTypes.
     * 
    **/
    data: XOR<WineTypeUpdateManyMutationInput, WineTypeUncheckedUpdateManyInput>
    /**
     * Filter which WineTypes to update
     * 
    **/
    where?: WineTypeWhereInput
  }


  /**
   * WineType upsert
   */
  export type WineTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * The filter to search for the WineType to update in case it exists.
     * 
    **/
    where: WineTypeWhereUniqueInput
    /**
     * In case the WineType found by the `where` argument doesn't exist, create a new WineType with this data.
     * 
    **/
    create: XOR<WineTypeCreateInput, WineTypeUncheckedCreateInput>
    /**
     * In case the WineType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WineTypeUpdateInput, WineTypeUncheckedUpdateInput>
  }


  /**
   * WineType delete
   */
  export type WineTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter which WineType to delete.
     * 
    **/
    where: WineTypeWhereUniqueInput
  }


  /**
   * WineType deleteMany
   */
  export type WineTypeDeleteManyArgs = {
    /**
     * Filter which WineTypes to delete
     * 
    **/
    where?: WineTypeWhereInput
  }


  /**
   * WineType: findUniqueOrThrow
   */
  export type WineTypeFindUniqueOrThrowArgs = WineTypeFindUniqueArgsBase
      

  /**
   * WineType: findFirstOrThrow
   */
  export type WineTypeFindFirstOrThrowArgs = WineTypeFindFirstArgsBase
      

  /**
   * WineType without action
   */
  export type WineTypeArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    total: number | null
    coupon_id: number | null
  }

  export type OrderSumAggregateOutputType = {
    total: number | null
    coupon_id: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    code: string | null
    account_id: string | null
    total: number | null
    coupon_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    code: string | null
    account_id: string | null
    total: number | null
    coupon_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    code: number
    account_id: number
    total: number
    coupon_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    total?: true
    coupon_id?: true
  }

  export type OrderSumAggregateInputType = {
    total?: true
    coupon_id?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    code?: true
    account_id?: true
    total?: true
    coupon_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    code?: true
    account_id?: true
    total?: true
    coupon_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    code?: true
    account_id?: true
    total?: true
    coupon_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    code: string
    account_id: string
    total: number
    coupon_id: number | null
    created_at: Date
    updated_at: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    code?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    total?: boolean
    coupon_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    order_label?: boolean | OrderLabelFindManyArgs
    invoice?: boolean | InvoiceFindManyArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderInclude = {
    account?: boolean | AccountArgs
    order_label?: boolean | OrderLabelFindManyArgs
    invoice?: boolean | InvoiceFindManyArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<
    S extends boolean | null | undefined | OrderArgs,
    U = keyof S
      > = S extends true
        ? Order
    : S extends undefined
    ? never
    : S extends OrderArgs | OrderFindManyArgs
    ?'include' extends U
    ? Order  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'order_label' ? Array < OrderLabelGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'invoice' ? Array < InvoiceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'order_label' ? Array < OrderLabelGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'invoice' ? Array < InvoiceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Order ? Order[P] : never
  } 
    : Order
  : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null, null>, Prisma__OrderClient<OrderGetPayload<T> | null, null>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null, null>, Prisma__OrderClient<OrderGetPayload<T> | null, null>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Find one Order that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    order_label<T extends OrderLabelFindManyArgs = {}>(args?: Subset<T, OrderLabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderLabel>| Null>, PrismaPromise<Array<OrderLabelGetPayload<T>>| Null>>;

    invoice<T extends InvoiceFindManyArgs = {}>(args?: Subset<T, InvoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Invoice>| Null>, PrismaPromise<Array<InvoiceGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }

  /**
   * Order: findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order: findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order: findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = OrderFindUniqueArgsBase
      

  /**
   * Order: findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = OrderFindFirstArgsBase
      

  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model OrderLabel
   */


  export type AggregateOrderLabel = {
    _count: OrderLabelCountAggregateOutputType | null
    _avg: OrderLabelAvgAggregateOutputType | null
    _sum: OrderLabelSumAggregateOutputType | null
    _min: OrderLabelMinAggregateOutputType | null
    _max: OrderLabelMaxAggregateOutputType | null
  }

  export type OrderLabelAvgAggregateOutputType = {
    quantity: number | null
  }

  export type OrderLabelSumAggregateOutputType = {
    quantity: number | null
  }

  export type OrderLabelMinAggregateOutputType = {
    order_id: string | null
    label_id: string | null
    created_at: Date | null
    updated_at: Date | null
    quantity: number | null
  }

  export type OrderLabelMaxAggregateOutputType = {
    order_id: string | null
    label_id: string | null
    created_at: Date | null
    updated_at: Date | null
    quantity: number | null
  }

  export type OrderLabelCountAggregateOutputType = {
    order_id: number
    label_id: number
    created_at: number
    updated_at: number
    quantity: number
    _all: number
  }


  export type OrderLabelAvgAggregateInputType = {
    quantity?: true
  }

  export type OrderLabelSumAggregateInputType = {
    quantity?: true
  }

  export type OrderLabelMinAggregateInputType = {
    order_id?: true
    label_id?: true
    created_at?: true
    updated_at?: true
    quantity?: true
  }

  export type OrderLabelMaxAggregateInputType = {
    order_id?: true
    label_id?: true
    created_at?: true
    updated_at?: true
    quantity?: true
  }

  export type OrderLabelCountAggregateInputType = {
    order_id?: true
    label_id?: true
    created_at?: true
    updated_at?: true
    quantity?: true
    _all?: true
  }

  export type OrderLabelAggregateArgs = {
    /**
     * Filter which OrderLabel to aggregate.
     * 
    **/
    where?: OrderLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderLabels to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderLabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderLabels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderLabels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderLabels
    **/
    _count?: true | OrderLabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderLabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderLabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderLabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderLabelMaxAggregateInputType
  }

  export type GetOrderLabelAggregateType<T extends OrderLabelAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderLabel[P]>
      : GetScalarType<T[P], AggregateOrderLabel[P]>
  }




  export type OrderLabelGroupByArgs = {
    where?: OrderLabelWhereInput
    orderBy?: Enumerable<OrderLabelOrderByWithAggregationInput>
    by: Array<OrderLabelScalarFieldEnum>
    having?: OrderLabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderLabelCountAggregateInputType | true
    _avg?: OrderLabelAvgAggregateInputType
    _sum?: OrderLabelSumAggregateInputType
    _min?: OrderLabelMinAggregateInputType
    _max?: OrderLabelMaxAggregateInputType
  }


  export type OrderLabelGroupByOutputType = {
    order_id: string
    label_id: string
    created_at: Date
    updated_at: Date
    quantity: number
    _count: OrderLabelCountAggregateOutputType | null
    _avg: OrderLabelAvgAggregateOutputType | null
    _sum: OrderLabelSumAggregateOutputType | null
    _min: OrderLabelMinAggregateOutputType | null
    _max: OrderLabelMaxAggregateOutputType | null
  }

  type GetOrderLabelGroupByPayload<T extends OrderLabelGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderLabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderLabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderLabelGroupByOutputType[P]>
            : GetScalarType<T[P], OrderLabelGroupByOutputType[P]>
        }
      >
    >


  export type OrderLabelSelect = {
    order_id?: boolean
    order?: boolean | OrderArgs
    label_id?: boolean
    label?: boolean | LabelArgs
    created_at?: boolean
    updated_at?: boolean
    quantity?: boolean
  }

  export type OrderLabelInclude = {
    order?: boolean | OrderArgs
    label?: boolean | LabelArgs
  }

  export type OrderLabelGetPayload<
    S extends boolean | null | undefined | OrderLabelArgs,
    U = keyof S
      > = S extends true
        ? OrderLabel
    : S extends undefined
    ? never
    : S extends OrderLabelArgs | OrderLabelFindManyArgs
    ?'include' extends U
    ? OrderLabel  & {
    [P in TrueKeys<S['include']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'label' ? LabelGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'label' ? LabelGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OrderLabel ? OrderLabel[P] : never
  } 
    : OrderLabel
  : OrderLabel


  type OrderLabelCountArgs = Merge<
    Omit<OrderLabelFindManyArgs, 'select' | 'include'> & {
      select?: OrderLabelCountAggregateInputType | true
    }
  >

  export interface OrderLabelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OrderLabel that matches the filter.
     * @param {OrderLabelFindUniqueArgs} args - Arguments to find a OrderLabel
     * @example
     * // Get one OrderLabel
     * const orderLabel = await prisma.orderLabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderLabelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderLabelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderLabel'> extends True ? CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>> : CheckSelect<T, Prisma__OrderLabelClient<OrderLabel | null, null>, Prisma__OrderLabelClient<OrderLabelGetPayload<T> | null, null>>

    /**
     * Find the first OrderLabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLabelFindFirstArgs} args - Arguments to find a OrderLabel
     * @example
     * // Get one OrderLabel
     * const orderLabel = await prisma.orderLabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderLabelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderLabelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderLabel'> extends True ? CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>> : CheckSelect<T, Prisma__OrderLabelClient<OrderLabel | null, null>, Prisma__OrderLabelClient<OrderLabelGetPayload<T> | null, null>>

    /**
     * Find zero or more OrderLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLabelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderLabels
     * const orderLabels = await prisma.orderLabel.findMany()
     * 
     * // Get first 10 OrderLabels
     * const orderLabels = await prisma.orderLabel.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const orderLabelWithOrder_idOnly = await prisma.orderLabel.findMany({ select: { order_id: true } })
     * 
    **/
    findMany<T extends OrderLabelFindManyArgs>(
      args?: SelectSubset<T, OrderLabelFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderLabel>>, PrismaPromise<Array<OrderLabelGetPayload<T>>>>

    /**
     * Create a OrderLabel.
     * @param {OrderLabelCreateArgs} args - Arguments to create a OrderLabel.
     * @example
     * // Create one OrderLabel
     * const OrderLabel = await prisma.orderLabel.create({
     *   data: {
     *     // ... data to create a OrderLabel
     *   }
     * })
     * 
    **/
    create<T extends OrderLabelCreateArgs>(
      args: SelectSubset<T, OrderLabelCreateArgs>
    ): CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>>

    /**
     * Create many OrderLabels.
     *     @param {OrderLabelCreateManyArgs} args - Arguments to create many OrderLabels.
     *     @example
     *     // Create many OrderLabels
     *     const orderLabel = await prisma.orderLabel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderLabelCreateManyArgs>(
      args?: SelectSubset<T, OrderLabelCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderLabel.
     * @param {OrderLabelDeleteArgs} args - Arguments to delete one OrderLabel.
     * @example
     * // Delete one OrderLabel
     * const OrderLabel = await prisma.orderLabel.delete({
     *   where: {
     *     // ... filter to delete one OrderLabel
     *   }
     * })
     * 
    **/
    delete<T extends OrderLabelDeleteArgs>(
      args: SelectSubset<T, OrderLabelDeleteArgs>
    ): CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>>

    /**
     * Update one OrderLabel.
     * @param {OrderLabelUpdateArgs} args - Arguments to update one OrderLabel.
     * @example
     * // Update one OrderLabel
     * const orderLabel = await prisma.orderLabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderLabelUpdateArgs>(
      args: SelectSubset<T, OrderLabelUpdateArgs>
    ): CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>>

    /**
     * Delete zero or more OrderLabels.
     * @param {OrderLabelDeleteManyArgs} args - Arguments to filter OrderLabels to delete.
     * @example
     * // Delete a few OrderLabels
     * const { count } = await prisma.orderLabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderLabelDeleteManyArgs>(
      args?: SelectSubset<T, OrderLabelDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderLabels
     * const orderLabel = await prisma.orderLabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderLabelUpdateManyArgs>(
      args: SelectSubset<T, OrderLabelUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderLabel.
     * @param {OrderLabelUpsertArgs} args - Arguments to update or create a OrderLabel.
     * @example
     * // Update or create a OrderLabel
     * const orderLabel = await prisma.orderLabel.upsert({
     *   create: {
     *     // ... data to create a OrderLabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderLabel we want to update
     *   }
     * })
    **/
    upsert<T extends OrderLabelUpsertArgs>(
      args: SelectSubset<T, OrderLabelUpsertArgs>
    ): CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>>

    /**
     * Find one OrderLabel that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrderLabelFindUniqueOrThrowArgs} args - Arguments to find a OrderLabel
     * @example
     * // Get one OrderLabel
     * const orderLabel = await prisma.orderLabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderLabelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderLabelFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>>

    /**
     * Find the first OrderLabel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLabelFindFirstOrThrowArgs} args - Arguments to find a OrderLabel
     * @example
     * // Get one OrderLabel
     * const orderLabel = await prisma.orderLabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderLabelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderLabelFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderLabelClient<OrderLabel>, Prisma__OrderLabelClient<OrderLabelGetPayload<T>>>

    /**
     * Count the number of OrderLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLabelCountArgs} args - Arguments to filter OrderLabels to count.
     * @example
     * // Count the number of OrderLabels
     * const count = await prisma.orderLabel.count({
     *   where: {
     *     // ... the filter for the OrderLabels we want to count
     *   }
     * })
    **/
    count<T extends OrderLabelCountArgs>(
      args?: Subset<T, OrderLabelCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderLabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderLabelAggregateArgs>(args: Subset<T, OrderLabelAggregateArgs>): PrismaPromise<GetOrderLabelAggregateType<T>>

    /**
     * Group by OrderLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderLabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderLabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderLabelGroupByArgs['orderBy'] }
        : { orderBy?: OrderLabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderLabelGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderLabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderLabelClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | Null>, Prisma__OrderClient<OrderGetPayload<T> | Null>>;

    label<T extends LabelArgs = {}>(args?: Subset<T, LabelArgs>): CheckSelect<T, Prisma__LabelClient<Label | Null>, Prisma__LabelClient<LabelGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrderLabel base type for findUnique actions
   */
  export type OrderLabelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
    /**
     * Filter, which OrderLabel to fetch.
     * 
    **/
    where: OrderLabelWhereUniqueInput
  }

  /**
   * OrderLabel: findUnique
   */
  export interface OrderLabelFindUniqueArgs extends OrderLabelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderLabel base type for findFirst actions
   */
  export type OrderLabelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
    /**
     * Filter, which OrderLabel to fetch.
     * 
    **/
    where?: OrderLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderLabels to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderLabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderLabels.
     * 
    **/
    cursor?: OrderLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderLabels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderLabels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderLabels.
     * 
    **/
    distinct?: Enumerable<OrderLabelScalarFieldEnum>
  }

  /**
   * OrderLabel: findFirst
   */
  export interface OrderLabelFindFirstArgs extends OrderLabelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderLabel findMany
   */
  export type OrderLabelFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
    /**
     * Filter, which OrderLabels to fetch.
     * 
    **/
    where?: OrderLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderLabels to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderLabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderLabels.
     * 
    **/
    cursor?: OrderLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderLabels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderLabels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderLabelScalarFieldEnum>
  }


  /**
   * OrderLabel create
   */
  export type OrderLabelCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
    /**
     * The data needed to create a OrderLabel.
     * 
    **/
    data: XOR<OrderLabelCreateInput, OrderLabelUncheckedCreateInput>
  }


  /**
   * OrderLabel createMany
   */
  export type OrderLabelCreateManyArgs = {
    /**
     * The data used to create many OrderLabels.
     * 
    **/
    data: Enumerable<OrderLabelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderLabel update
   */
  export type OrderLabelUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
    /**
     * The data needed to update a OrderLabel.
     * 
    **/
    data: XOR<OrderLabelUpdateInput, OrderLabelUncheckedUpdateInput>
    /**
     * Choose, which OrderLabel to update.
     * 
    **/
    where: OrderLabelWhereUniqueInput
  }


  /**
   * OrderLabel updateMany
   */
  export type OrderLabelUpdateManyArgs = {
    /**
     * The data used to update OrderLabels.
     * 
    **/
    data: XOR<OrderLabelUpdateManyMutationInput, OrderLabelUncheckedUpdateManyInput>
    /**
     * Filter which OrderLabels to update
     * 
    **/
    where?: OrderLabelWhereInput
  }


  /**
   * OrderLabel upsert
   */
  export type OrderLabelUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
    /**
     * The filter to search for the OrderLabel to update in case it exists.
     * 
    **/
    where: OrderLabelWhereUniqueInput
    /**
     * In case the OrderLabel found by the `where` argument doesn't exist, create a new OrderLabel with this data.
     * 
    **/
    create: XOR<OrderLabelCreateInput, OrderLabelUncheckedCreateInput>
    /**
     * In case the OrderLabel was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderLabelUpdateInput, OrderLabelUncheckedUpdateInput>
  }


  /**
   * OrderLabel delete
   */
  export type OrderLabelDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
    /**
     * Filter which OrderLabel to delete.
     * 
    **/
    where: OrderLabelWhereUniqueInput
  }


  /**
   * OrderLabel deleteMany
   */
  export type OrderLabelDeleteManyArgs = {
    /**
     * Filter which OrderLabels to delete
     * 
    **/
    where?: OrderLabelWhereInput
  }


  /**
   * OrderLabel: findUniqueOrThrow
   */
  export type OrderLabelFindUniqueOrThrowArgs = OrderLabelFindUniqueArgsBase
      

  /**
   * OrderLabel: findFirstOrThrow
   */
  export type OrderLabelFindFirstOrThrowArgs = OrderLabelFindFirstArgsBase
      

  /**
   * OrderLabel without action
   */
  export type OrderLabelArgs = {
    /**
     * Select specific fields to fetch from the OrderLabel
     * 
    **/
    select?: OrderLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderLabelInclude | null
  }



  /**
   * Model Invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    order_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvoiceMinAggregateInputType = {
    id?: true
    order_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    order_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    order_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvoiceAggregateArgs = {
    /**
     * Filter which Invoice to aggregate.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs = {
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithAggregationInput>
    by: Array<InvoiceScalarFieldEnum>
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    order_id: string
    created_at: Date
    updated_at: Date
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect = {
    id?: boolean
    order_id?: boolean
    order?: boolean | OrderArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type InvoiceInclude = {
    order?: boolean | OrderArgs
  }

  export type InvoiceGetPayload<
    S extends boolean | null | undefined | InvoiceArgs,
    U = keyof S
      > = S extends true
        ? Invoice
    : S extends undefined
    ? never
    : S extends InvoiceArgs | InvoiceFindManyArgs
    ?'include' extends U
    ? Invoice  & {
    [P in TrueKeys<S['include']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Invoice ? Invoice[P] : never
  } 
    : Invoice
  : Invoice


  type InvoiceCountArgs = Merge<
    Omit<InvoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }
  >

  export interface InvoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invoice'> extends True ? CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceClient<Invoice | null, null>, Prisma__InvoiceClient<InvoiceGetPayload<T> | null, null>>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invoice'> extends True ? CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceClient<Invoice | null, null>, Prisma__InvoiceClient<InvoiceGetPayload<T> | null, null>>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs>(
      args?: SelectSubset<T, InvoiceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Invoice>>, PrismaPromise<Array<InvoiceGetPayload<T>>>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs>(
      args: SelectSubset<T, InvoiceCreateArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs>(
      args?: SelectSubset<T, InvoiceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs>(
      args: SelectSubset<T, InvoiceDeleteArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs>(
      args: SelectSubset<T, InvoiceUpdateArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs>(
      args: SelectSubset<T, InvoiceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs>(
      args: SelectSubset<T, InvoiceUpsertArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Find one Invoice that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InvoiceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Find the first Invoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | Null>, Prisma__OrderClient<OrderGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invoice base type for findUnique actions
   */
  export type InvoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter, which Invoice to fetch.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice: findUnique
   */
  export interface InvoiceFindUniqueArgs extends InvoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice base type for findFirst actions
   */
  export type InvoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter, which Invoice to fetch.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     * 
    **/
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }

  /**
   * Invoice: findFirst
   */
  export interface InvoiceFindFirstArgs extends InvoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter, which Invoices to fetch.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The data needed to create a Invoice.
     * 
    **/
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs = {
    /**
     * The data used to create many Invoices.
     * 
    **/
    data: Enumerable<InvoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The data needed to update a Invoice.
     * 
    **/
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs = {
    /**
     * The data used to update Invoices.
     * 
    **/
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     * 
    **/
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     * 
    **/
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     * 
    **/
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter which Invoice to delete.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs = {
    /**
     * Filter which Invoices to delete
     * 
    **/
    where?: InvoiceWhereInput
  }


  /**
   * Invoice: findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs = InvoiceFindUniqueArgsBase
      

  /**
   * Invoice: findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs = InvoiceFindFirstArgsBase
      

  /**
   * Invoice without action
   */
  export type InvoiceArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
  }



  /**
   * Model Device
   */


  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    device_physical_id: string | null
    platform: PlatformType | null
    version: string | null
    token_notification: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    device_physical_id: string | null
    platform: PlatformType | null
    version: string | null
    token_notification: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    device_physical_id: number
    platform: number
    version: number
    token_notification: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true
    device_physical_id?: true
    platform?: true
    version?: true
    token_notification?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    device_physical_id?: true
    platform?: true
    version?: true
    token_notification?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    device_physical_id?: true
    platform?: true
    version?: true
    token_notification?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeviceAggregateArgs = {
    /**
     * Filter which Device to aggregate.
     * 
    **/
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs = {
    where?: DeviceWhereInput
    orderBy?: Enumerable<DeviceOrderByWithAggregationInput>
    by: Array<DeviceScalarFieldEnum>
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }


  export type DeviceGroupByOutputType = {
    id: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at: Date
    updated_at: Date
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect = {
    id?: boolean
    device_physical_id?: boolean
    platform?: boolean
    version?: boolean
    token_notification?: boolean
    created_at?: boolean
    updated_at?: boolean
    device_user?: boolean | DeviceUserFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    sms_notification?: boolean | SmsNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | DeviceCountOutputTypeArgs
  }

  export type DeviceInclude = {
    device_user?: boolean | DeviceUserFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    sms_notification?: boolean | SmsNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | DeviceCountOutputTypeArgs
  }

  export type DeviceGetPayload<
    S extends boolean | null | undefined | DeviceArgs,
    U = keyof S
      > = S extends true
        ? Device
    : S extends undefined
    ? never
    : S extends DeviceArgs | DeviceFindManyArgs
    ?'include' extends U
    ? Device  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? DeviceCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? DeviceCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Device ? Device[P] : never
  } 
    : Device
  : Device


  type DeviceCountArgs = Merge<
    Omit<DeviceFindManyArgs, 'select' | 'include'> & {
      select?: DeviceCountAggregateInputType | true
    }
  >

  export interface DeviceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeviceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Device'> extends True ? CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>> : CheckSelect<T, Prisma__DeviceClient<Device | null, null>, Prisma__DeviceClient<DeviceGetPayload<T> | null, null>>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeviceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Device'> extends True ? CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>> : CheckSelect<T, Prisma__DeviceClient<Device | null, null>, Prisma__DeviceClient<DeviceGetPayload<T> | null, null>>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeviceFindManyArgs>(
      args?: SelectSubset<T, DeviceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Device>>, PrismaPromise<Array<DeviceGetPayload<T>>>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
    **/
    create<T extends DeviceCreateArgs>(
      args: SelectSubset<T, DeviceCreateArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Create many Devices.
     *     @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     *     @example
     *     // Create many Devices
     *     const device = await prisma.device.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeviceCreateManyArgs>(
      args?: SelectSubset<T, DeviceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
    **/
    delete<T extends DeviceDeleteArgs>(
      args: SelectSubset<T, DeviceDeleteArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceUpdateArgs>(
      args: SelectSubset<T, DeviceUpdateArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceDeleteManyArgs>(
      args?: SelectSubset<T, DeviceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceUpdateManyArgs>(
      args: SelectSubset<T, DeviceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceUpsertArgs>(
      args: SelectSubset<T, DeviceUpsertArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Find one Device that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeviceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Find the first Device that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeviceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeviceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device_user<T extends DeviceUserFindManyArgs = {}>(args?: Subset<T, DeviceUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceUser>| Null>, PrismaPromise<Array<DeviceUserGetPayload<T>>| Null>>;

    push_notification<T extends PushNotificationFindManyArgs = {}>(args?: Subset<T, PushNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PushNotification>| Null>, PrismaPromise<Array<PushNotificationGetPayload<T>>| Null>>;

    sms_notification<T extends SmsNotificationFindManyArgs = {}>(args?: Subset<T, SmsNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SmsNotification>| Null>, PrismaPromise<Array<SmsNotificationGetPayload<T>>| Null>>;

    device_notification<T extends DeviceNotificationFindManyArgs = {}>(args?: Subset<T, DeviceNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceNotification>| Null>, PrismaPromise<Array<DeviceNotificationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Device base type for findUnique actions
   */
  export type DeviceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     * 
    **/
    where: DeviceWhereUniqueInput
  }

  /**
   * Device: findUnique
   */
  export interface DeviceFindUniqueArgs extends DeviceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Device base type for findFirst actions
   */
  export type DeviceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     * 
    **/
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     * 
    **/
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     * 
    **/
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }

  /**
   * Device: findFirst
   */
  export interface DeviceFindFirstArgs extends DeviceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter, which Devices to fetch.
     * 
    **/
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     * 
    **/
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }


  /**
   * Device create
   */
  export type DeviceCreateArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * The data needed to create a Device.
     * 
    **/
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }


  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs = {
    /**
     * The data used to create many Devices.
     * 
    **/
    data: Enumerable<DeviceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Device update
   */
  export type DeviceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * The data needed to update a Device.
     * 
    **/
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     * 
    **/
    where: DeviceWhereUniqueInput
  }


  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs = {
    /**
     * The data used to update Devices.
     * 
    **/
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     * 
    **/
    where?: DeviceWhereInput
  }


  /**
   * Device upsert
   */
  export type DeviceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * The filter to search for the Device to update in case it exists.
     * 
    **/
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     * 
    **/
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }


  /**
   * Device delete
   */
  export type DeviceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter which Device to delete.
     * 
    **/
    where: DeviceWhereUniqueInput
  }


  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs = {
    /**
     * Filter which Devices to delete
     * 
    **/
    where?: DeviceWhereInput
  }


  /**
   * Device: findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs = DeviceFindUniqueArgsBase
      

  /**
   * Device: findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs = DeviceFindFirstArgsBase
      

  /**
   * Device without action
   */
  export type DeviceArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
  }



  /**
   * Model DeviceUser
   */


  export type AggregateDeviceUser = {
    _count: DeviceUserCountAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  export type DeviceUserMinAggregateOutputType = {
    device_id: string | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceUserMaxAggregateOutputType = {
    device_id: string | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceUserCountAggregateOutputType = {
    device_id: number
    user_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeviceUserMinAggregateInputType = {
    device_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceUserMaxAggregateInputType = {
    device_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceUserCountAggregateInputType = {
    device_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeviceUserAggregateArgs = {
    /**
     * Filter which DeviceUser to aggregate.
     * 
    **/
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceUsers
    **/
    _count?: true | DeviceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceUserMaxAggregateInputType
  }

  export type GetDeviceUserAggregateType<T extends DeviceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceUser[P]>
      : GetScalarType<T[P], AggregateDeviceUser[P]>
  }




  export type DeviceUserGroupByArgs = {
    where?: DeviceUserWhereInput
    orderBy?: Enumerable<DeviceUserOrderByWithAggregationInput>
    by: Array<DeviceUserScalarFieldEnum>
    having?: DeviceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceUserCountAggregateInputType | true
    _min?: DeviceUserMinAggregateInputType
    _max?: DeviceUserMaxAggregateInputType
  }


  export type DeviceUserGroupByOutputType = {
    device_id: string
    user_id: string
    created_at: Date
    updated_at: Date
    _count: DeviceUserCountAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  type GetDeviceUserGroupByPayload<T extends DeviceUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeviceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
        }
      >
    >


  export type DeviceUserSelect = {
    device_id?: boolean
    device?: boolean | DeviceArgs
    user_id?: boolean
    user?: boolean | UserArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type DeviceUserInclude = {
    device?: boolean | DeviceArgs
    user?: boolean | UserArgs
  }

  export type DeviceUserGetPayload<
    S extends boolean | null | undefined | DeviceUserArgs,
    U = keyof S
      > = S extends true
        ? DeviceUser
    : S extends undefined
    ? never
    : S extends DeviceUserArgs | DeviceUserFindManyArgs
    ?'include' extends U
    ? DeviceUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof DeviceUser ? DeviceUser[P] : never
  } 
    : DeviceUser
  : DeviceUser


  type DeviceUserCountArgs = Merge<
    Omit<DeviceUserFindManyArgs, 'select' | 'include'> & {
      select?: DeviceUserCountAggregateInputType | true
    }
  >

  export interface DeviceUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DeviceUser that matches the filter.
     * @param {DeviceUserFindUniqueArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeviceUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeviceUser'> extends True ? CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>> : CheckSelect<T, Prisma__DeviceUserClient<DeviceUser | null, null>, Prisma__DeviceUserClient<DeviceUserGetPayload<T> | null, null>>

    /**
     * Find the first DeviceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeviceUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeviceUser'> extends True ? CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>> : CheckSelect<T, Prisma__DeviceUserClient<DeviceUser | null, null>, Prisma__DeviceUserClient<DeviceUserGetPayload<T> | null, null>>

    /**
     * Find zero or more DeviceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany()
     * 
     * // Get first 10 DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceUserWithDevice_idOnly = await prisma.deviceUser.findMany({ select: { device_id: true } })
     * 
    **/
    findMany<T extends DeviceUserFindManyArgs>(
      args?: SelectSubset<T, DeviceUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DeviceUser>>, PrismaPromise<Array<DeviceUserGetPayload<T>>>>

    /**
     * Create a DeviceUser.
     * @param {DeviceUserCreateArgs} args - Arguments to create a DeviceUser.
     * @example
     * // Create one DeviceUser
     * const DeviceUser = await prisma.deviceUser.create({
     *   data: {
     *     // ... data to create a DeviceUser
     *   }
     * })
     * 
    **/
    create<T extends DeviceUserCreateArgs>(
      args: SelectSubset<T, DeviceUserCreateArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Create many DeviceUsers.
     *     @param {DeviceUserCreateManyArgs} args - Arguments to create many DeviceUsers.
     *     @example
     *     // Create many DeviceUsers
     *     const deviceUser = await prisma.deviceUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeviceUserCreateManyArgs>(
      args?: SelectSubset<T, DeviceUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceUser.
     * @param {DeviceUserDeleteArgs} args - Arguments to delete one DeviceUser.
     * @example
     * // Delete one DeviceUser
     * const DeviceUser = await prisma.deviceUser.delete({
     *   where: {
     *     // ... filter to delete one DeviceUser
     *   }
     * })
     * 
    **/
    delete<T extends DeviceUserDeleteArgs>(
      args: SelectSubset<T, DeviceUserDeleteArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Update one DeviceUser.
     * @param {DeviceUserUpdateArgs} args - Arguments to update one DeviceUser.
     * @example
     * // Update one DeviceUser
     * const deviceUser = await prisma.deviceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceUserUpdateArgs>(
      args: SelectSubset<T, DeviceUserUpdateArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Delete zero or more DeviceUsers.
     * @param {DeviceUserDeleteManyArgs} args - Arguments to filter DeviceUsers to delete.
     * @example
     * // Delete a few DeviceUsers
     * const { count } = await prisma.deviceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceUserDeleteManyArgs>(
      args?: SelectSubset<T, DeviceUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceUsers
     * const deviceUser = await prisma.deviceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceUserUpdateManyArgs>(
      args: SelectSubset<T, DeviceUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceUser.
     * @param {DeviceUserUpsertArgs} args - Arguments to update or create a DeviceUser.
     * @example
     * // Update or create a DeviceUser
     * const deviceUser = await prisma.deviceUser.upsert({
     *   create: {
     *     // ... data to create a DeviceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceUser we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceUserUpsertArgs>(
      args: SelectSubset<T, DeviceUserUpsertArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Find one DeviceUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeviceUserFindUniqueOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeviceUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Find the first DeviceUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeviceUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Count the number of DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserCountArgs} args - Arguments to filter DeviceUsers to count.
     * @example
     * // Count the number of DeviceUsers
     * const count = await prisma.deviceUser.count({
     *   where: {
     *     // ... the filter for the DeviceUsers we want to count
     *   }
     * })
    **/
    count<T extends DeviceUserCountArgs>(
      args?: Subset<T, DeviceUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceUserAggregateArgs>(args: Subset<T, DeviceUserAggregateArgs>): PrismaPromise<GetDeviceUserAggregateType<T>>

    /**
     * Group by DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceUserGroupByArgs['orderBy'] }
        : { orderBy?: DeviceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeviceUserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeviceUser base type for findUnique actions
   */
  export type DeviceUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter, which DeviceUser to fetch.
     * 
    **/
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser: findUnique
   */
  export interface DeviceUserFindUniqueArgs extends DeviceUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceUser base type for findFirst actions
   */
  export type DeviceUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter, which DeviceUser to fetch.
     * 
    **/
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceUsers.
     * 
    **/
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceUsers.
     * 
    **/
    distinct?: Enumerable<DeviceUserScalarFieldEnum>
  }

  /**
   * DeviceUser: findFirst
   */
  export interface DeviceUserFindFirstArgs extends DeviceUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceUser findMany
   */
  export type DeviceUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter, which DeviceUsers to fetch.
     * 
    **/
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceUsers.
     * 
    **/
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeviceUserScalarFieldEnum>
  }


  /**
   * DeviceUser create
   */
  export type DeviceUserCreateArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * The data needed to create a DeviceUser.
     * 
    **/
    data: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
  }


  /**
   * DeviceUser createMany
   */
  export type DeviceUserCreateManyArgs = {
    /**
     * The data used to create many DeviceUsers.
     * 
    **/
    data: Enumerable<DeviceUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeviceUser update
   */
  export type DeviceUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * The data needed to update a DeviceUser.
     * 
    **/
    data: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
    /**
     * Choose, which DeviceUser to update.
     * 
    **/
    where: DeviceUserWhereUniqueInput
  }


  /**
   * DeviceUser updateMany
   */
  export type DeviceUserUpdateManyArgs = {
    /**
     * The data used to update DeviceUsers.
     * 
    **/
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyInput>
    /**
     * Filter which DeviceUsers to update
     * 
    **/
    where?: DeviceUserWhereInput
  }


  /**
   * DeviceUser upsert
   */
  export type DeviceUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * The filter to search for the DeviceUser to update in case it exists.
     * 
    **/
    where: DeviceUserWhereUniqueInput
    /**
     * In case the DeviceUser found by the `where` argument doesn't exist, create a new DeviceUser with this data.
     * 
    **/
    create: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
    /**
     * In case the DeviceUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
  }


  /**
   * DeviceUser delete
   */
  export type DeviceUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter which DeviceUser to delete.
     * 
    **/
    where: DeviceUserWhereUniqueInput
  }


  /**
   * DeviceUser deleteMany
   */
  export type DeviceUserDeleteManyArgs = {
    /**
     * Filter which DeviceUsers to delete
     * 
    **/
    where?: DeviceUserWhereInput
  }


  /**
   * DeviceUser: findUniqueOrThrow
   */
  export type DeviceUserFindUniqueOrThrowArgs = DeviceUserFindUniqueArgsBase
      

  /**
   * DeviceUser: findFirstOrThrow
   */
  export type DeviceUserFindFirstOrThrowArgs = DeviceUserFindFirstArgsBase
      

  /**
   * DeviceUser without action
   */
  export type DeviceUserArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
  }



  /**
   * Model Notifications
   */


  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    type: TypeNotification | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    type: TypeNotification | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    title: number
    message: number
    created_at: number
    updated_at: number
    type: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
    updated_at?: true
    type?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
    updated_at?: true
    type?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
    updated_at?: true
    type?: true
    _all?: true
  }

  export type NotificationsAggregateArgs = {
    /**
     * Filter which Notifications to aggregate.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs = {
    where?: NotificationsWhereInput
    orderBy?: Enumerable<NotificationsOrderByWithAggregationInput>
    by: Array<NotificationsScalarFieldEnum>
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }


  export type NotificationsGroupByOutputType = {
    id: string
    title: string
    message: string
    created_at: Date
    updated_at: Date
    type: TypeNotification
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect = {
    id?: boolean
    title?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    type?: boolean
    sms_notification?: boolean | SmsNotificationFindManyArgs
    email_notification?: boolean | EmailNotificationFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | NotificationsCountOutputTypeArgs
  }

  export type NotificationsInclude = {
    sms_notification?: boolean | SmsNotificationFindManyArgs
    email_notification?: boolean | EmailNotificationFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | NotificationsCountOutputTypeArgs
  }

  export type NotificationsGetPayload<
    S extends boolean | null | undefined | NotificationsArgs,
    U = keyof S
      > = S extends true
        ? Notifications
    : S extends undefined
    ? never
    : S extends NotificationsArgs | NotificationsFindManyArgs
    ?'include' extends U
    ? Notifications  & {
    [P in TrueKeys<S['include']>]:
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'email_notification' ? Array < EmailNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? NotificationsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'email_notification' ? Array < EmailNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? NotificationsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Notifications ? Notifications[P] : never
  } 
    : Notifications
  : Notifications


  type NotificationsCountArgs = Merge<
    Omit<NotificationsFindManyArgs, 'select' | 'include'> & {
      select?: NotificationsCountAggregateInputType | true
    }
  >

  export interface NotificationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notifications'> extends True ? CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>> : CheckSelect<T, Prisma__NotificationsClient<Notifications | null, null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | null, null>>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notifications'> extends True ? CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>> : CheckSelect<T, Prisma__NotificationsClient<Notifications | null, null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | null, null>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationsFindManyArgs>(
      args?: SelectSubset<T, NotificationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notifications>>, PrismaPromise<Array<NotificationsGetPayload<T>>>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
    **/
    create<T extends NotificationsCreateArgs>(
      args: SelectSubset<T, NotificationsCreateArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Create many Notifications.
     *     @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notifications = await prisma.notifications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationsCreateManyArgs>(
      args?: SelectSubset<T, NotificationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
    **/
    delete<T extends NotificationsDeleteArgs>(
      args: SelectSubset<T, NotificationsDeleteArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationsUpdateArgs>(
      args: SelectSubset<T, NotificationsUpdateArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationsDeleteManyArgs>(
      args?: SelectSubset<T, NotificationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationsUpdateManyArgs>(
      args: SelectSubset<T, NotificationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationsUpsertArgs>(
      args: SelectSubset<T, NotificationsUpsertArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Find one Notifications that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Find the first Notifications that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sms_notification<T extends SmsNotificationFindManyArgs = {}>(args?: Subset<T, SmsNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SmsNotification>| Null>, PrismaPromise<Array<SmsNotificationGetPayload<T>>| Null>>;

    email_notification<T extends EmailNotificationFindManyArgs = {}>(args?: Subset<T, EmailNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EmailNotification>| Null>, PrismaPromise<Array<EmailNotificationGetPayload<T>>| Null>>;

    push_notification<T extends PushNotificationFindManyArgs = {}>(args?: Subset<T, PushNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PushNotification>| Null>, PrismaPromise<Array<PushNotificationGetPayload<T>>| Null>>;

    device_notification<T extends DeviceNotificationFindManyArgs = {}>(args?: Subset<T, DeviceNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceNotification>| Null>, PrismaPromise<Array<DeviceNotificationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notifications base type for findUnique actions
   */
  export type NotificationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications: findUnique
   */
  export interface NotificationsFindUniqueArgs extends NotificationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notifications base type for findFirst actions
   */
  export type NotificationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationsScalarFieldEnum>
  }

  /**
   * Notifications: findFirst
   */
  export interface NotificationsFindFirstArgs extends NotificationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationsScalarFieldEnum>
  }


  /**
   * Notifications create
   */
  export type NotificationsCreateArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The data needed to create a Notifications.
     * 
    **/
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }


  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     * 
    **/
    data: Enumerable<NotificationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The data needed to update a Notifications.
     * 
    **/
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     * 
    **/
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     * 
    **/
    where?: NotificationsWhereInput
  }


  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     * 
    **/
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     * 
    **/
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }


  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter which Notifications to delete.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     * 
    **/
    where?: NotificationsWhereInput
  }


  /**
   * Notifications: findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs = NotificationsFindUniqueArgsBase
      

  /**
   * Notifications: findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs = NotificationsFindFirstArgsBase
      

  /**
   * Notifications without action
   */
  export type NotificationsArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
  }



  /**
   * Model EmailNotification
   */


  export type AggregateEmailNotification = {
    _count: EmailNotificationCountAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  export type EmailNotificationMinAggregateOutputType = {
    id: string | null
    notification_id: string | null
    to: string | null
    from: string | null
    from_name: string | null
    cc: string | null
    bcc: string | null
    type: EmailTypeNotification | null
    subject: string | null
    body: string | null
    url_callback: string | null
    opened: string | null
    clicked: string | null
    failed: string | null
    error_description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmailNotificationMaxAggregateOutputType = {
    id: string | null
    notification_id: string | null
    to: string | null
    from: string | null
    from_name: string | null
    cc: string | null
    bcc: string | null
    type: EmailTypeNotification | null
    subject: string | null
    body: string | null
    url_callback: string | null
    opened: string | null
    clicked: string | null
    failed: string | null
    error_description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmailNotificationCountAggregateOutputType = {
    id: number
    notification_id: number
    to: number
    from: number
    from_name: number
    cc: number
    bcc: number
    type: number
    subject: number
    body: number
    url_callback: number
    opened: number
    clicked: number
    failed: number
    error_description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EmailNotificationMinAggregateInputType = {
    id?: true
    notification_id?: true
    to?: true
    from?: true
    from_name?: true
    cc?: true
    bcc?: true
    type?: true
    subject?: true
    body?: true
    url_callback?: true
    opened?: true
    clicked?: true
    failed?: true
    error_description?: true
    created_at?: true
    updated_at?: true
  }

  export type EmailNotificationMaxAggregateInputType = {
    id?: true
    notification_id?: true
    to?: true
    from?: true
    from_name?: true
    cc?: true
    bcc?: true
    type?: true
    subject?: true
    body?: true
    url_callback?: true
    opened?: true
    clicked?: true
    failed?: true
    error_description?: true
    created_at?: true
    updated_at?: true
  }

  export type EmailNotificationCountAggregateInputType = {
    id?: true
    notification_id?: true
    to?: true
    from?: true
    from_name?: true
    cc?: true
    bcc?: true
    type?: true
    subject?: true
    body?: true
    url_callback?: true
    opened?: true
    clicked?: true
    failed?: true
    error_description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EmailNotificationAggregateArgs = {
    /**
     * Filter which EmailNotification to aggregate.
     * 
    **/
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<EmailNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailNotifications
    **/
    _count?: true | EmailNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type GetEmailNotificationAggregateType<T extends EmailNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailNotification[P]>
      : GetScalarType<T[P], AggregateEmailNotification[P]>
  }




  export type EmailNotificationGroupByArgs = {
    where?: EmailNotificationWhereInput
    orderBy?: Enumerable<EmailNotificationOrderByWithAggregationInput>
    by: Array<EmailNotificationScalarFieldEnum>
    having?: EmailNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailNotificationCountAggregateInputType | true
    _min?: EmailNotificationMinAggregateInputType
    _max?: EmailNotificationMaxAggregateInputType
  }


  export type EmailNotificationGroupByOutputType = {
    id: string
    notification_id: string
    to: string
    from: string
    from_name: string
    cc: string | null
    bcc: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened: string | null
    clicked: string | null
    failed: string | null
    error_description: string | null
    created_at: Date
    updated_at: Date
    _count: EmailNotificationCountAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  type GetEmailNotificationGroupByPayload<T extends EmailNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmailNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailNotificationSelect = {
    id?: boolean
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    to?: boolean
    from?: boolean
    from_name?: boolean
    cc?: boolean
    bcc?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    url_callback?: boolean
    opened?: boolean
    clicked?: boolean
    failed?: boolean
    error_description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type EmailNotificationInclude = {
    notification?: boolean | NotificationsArgs
  }

  export type EmailNotificationGetPayload<
    S extends boolean | null | undefined | EmailNotificationArgs,
    U = keyof S
      > = S extends true
        ? EmailNotification
    : S extends undefined
    ? never
    : S extends EmailNotificationArgs | EmailNotificationFindManyArgs
    ?'include' extends U
    ? EmailNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof EmailNotification ? EmailNotification[P] : never
  } 
    : EmailNotification
  : EmailNotification


  type EmailNotificationCountArgs = Merge<
    Omit<EmailNotificationFindManyArgs, 'select' | 'include'> & {
      select?: EmailNotificationCountAggregateInputType | true
    }
  >

  export interface EmailNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EmailNotification that matches the filter.
     * @param {EmailNotificationFindUniqueArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmailNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EmailNotification'> extends True ? CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>> : CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification | null, null>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T> | null, null>>

    /**
     * Find the first EmailNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmailNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EmailNotification'> extends True ? CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>> : CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification | null, null>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more EmailNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany()
     * 
     * // Get first 10 EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailNotificationFindManyArgs>(
      args?: SelectSubset<T, EmailNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EmailNotification>>, PrismaPromise<Array<EmailNotificationGetPayload<T>>>>

    /**
     * Create a EmailNotification.
     * @param {EmailNotificationCreateArgs} args - Arguments to create a EmailNotification.
     * @example
     * // Create one EmailNotification
     * const EmailNotification = await prisma.emailNotification.create({
     *   data: {
     *     // ... data to create a EmailNotification
     *   }
     * })
     * 
    **/
    create<T extends EmailNotificationCreateArgs>(
      args: SelectSubset<T, EmailNotificationCreateArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Create many EmailNotifications.
     *     @param {EmailNotificationCreateManyArgs} args - Arguments to create many EmailNotifications.
     *     @example
     *     // Create many EmailNotifications
     *     const emailNotification = await prisma.emailNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailNotificationCreateManyArgs>(
      args?: SelectSubset<T, EmailNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EmailNotification.
     * @param {EmailNotificationDeleteArgs} args - Arguments to delete one EmailNotification.
     * @example
     * // Delete one EmailNotification
     * const EmailNotification = await prisma.emailNotification.delete({
     *   where: {
     *     // ... filter to delete one EmailNotification
     *   }
     * })
     * 
    **/
    delete<T extends EmailNotificationDeleteArgs>(
      args: SelectSubset<T, EmailNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Update one EmailNotification.
     * @param {EmailNotificationUpdateArgs} args - Arguments to update one EmailNotification.
     * @example
     * // Update one EmailNotification
     * const emailNotification = await prisma.emailNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailNotificationUpdateArgs>(
      args: SelectSubset<T, EmailNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Delete zero or more EmailNotifications.
     * @param {EmailNotificationDeleteManyArgs} args - Arguments to filter EmailNotifications to delete.
     * @example
     * // Delete a few EmailNotifications
     * const { count } = await prisma.emailNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailNotificationDeleteManyArgs>(
      args?: SelectSubset<T, EmailNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailNotifications
     * const emailNotification = await prisma.emailNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailNotificationUpdateManyArgs>(
      args: SelectSubset<T, EmailNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailNotification.
     * @param {EmailNotificationUpsertArgs} args - Arguments to update or create a EmailNotification.
     * @example
     * // Update or create a EmailNotification
     * const emailNotification = await prisma.emailNotification.upsert({
     *   create: {
     *     // ... data to create a EmailNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailNotification we want to update
     *   }
     * })
    **/
    upsert<T extends EmailNotificationUpsertArgs>(
      args: SelectSubset<T, EmailNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Find one EmailNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {EmailNotificationFindUniqueOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EmailNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Find the first EmailNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EmailNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Count the number of EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationCountArgs} args - Arguments to filter EmailNotifications to count.
     * @example
     * // Count the number of EmailNotifications
     * const count = await prisma.emailNotification.count({
     *   where: {
     *     // ... the filter for the EmailNotifications we want to count
     *   }
     * })
    **/
    count<T extends EmailNotificationCountArgs>(
      args?: Subset<T, EmailNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailNotificationAggregateArgs>(args: Subset<T, EmailNotificationAggregateArgs>): PrismaPromise<GetEmailNotificationAggregateType<T>>

    /**
     * Group by EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailNotificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmailNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EmailNotification base type for findUnique actions
   */
  export type EmailNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter, which EmailNotification to fetch.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification: findUnique
   */
  export interface EmailNotificationFindUniqueArgs extends EmailNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmailNotification base type for findFirst actions
   */
  export type EmailNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter, which EmailNotification to fetch.
     * 
    **/
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<EmailNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     * 
    **/
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     * 
    **/
    distinct?: Enumerable<EmailNotificationScalarFieldEnum>
  }

  /**
   * EmailNotification: findFirst
   */
  export interface EmailNotificationFindFirstArgs extends EmailNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmailNotification findMany
   */
  export type EmailNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter, which EmailNotifications to fetch.
     * 
    **/
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<EmailNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailNotifications.
     * 
    **/
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmailNotificationScalarFieldEnum>
  }


  /**
   * EmailNotification create
   */
  export type EmailNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * The data needed to create a EmailNotification.
     * 
    **/
    data: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
  }


  /**
   * EmailNotification createMany
   */
  export type EmailNotificationCreateManyArgs = {
    /**
     * The data used to create many EmailNotifications.
     * 
    **/
    data: Enumerable<EmailNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EmailNotification update
   */
  export type EmailNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * The data needed to update a EmailNotification.
     * 
    **/
    data: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
    /**
     * Choose, which EmailNotification to update.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
  }


  /**
   * EmailNotification updateMany
   */
  export type EmailNotificationUpdateManyArgs = {
    /**
     * The data used to update EmailNotifications.
     * 
    **/
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailNotifications to update
     * 
    **/
    where?: EmailNotificationWhereInput
  }


  /**
   * EmailNotification upsert
   */
  export type EmailNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * The filter to search for the EmailNotification to update in case it exists.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
    /**
     * In case the EmailNotification found by the `where` argument doesn't exist, create a new EmailNotification with this data.
     * 
    **/
    create: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
    /**
     * In case the EmailNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
  }


  /**
   * EmailNotification delete
   */
  export type EmailNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter which EmailNotification to delete.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
  }


  /**
   * EmailNotification deleteMany
   */
  export type EmailNotificationDeleteManyArgs = {
    /**
     * Filter which EmailNotifications to delete
     * 
    **/
    where?: EmailNotificationWhereInput
  }


  /**
   * EmailNotification: findUniqueOrThrow
   */
  export type EmailNotificationFindUniqueOrThrowArgs = EmailNotificationFindUniqueArgsBase
      

  /**
   * EmailNotification: findFirstOrThrow
   */
  export type EmailNotificationFindFirstOrThrowArgs = EmailNotificationFindFirstArgsBase
      

  /**
   * EmailNotification without action
   */
  export type EmailNotificationArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
  }



  /**
   * Model SmsNotification
   */


  export type AggregateSmsNotification = {
    _count: SmsNotificationCountAggregateOutputType | null
    _min: SmsNotificationMinAggregateOutputType | null
    _max: SmsNotificationMaxAggregateOutputType | null
  }

  export type SmsNotificationMinAggregateOutputType = {
    id: string | null
    notification_id: string | null
    device_id: string | null
    to: string | null
    subject: string | null
    body: string | null
    send: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SmsNotificationMaxAggregateOutputType = {
    id: string | null
    notification_id: string | null
    device_id: string | null
    to: string | null
    subject: string | null
    body: string | null
    send: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SmsNotificationCountAggregateOutputType = {
    id: number
    notification_id: number
    device_id: number
    to: number
    subject: number
    body: number
    send: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SmsNotificationMinAggregateInputType = {
    id?: true
    notification_id?: true
    device_id?: true
    to?: true
    subject?: true
    body?: true
    send?: true
    created_at?: true
    updated_at?: true
  }

  export type SmsNotificationMaxAggregateInputType = {
    id?: true
    notification_id?: true
    device_id?: true
    to?: true
    subject?: true
    body?: true
    send?: true
    created_at?: true
    updated_at?: true
  }

  export type SmsNotificationCountAggregateInputType = {
    id?: true
    notification_id?: true
    device_id?: true
    to?: true
    subject?: true
    body?: true
    send?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SmsNotificationAggregateArgs = {
    /**
     * Filter which SmsNotification to aggregate.
     * 
    **/
    where?: SmsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<SmsNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SmsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmsNotifications
    **/
    _count?: true | SmsNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmsNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmsNotificationMaxAggregateInputType
  }

  export type GetSmsNotificationAggregateType<T extends SmsNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSmsNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmsNotification[P]>
      : GetScalarType<T[P], AggregateSmsNotification[P]>
  }




  export type SmsNotificationGroupByArgs = {
    where?: SmsNotificationWhereInput
    orderBy?: Enumerable<SmsNotificationOrderByWithAggregationInput>
    by: Array<SmsNotificationScalarFieldEnum>
    having?: SmsNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmsNotificationCountAggregateInputType | true
    _min?: SmsNotificationMinAggregateInputType
    _max?: SmsNotificationMaxAggregateInputType
  }


  export type SmsNotificationGroupByOutputType = {
    id: string
    notification_id: string
    device_id: string
    to: string
    subject: string
    body: string
    send: string | null
    created_at: Date
    updated_at: Date
    _count: SmsNotificationCountAggregateOutputType | null
    _min: SmsNotificationMinAggregateOutputType | null
    _max: SmsNotificationMaxAggregateOutputType | null
  }

  type GetSmsNotificationGroupByPayload<T extends SmsNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SmsNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmsNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmsNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], SmsNotificationGroupByOutputType[P]>
        }
      >
    >


  export type SmsNotificationSelect = {
    id?: boolean
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    device_id?: boolean
    device?: boolean | DeviceArgs
    to?: boolean
    subject?: boolean
    body?: boolean
    send?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SmsNotificationInclude = {
    notification?: boolean | NotificationsArgs
    device?: boolean | DeviceArgs
  }

  export type SmsNotificationGetPayload<
    S extends boolean | null | undefined | SmsNotificationArgs,
    U = keyof S
      > = S extends true
        ? SmsNotification
    : S extends undefined
    ? never
    : S extends SmsNotificationArgs | SmsNotificationFindManyArgs
    ?'include' extends U
    ? SmsNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SmsNotification ? SmsNotification[P] : never
  } 
    : SmsNotification
  : SmsNotification


  type SmsNotificationCountArgs = Merge<
    Omit<SmsNotificationFindManyArgs, 'select' | 'include'> & {
      select?: SmsNotificationCountAggregateInputType | true
    }
  >

  export interface SmsNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SmsNotification that matches the filter.
     * @param {SmsNotificationFindUniqueArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SmsNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SmsNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SmsNotification'> extends True ? CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>> : CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification | null, null>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T> | null, null>>

    /**
     * Find the first SmsNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationFindFirstArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SmsNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SmsNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SmsNotification'> extends True ? CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>> : CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification | null, null>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more SmsNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmsNotifications
     * const smsNotifications = await prisma.smsNotification.findMany()
     * 
     * // Get first 10 SmsNotifications
     * const smsNotifications = await prisma.smsNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smsNotificationWithIdOnly = await prisma.smsNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SmsNotificationFindManyArgs>(
      args?: SelectSubset<T, SmsNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SmsNotification>>, PrismaPromise<Array<SmsNotificationGetPayload<T>>>>

    /**
     * Create a SmsNotification.
     * @param {SmsNotificationCreateArgs} args - Arguments to create a SmsNotification.
     * @example
     * // Create one SmsNotification
     * const SmsNotification = await prisma.smsNotification.create({
     *   data: {
     *     // ... data to create a SmsNotification
     *   }
     * })
     * 
    **/
    create<T extends SmsNotificationCreateArgs>(
      args: SelectSubset<T, SmsNotificationCreateArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Create many SmsNotifications.
     *     @param {SmsNotificationCreateManyArgs} args - Arguments to create many SmsNotifications.
     *     @example
     *     // Create many SmsNotifications
     *     const smsNotification = await prisma.smsNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SmsNotificationCreateManyArgs>(
      args?: SelectSubset<T, SmsNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SmsNotification.
     * @param {SmsNotificationDeleteArgs} args - Arguments to delete one SmsNotification.
     * @example
     * // Delete one SmsNotification
     * const SmsNotification = await prisma.smsNotification.delete({
     *   where: {
     *     // ... filter to delete one SmsNotification
     *   }
     * })
     * 
    **/
    delete<T extends SmsNotificationDeleteArgs>(
      args: SelectSubset<T, SmsNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Update one SmsNotification.
     * @param {SmsNotificationUpdateArgs} args - Arguments to update one SmsNotification.
     * @example
     * // Update one SmsNotification
     * const smsNotification = await prisma.smsNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SmsNotificationUpdateArgs>(
      args: SelectSubset<T, SmsNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Delete zero or more SmsNotifications.
     * @param {SmsNotificationDeleteManyArgs} args - Arguments to filter SmsNotifications to delete.
     * @example
     * // Delete a few SmsNotifications
     * const { count } = await prisma.smsNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SmsNotificationDeleteManyArgs>(
      args?: SelectSubset<T, SmsNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmsNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmsNotifications
     * const smsNotification = await prisma.smsNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SmsNotificationUpdateManyArgs>(
      args: SelectSubset<T, SmsNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SmsNotification.
     * @param {SmsNotificationUpsertArgs} args - Arguments to update or create a SmsNotification.
     * @example
     * // Update or create a SmsNotification
     * const smsNotification = await prisma.smsNotification.upsert({
     *   create: {
     *     // ... data to create a SmsNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmsNotification we want to update
     *   }
     * })
    **/
    upsert<T extends SmsNotificationUpsertArgs>(
      args: SelectSubset<T, SmsNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Find one SmsNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SmsNotificationFindUniqueOrThrowArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SmsNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SmsNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Find the first SmsNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationFindFirstOrThrowArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SmsNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SmsNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Count the number of SmsNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationCountArgs} args - Arguments to filter SmsNotifications to count.
     * @example
     * // Count the number of SmsNotifications
     * const count = await prisma.smsNotification.count({
     *   where: {
     *     // ... the filter for the SmsNotifications we want to count
     *   }
     * })
    **/
    count<T extends SmsNotificationCountArgs>(
      args?: Subset<T, SmsNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmsNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmsNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmsNotificationAggregateArgs>(args: Subset<T, SmsNotificationAggregateArgs>): PrismaPromise<GetSmsNotificationAggregateType<T>>

    /**
     * Group by SmsNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmsNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmsNotificationGroupByArgs['orderBy'] }
        : { orderBy?: SmsNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmsNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmsNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SmsNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SmsNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SmsNotification base type for findUnique actions
   */
  export type SmsNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter, which SmsNotification to fetch.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
  }

  /**
   * SmsNotification: findUnique
   */
  export interface SmsNotificationFindUniqueArgs extends SmsNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SmsNotification base type for findFirst actions
   */
  export type SmsNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter, which SmsNotification to fetch.
     * 
    **/
    where?: SmsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<SmsNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmsNotifications.
     * 
    **/
    cursor?: SmsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmsNotifications.
     * 
    **/
    distinct?: Enumerable<SmsNotificationScalarFieldEnum>
  }

  /**
   * SmsNotification: findFirst
   */
  export interface SmsNotificationFindFirstArgs extends SmsNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SmsNotification findMany
   */
  export type SmsNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter, which SmsNotifications to fetch.
     * 
    **/
    where?: SmsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<SmsNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmsNotifications.
     * 
    **/
    cursor?: SmsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SmsNotificationScalarFieldEnum>
  }


  /**
   * SmsNotification create
   */
  export type SmsNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * The data needed to create a SmsNotification.
     * 
    **/
    data: XOR<SmsNotificationCreateInput, SmsNotificationUncheckedCreateInput>
  }


  /**
   * SmsNotification createMany
   */
  export type SmsNotificationCreateManyArgs = {
    /**
     * The data used to create many SmsNotifications.
     * 
    **/
    data: Enumerable<SmsNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SmsNotification update
   */
  export type SmsNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * The data needed to update a SmsNotification.
     * 
    **/
    data: XOR<SmsNotificationUpdateInput, SmsNotificationUncheckedUpdateInput>
    /**
     * Choose, which SmsNotification to update.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
  }


  /**
   * SmsNotification updateMany
   */
  export type SmsNotificationUpdateManyArgs = {
    /**
     * The data used to update SmsNotifications.
     * 
    **/
    data: XOR<SmsNotificationUpdateManyMutationInput, SmsNotificationUncheckedUpdateManyInput>
    /**
     * Filter which SmsNotifications to update
     * 
    **/
    where?: SmsNotificationWhereInput
  }


  /**
   * SmsNotification upsert
   */
  export type SmsNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * The filter to search for the SmsNotification to update in case it exists.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
    /**
     * In case the SmsNotification found by the `where` argument doesn't exist, create a new SmsNotification with this data.
     * 
    **/
    create: XOR<SmsNotificationCreateInput, SmsNotificationUncheckedCreateInput>
    /**
     * In case the SmsNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SmsNotificationUpdateInput, SmsNotificationUncheckedUpdateInput>
  }


  /**
   * SmsNotification delete
   */
  export type SmsNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter which SmsNotification to delete.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
  }


  /**
   * SmsNotification deleteMany
   */
  export type SmsNotificationDeleteManyArgs = {
    /**
     * Filter which SmsNotifications to delete
     * 
    **/
    where?: SmsNotificationWhereInput
  }


  /**
   * SmsNotification: findUniqueOrThrow
   */
  export type SmsNotificationFindUniqueOrThrowArgs = SmsNotificationFindUniqueArgsBase
      

  /**
   * SmsNotification: findFirstOrThrow
   */
  export type SmsNotificationFindFirstOrThrowArgs = SmsNotificationFindFirstArgsBase
      

  /**
   * SmsNotification without action
   */
  export type SmsNotificationArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
  }



  /**
   * Model PushNotification
   */


  export type AggregatePushNotification = {
    _count: PushNotificationCountAggregateOutputType | null
    _min: PushNotificationMinAggregateOutputType | null
    _max: PushNotificationMaxAggregateOutputType | null
  }

  export type PushNotificationMinAggregateOutputType = {
    id: string | null
    notification_id: string | null
    title: string | null
    subject: string | null
    send: string | null
    device_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PushNotificationMaxAggregateOutputType = {
    id: string | null
    notification_id: string | null
    title: string | null
    subject: string | null
    send: string | null
    device_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PushNotificationCountAggregateOutputType = {
    id: number
    notification_id: number
    title: number
    subject: number
    send: number
    device_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PushNotificationMinAggregateInputType = {
    id?: true
    notification_id?: true
    title?: true
    subject?: true
    send?: true
    device_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PushNotificationMaxAggregateInputType = {
    id?: true
    notification_id?: true
    title?: true
    subject?: true
    send?: true
    device_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PushNotificationCountAggregateInputType = {
    id?: true
    notification_id?: true
    title?: true
    subject?: true
    send?: true
    device_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PushNotificationAggregateArgs = {
    /**
     * Filter which PushNotification to aggregate.
     * 
    **/
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<PushNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushNotifications
    **/
    _count?: true | PushNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushNotificationMaxAggregateInputType
  }

  export type GetPushNotificationAggregateType<T extends PushNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePushNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushNotification[P]>
      : GetScalarType<T[P], AggregatePushNotification[P]>
  }




  export type PushNotificationGroupByArgs = {
    where?: PushNotificationWhereInput
    orderBy?: Enumerable<PushNotificationOrderByWithAggregationInput>
    by: Array<PushNotificationScalarFieldEnum>
    having?: PushNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushNotificationCountAggregateInputType | true
    _min?: PushNotificationMinAggregateInputType
    _max?: PushNotificationMaxAggregateInputType
  }


  export type PushNotificationGroupByOutputType = {
    id: string
    notification_id: string
    title: string
    subject: string
    send: string | null
    device_id: string
    created_at: Date
    updated_at: Date
    _count: PushNotificationCountAggregateOutputType | null
    _min: PushNotificationMinAggregateOutputType | null
    _max: PushNotificationMaxAggregateOutputType | null
  }

  type GetPushNotificationGroupByPayload<T extends PushNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PushNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], PushNotificationGroupByOutputType[P]>
        }
      >
    >


  export type PushNotificationSelect = {
    id?: boolean
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    title?: boolean
    subject?: boolean
    send?: boolean
    device_id?: boolean
    device?: boolean | DeviceArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type PushNotificationInclude = {
    notification?: boolean | NotificationsArgs
    device?: boolean | DeviceArgs
  }

  export type PushNotificationGetPayload<
    S extends boolean | null | undefined | PushNotificationArgs,
    U = keyof S
      > = S extends true
        ? PushNotification
    : S extends undefined
    ? never
    : S extends PushNotificationArgs | PushNotificationFindManyArgs
    ?'include' extends U
    ? PushNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof PushNotification ? PushNotification[P] : never
  } 
    : PushNotification
  : PushNotification


  type PushNotificationCountArgs = Merge<
    Omit<PushNotificationFindManyArgs, 'select' | 'include'> & {
      select?: PushNotificationCountAggregateInputType | true
    }
  >

  export interface PushNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PushNotification that matches the filter.
     * @param {PushNotificationFindUniqueArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PushNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PushNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PushNotification'> extends True ? CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>> : CheckSelect<T, Prisma__PushNotificationClient<PushNotification | null, null>, Prisma__PushNotificationClient<PushNotificationGetPayload<T> | null, null>>

    /**
     * Find the first PushNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindFirstArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PushNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PushNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PushNotification'> extends True ? CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>> : CheckSelect<T, Prisma__PushNotificationClient<PushNotification | null, null>, Prisma__PushNotificationClient<PushNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more PushNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushNotifications
     * const pushNotifications = await prisma.pushNotification.findMany()
     * 
     * // Get first 10 PushNotifications
     * const pushNotifications = await prisma.pushNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushNotificationWithIdOnly = await prisma.pushNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PushNotificationFindManyArgs>(
      args?: SelectSubset<T, PushNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PushNotification>>, PrismaPromise<Array<PushNotificationGetPayload<T>>>>

    /**
     * Create a PushNotification.
     * @param {PushNotificationCreateArgs} args - Arguments to create a PushNotification.
     * @example
     * // Create one PushNotification
     * const PushNotification = await prisma.pushNotification.create({
     *   data: {
     *     // ... data to create a PushNotification
     *   }
     * })
     * 
    **/
    create<T extends PushNotificationCreateArgs>(
      args: SelectSubset<T, PushNotificationCreateArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Create many PushNotifications.
     *     @param {PushNotificationCreateManyArgs} args - Arguments to create many PushNotifications.
     *     @example
     *     // Create many PushNotifications
     *     const pushNotification = await prisma.pushNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PushNotificationCreateManyArgs>(
      args?: SelectSubset<T, PushNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PushNotification.
     * @param {PushNotificationDeleteArgs} args - Arguments to delete one PushNotification.
     * @example
     * // Delete one PushNotification
     * const PushNotification = await prisma.pushNotification.delete({
     *   where: {
     *     // ... filter to delete one PushNotification
     *   }
     * })
     * 
    **/
    delete<T extends PushNotificationDeleteArgs>(
      args: SelectSubset<T, PushNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Update one PushNotification.
     * @param {PushNotificationUpdateArgs} args - Arguments to update one PushNotification.
     * @example
     * // Update one PushNotification
     * const pushNotification = await prisma.pushNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PushNotificationUpdateArgs>(
      args: SelectSubset<T, PushNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Delete zero or more PushNotifications.
     * @param {PushNotificationDeleteManyArgs} args - Arguments to filter PushNotifications to delete.
     * @example
     * // Delete a few PushNotifications
     * const { count } = await prisma.pushNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PushNotificationDeleteManyArgs>(
      args?: SelectSubset<T, PushNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushNotifications
     * const pushNotification = await prisma.pushNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PushNotificationUpdateManyArgs>(
      args: SelectSubset<T, PushNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PushNotification.
     * @param {PushNotificationUpsertArgs} args - Arguments to update or create a PushNotification.
     * @example
     * // Update or create a PushNotification
     * const pushNotification = await prisma.pushNotification.upsert({
     *   create: {
     *     // ... data to create a PushNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushNotification we want to update
     *   }
     * })
    **/
    upsert<T extends PushNotificationUpsertArgs>(
      args: SelectSubset<T, PushNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Find one PushNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PushNotificationFindUniqueOrThrowArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PushNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PushNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Find the first PushNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindFirstOrThrowArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PushNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PushNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Count the number of PushNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationCountArgs} args - Arguments to filter PushNotifications to count.
     * @example
     * // Count the number of PushNotifications
     * const count = await prisma.pushNotification.count({
     *   where: {
     *     // ... the filter for the PushNotifications we want to count
     *   }
     * })
    **/
    count<T extends PushNotificationCountArgs>(
      args?: Subset<T, PushNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushNotificationAggregateArgs>(args: Subset<T, PushNotificationAggregateArgs>): PrismaPromise<GetPushNotificationAggregateType<T>>

    /**
     * Group by PushNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushNotificationGroupByArgs['orderBy'] }
        : { orderBy?: PushNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PushNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PushNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PushNotification base type for findUnique actions
   */
  export type PushNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter, which PushNotification to fetch.
     * 
    **/
    where: PushNotificationWhereUniqueInput
  }

  /**
   * PushNotification: findUnique
   */
  export interface PushNotificationFindUniqueArgs extends PushNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PushNotification base type for findFirst actions
   */
  export type PushNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter, which PushNotification to fetch.
     * 
    **/
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<PushNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushNotifications.
     * 
    **/
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushNotifications.
     * 
    **/
    distinct?: Enumerable<PushNotificationScalarFieldEnum>
  }

  /**
   * PushNotification: findFirst
   */
  export interface PushNotificationFindFirstArgs extends PushNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PushNotification findMany
   */
  export type PushNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter, which PushNotifications to fetch.
     * 
    **/
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<PushNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushNotifications.
     * 
    **/
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PushNotificationScalarFieldEnum>
  }


  /**
   * PushNotification create
   */
  export type PushNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * The data needed to create a PushNotification.
     * 
    **/
    data: XOR<PushNotificationCreateInput, PushNotificationUncheckedCreateInput>
  }


  /**
   * PushNotification createMany
   */
  export type PushNotificationCreateManyArgs = {
    /**
     * The data used to create many PushNotifications.
     * 
    **/
    data: Enumerable<PushNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PushNotification update
   */
  export type PushNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * The data needed to update a PushNotification.
     * 
    **/
    data: XOR<PushNotificationUpdateInput, PushNotificationUncheckedUpdateInput>
    /**
     * Choose, which PushNotification to update.
     * 
    **/
    where: PushNotificationWhereUniqueInput
  }


  /**
   * PushNotification updateMany
   */
  export type PushNotificationUpdateManyArgs = {
    /**
     * The data used to update PushNotifications.
     * 
    **/
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyInput>
    /**
     * Filter which PushNotifications to update
     * 
    **/
    where?: PushNotificationWhereInput
  }


  /**
   * PushNotification upsert
   */
  export type PushNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * The filter to search for the PushNotification to update in case it exists.
     * 
    **/
    where: PushNotificationWhereUniqueInput
    /**
     * In case the PushNotification found by the `where` argument doesn't exist, create a new PushNotification with this data.
     * 
    **/
    create: XOR<PushNotificationCreateInput, PushNotificationUncheckedCreateInput>
    /**
     * In case the PushNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PushNotificationUpdateInput, PushNotificationUncheckedUpdateInput>
  }


  /**
   * PushNotification delete
   */
  export type PushNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter which PushNotification to delete.
     * 
    **/
    where: PushNotificationWhereUniqueInput
  }


  /**
   * PushNotification deleteMany
   */
  export type PushNotificationDeleteManyArgs = {
    /**
     * Filter which PushNotifications to delete
     * 
    **/
    where?: PushNotificationWhereInput
  }


  /**
   * PushNotification: findUniqueOrThrow
   */
  export type PushNotificationFindUniqueOrThrowArgs = PushNotificationFindUniqueArgsBase
      

  /**
   * PushNotification: findFirstOrThrow
   */
  export type PushNotificationFindFirstOrThrowArgs = PushNotificationFindFirstArgsBase
      

  /**
   * PushNotification without action
   */
  export type PushNotificationArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
  }



  /**
   * Model DeviceNotification
   */


  export type AggregateDeviceNotification = {
    _count: DeviceNotificationCountAggregateOutputType | null
    _min: DeviceNotificationMinAggregateOutputType | null
    _max: DeviceNotificationMaxAggregateOutputType | null
  }

  export type DeviceNotificationMinAggregateOutputType = {
    device_id: string | null
    notification_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceNotificationMaxAggregateOutputType = {
    device_id: string | null
    notification_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceNotificationCountAggregateOutputType = {
    device_id: number
    notification_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeviceNotificationMinAggregateInputType = {
    device_id?: true
    notification_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceNotificationMaxAggregateInputType = {
    device_id?: true
    notification_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceNotificationCountAggregateInputType = {
    device_id?: true
    notification_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeviceNotificationAggregateArgs = {
    /**
     * Filter which DeviceNotification to aggregate.
     * 
    **/
    where?: DeviceNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeviceNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceNotifications
    **/
    _count?: true | DeviceNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceNotificationMaxAggregateInputType
  }

  export type GetDeviceNotificationAggregateType<T extends DeviceNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceNotification[P]>
      : GetScalarType<T[P], AggregateDeviceNotification[P]>
  }




  export type DeviceNotificationGroupByArgs = {
    where?: DeviceNotificationWhereInput
    orderBy?: Enumerable<DeviceNotificationOrderByWithAggregationInput>
    by: Array<DeviceNotificationScalarFieldEnum>
    having?: DeviceNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceNotificationCountAggregateInputType | true
    _min?: DeviceNotificationMinAggregateInputType
    _max?: DeviceNotificationMaxAggregateInputType
  }


  export type DeviceNotificationGroupByOutputType = {
    device_id: string
    notification_id: string
    created_at: Date
    updated_at: Date
    _count: DeviceNotificationCountAggregateOutputType | null
    _min: DeviceNotificationMinAggregateOutputType | null
    _max: DeviceNotificationMaxAggregateOutputType | null
  }

  type GetDeviceNotificationGroupByPayload<T extends DeviceNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeviceNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceNotificationGroupByOutputType[P]>
        }
      >
    >


  export type DeviceNotificationSelect = {
    device_id?: boolean
    device?: boolean | DeviceArgs
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type DeviceNotificationInclude = {
    device?: boolean | DeviceArgs
    notification?: boolean | NotificationsArgs
  }

  export type DeviceNotificationGetPayload<
    S extends boolean | null | undefined | DeviceNotificationArgs,
    U = keyof S
      > = S extends true
        ? DeviceNotification
    : S extends undefined
    ? never
    : S extends DeviceNotificationArgs | DeviceNotificationFindManyArgs
    ?'include' extends U
    ? DeviceNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof DeviceNotification ? DeviceNotification[P] : never
  } 
    : DeviceNotification
  : DeviceNotification


  type DeviceNotificationCountArgs = Merge<
    Omit<DeviceNotificationFindManyArgs, 'select' | 'include'> & {
      select?: DeviceNotificationCountAggregateInputType | true
    }
  >

  export interface DeviceNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DeviceNotification that matches the filter.
     * @param {DeviceNotificationFindUniqueArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeviceNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeviceNotification'> extends True ? CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>> : CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification | null, null>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T> | null, null>>

    /**
     * Find the first DeviceNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationFindFirstArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeviceNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeviceNotification'> extends True ? CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>> : CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification | null, null>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more DeviceNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceNotifications
     * const deviceNotifications = await prisma.deviceNotification.findMany()
     * 
     * // Get first 10 DeviceNotifications
     * const deviceNotifications = await prisma.deviceNotification.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceNotificationWithDevice_idOnly = await prisma.deviceNotification.findMany({ select: { device_id: true } })
     * 
    **/
    findMany<T extends DeviceNotificationFindManyArgs>(
      args?: SelectSubset<T, DeviceNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DeviceNotification>>, PrismaPromise<Array<DeviceNotificationGetPayload<T>>>>

    /**
     * Create a DeviceNotification.
     * @param {DeviceNotificationCreateArgs} args - Arguments to create a DeviceNotification.
     * @example
     * // Create one DeviceNotification
     * const DeviceNotification = await prisma.deviceNotification.create({
     *   data: {
     *     // ... data to create a DeviceNotification
     *   }
     * })
     * 
    **/
    create<T extends DeviceNotificationCreateArgs>(
      args: SelectSubset<T, DeviceNotificationCreateArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Create many DeviceNotifications.
     *     @param {DeviceNotificationCreateManyArgs} args - Arguments to create many DeviceNotifications.
     *     @example
     *     // Create many DeviceNotifications
     *     const deviceNotification = await prisma.deviceNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeviceNotificationCreateManyArgs>(
      args?: SelectSubset<T, DeviceNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceNotification.
     * @param {DeviceNotificationDeleteArgs} args - Arguments to delete one DeviceNotification.
     * @example
     * // Delete one DeviceNotification
     * const DeviceNotification = await prisma.deviceNotification.delete({
     *   where: {
     *     // ... filter to delete one DeviceNotification
     *   }
     * })
     * 
    **/
    delete<T extends DeviceNotificationDeleteArgs>(
      args: SelectSubset<T, DeviceNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Update one DeviceNotification.
     * @param {DeviceNotificationUpdateArgs} args - Arguments to update one DeviceNotification.
     * @example
     * // Update one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceNotificationUpdateArgs>(
      args: SelectSubset<T, DeviceNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Delete zero or more DeviceNotifications.
     * @param {DeviceNotificationDeleteManyArgs} args - Arguments to filter DeviceNotifications to delete.
     * @example
     * // Delete a few DeviceNotifications
     * const { count } = await prisma.deviceNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceNotificationDeleteManyArgs>(
      args?: SelectSubset<T, DeviceNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceNotifications
     * const deviceNotification = await prisma.deviceNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceNotificationUpdateManyArgs>(
      args: SelectSubset<T, DeviceNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceNotification.
     * @param {DeviceNotificationUpsertArgs} args - Arguments to update or create a DeviceNotification.
     * @example
     * // Update or create a DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.upsert({
     *   create: {
     *     // ... data to create a DeviceNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceNotification we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceNotificationUpsertArgs>(
      args: SelectSubset<T, DeviceNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Find one DeviceNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeviceNotificationFindUniqueOrThrowArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeviceNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Find the first DeviceNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationFindFirstOrThrowArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeviceNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Count the number of DeviceNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationCountArgs} args - Arguments to filter DeviceNotifications to count.
     * @example
     * // Count the number of DeviceNotifications
     * const count = await prisma.deviceNotification.count({
     *   where: {
     *     // ... the filter for the DeviceNotifications we want to count
     *   }
     * })
    **/
    count<T extends DeviceNotificationCountArgs>(
      args?: Subset<T, DeviceNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceNotificationAggregateArgs>(args: Subset<T, DeviceNotificationAggregateArgs>): PrismaPromise<GetDeviceNotificationAggregateType<T>>

    /**
     * Group by DeviceNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceNotificationGroupByArgs['orderBy'] }
        : { orderBy?: DeviceNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeviceNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeviceNotification base type for findUnique actions
   */
  export type DeviceNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter, which DeviceNotification to fetch.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
  }

  /**
   * DeviceNotification: findUnique
   */
  export interface DeviceNotificationFindUniqueArgs extends DeviceNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceNotification base type for findFirst actions
   */
  export type DeviceNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter, which DeviceNotification to fetch.
     * 
    **/
    where?: DeviceNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceNotifications.
     * 
    **/
    cursor?: DeviceNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceNotifications.
     * 
    **/
    distinct?: Enumerable<DeviceNotificationScalarFieldEnum>
  }

  /**
   * DeviceNotification: findFirst
   */
  export interface DeviceNotificationFindFirstArgs extends DeviceNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceNotification findMany
   */
  export type DeviceNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter, which DeviceNotifications to fetch.
     * 
    **/
    where?: DeviceNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceNotifications.
     * 
    **/
    cursor?: DeviceNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeviceNotificationScalarFieldEnum>
  }


  /**
   * DeviceNotification create
   */
  export type DeviceNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * The data needed to create a DeviceNotification.
     * 
    **/
    data: XOR<DeviceNotificationCreateInput, DeviceNotificationUncheckedCreateInput>
  }


  /**
   * DeviceNotification createMany
   */
  export type DeviceNotificationCreateManyArgs = {
    /**
     * The data used to create many DeviceNotifications.
     * 
    **/
    data: Enumerable<DeviceNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeviceNotification update
   */
  export type DeviceNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * The data needed to update a DeviceNotification.
     * 
    **/
    data: XOR<DeviceNotificationUpdateInput, DeviceNotificationUncheckedUpdateInput>
    /**
     * Choose, which DeviceNotification to update.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
  }


  /**
   * DeviceNotification updateMany
   */
  export type DeviceNotificationUpdateManyArgs = {
    /**
     * The data used to update DeviceNotifications.
     * 
    **/
    data: XOR<DeviceNotificationUpdateManyMutationInput, DeviceNotificationUncheckedUpdateManyInput>
    /**
     * Filter which DeviceNotifications to update
     * 
    **/
    where?: DeviceNotificationWhereInput
  }


  /**
   * DeviceNotification upsert
   */
  export type DeviceNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * The filter to search for the DeviceNotification to update in case it exists.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
    /**
     * In case the DeviceNotification found by the `where` argument doesn't exist, create a new DeviceNotification with this data.
     * 
    **/
    create: XOR<DeviceNotificationCreateInput, DeviceNotificationUncheckedCreateInput>
    /**
     * In case the DeviceNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeviceNotificationUpdateInput, DeviceNotificationUncheckedUpdateInput>
  }


  /**
   * DeviceNotification delete
   */
  export type DeviceNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter which DeviceNotification to delete.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
  }


  /**
   * DeviceNotification deleteMany
   */
  export type DeviceNotificationDeleteManyArgs = {
    /**
     * Filter which DeviceNotifications to delete
     * 
    **/
    where?: DeviceNotificationWhereInput
  }


  /**
   * DeviceNotification: findUniqueOrThrow
   */
  export type DeviceNotificationFindUniqueOrThrowArgs = DeviceNotificationFindUniqueArgsBase
      

  /**
   * DeviceNotification: findFirstOrThrow
   */
  export type DeviceNotificationFindFirstOrThrowArgs = DeviceNotificationFindFirstArgsBase
      

  /**
   * DeviceNotification without action
   */
  export type DeviceNotificationArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
  }



  /**
   * Model Plan
   */


  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
    max_users: number | null
    max_labels: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
    max_users: number | null
    max_labels: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    price: number | null
    max_users: number | null
    max_labels: number | null
    payment_cycle_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    price: number | null
    max_users: number | null
    max_labels: number | null
    payment_cycle_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
    max_users?: true
    max_labels?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
    max_users?: true
    max_labels?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    price?: true
    max_users?: true
    max_labels?: true
    payment_cycle_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    price?: true
    max_users?: true
    max_labels?: true
    payment_cycle_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    price?: true
    max_users?: true
    max_labels?: true
    payment_cycle_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PlanAggregateArgs = {
    /**
     * Filter which Plan to aggregate.
     * 
    **/
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     * 
    **/
    orderBy?: Enumerable<PlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs = {
    where?: PlanWhereInput
    orderBy?: Enumerable<PlanOrderByWithAggregationInput>
    by: Array<PlanScalarFieldEnum>
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }


  export type PlanGroupByOutputType = {
    id: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    created_at: Date
    updated_at: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    price?: boolean
    max_users?: boolean
    max_labels?: boolean
    payment_cycle_id?: boolean
    payment_cycle?: boolean | PaymentCycleArgs
    account?: boolean | AccountFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    subscription?: boolean | SubscriptionFindManyArgs
    _count?: boolean | PlanCountOutputTypeArgs
  }

  export type PlanInclude = {
    payment_cycle?: boolean | PaymentCycleArgs
    account?: boolean | AccountFindManyArgs
    subscription?: boolean | SubscriptionFindManyArgs
    _count?: boolean | PlanCountOutputTypeArgs
  }

  export type PlanGetPayload<
    S extends boolean | null | undefined | PlanArgs,
    U = keyof S
      > = S extends true
        ? Plan
    : S extends undefined
    ? never
    : S extends PlanArgs | PlanFindManyArgs
    ?'include' extends U
    ? Plan  & {
    [P in TrueKeys<S['include']>]:
        P extends 'payment_cycle' ? PaymentCycleGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? Array < AccountGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PlanCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'payment_cycle' ? PaymentCycleGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? Array < AccountGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PlanCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Plan ? Plan[P] : never
  } 
    : Plan
  : Plan


  type PlanCountArgs = Merge<
    Omit<PlanFindManyArgs, 'select' | 'include'> & {
      select?: PlanCountAggregateInputType | true
    }
  >

  export interface PlanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Plan'> extends True ? CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>> : CheckSelect<T, Prisma__PlanClient<Plan | null, null>, Prisma__PlanClient<PlanGetPayload<T> | null, null>>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Plan'> extends True ? CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>> : CheckSelect<T, Prisma__PlanClient<Plan | null, null>, Prisma__PlanClient<PlanGetPayload<T> | null, null>>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlanFindManyArgs>(
      args?: SelectSubset<T, PlanFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Plan>>, PrismaPromise<Array<PlanGetPayload<T>>>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
    **/
    create<T extends PlanCreateArgs>(
      args: SelectSubset<T, PlanCreateArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Create many Plans.
     *     @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     *     @example
     *     // Create many Plans
     *     const plan = await prisma.plan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlanCreateManyArgs>(
      args?: SelectSubset<T, PlanCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
    **/
    delete<T extends PlanDeleteArgs>(
      args: SelectSubset<T, PlanDeleteArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlanUpdateArgs>(
      args: SelectSubset<T, PlanUpdateArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlanDeleteManyArgs>(
      args?: SelectSubset<T, PlanDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlanUpdateManyArgs>(
      args: SelectSubset<T, PlanUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
    **/
    upsert<T extends PlanUpsertArgs>(
      args: SelectSubset<T, PlanUpsertArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Find one Plan that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PlanFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Find the first Plan that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PlanFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlanClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    payment_cycle<T extends PaymentCycleArgs = {}>(args?: Subset<T, PaymentCycleArgs>): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle | Null>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T> | Null>>;

    account<T extends AccountFindManyArgs = {}>(args?: Subset<T, AccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Account>| Null>, PrismaPromise<Array<AccountGetPayload<T>>| Null>>;

    subscription<T extends SubscriptionFindManyArgs = {}>(args?: Subset<T, SubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscription>| Null>, PrismaPromise<Array<SubscriptionGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Plan base type for findUnique actions
   */
  export type PlanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter, which Plan to fetch.
     * 
    **/
    where: PlanWhereUniqueInput
  }

  /**
   * Plan: findUnique
   */
  export interface PlanFindUniqueArgs extends PlanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Plan base type for findFirst actions
   */
  export type PlanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter, which Plan to fetch.
     * 
    **/
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     * 
    **/
    orderBy?: Enumerable<PlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     * 
    **/
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     * 
    **/
    distinct?: Enumerable<PlanScalarFieldEnum>
  }

  /**
   * Plan: findFirst
   */
  export interface PlanFindFirstArgs extends PlanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter, which Plans to fetch.
     * 
    **/
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     * 
    **/
    orderBy?: Enumerable<PlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     * 
    **/
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlanScalarFieldEnum>
  }


  /**
   * Plan create
   */
  export type PlanCreateArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * The data needed to create a Plan.
     * 
    **/
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }


  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs = {
    /**
     * The data used to create many Plans.
     * 
    **/
    data: Enumerable<PlanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Plan update
   */
  export type PlanUpdateArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * The data needed to update a Plan.
     * 
    **/
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     * 
    **/
    where: PlanWhereUniqueInput
  }


  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs = {
    /**
     * The data used to update Plans.
     * 
    **/
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     * 
    **/
    where?: PlanWhereInput
  }


  /**
   * Plan upsert
   */
  export type PlanUpsertArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * The filter to search for the Plan to update in case it exists.
     * 
    **/
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     * 
    **/
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }


  /**
   * Plan delete
   */
  export type PlanDeleteArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter which Plan to delete.
     * 
    **/
    where: PlanWhereUniqueInput
  }


  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs = {
    /**
     * Filter which Plans to delete
     * 
    **/
    where?: PlanWhereInput
  }


  /**
   * Plan: findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs = PlanFindUniqueArgsBase
      

  /**
   * Plan: findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs = PlanFindFirstArgsBase
      

  /**
   * Plan without action
   */
  export type PlanArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
  }



  /**
   * Model PaymentCycle
   */


  export type AggregatePaymentCycle = {
    _count: PaymentCycleCountAggregateOutputType | null
    _min: PaymentCycleMinAggregateOutputType | null
    _max: PaymentCycleMaxAggregateOutputType | null
  }

  export type PaymentCycleMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentCycleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentCycleCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentCycleMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentCycleMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentCycleCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentCycleAggregateArgs = {
    /**
     * Filter which PaymentCycle to aggregate.
     * 
    **/
    where?: PaymentCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCycles to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentCycleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCycles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCycles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentCycles
    **/
    _count?: true | PaymentCycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentCycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentCycleMaxAggregateInputType
  }

  export type GetPaymentCycleAggregateType<T extends PaymentCycleAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentCycle[P]>
      : GetScalarType<T[P], AggregatePaymentCycle[P]>
  }




  export type PaymentCycleGroupByArgs = {
    where?: PaymentCycleWhereInput
    orderBy?: Enumerable<PaymentCycleOrderByWithAggregationInput>
    by: Array<PaymentCycleScalarFieldEnum>
    having?: PaymentCycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCycleCountAggregateInputType | true
    _min?: PaymentCycleMinAggregateInputType
    _max?: PaymentCycleMaxAggregateInputType
  }


  export type PaymentCycleGroupByOutputType = {
    id: string
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: PaymentCycleCountAggregateOutputType | null
    _min: PaymentCycleMinAggregateOutputType | null
    _max: PaymentCycleMaxAggregateOutputType | null
  }

  type GetPaymentCycleGroupByPayload<T extends PaymentCycleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentCycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentCycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentCycleGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentCycleGroupByOutputType[P]>
        }
      >
    >


  export type PaymentCycleSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    plans?: boolean | PlanFindManyArgs
    _count?: boolean | PaymentCycleCountOutputTypeArgs
  }

  export type PaymentCycleInclude = {
    plans?: boolean | PlanFindManyArgs
    _count?: boolean | PaymentCycleCountOutputTypeArgs
  }

  export type PaymentCycleGetPayload<
    S extends boolean | null | undefined | PaymentCycleArgs,
    U = keyof S
      > = S extends true
        ? PaymentCycle
    : S extends undefined
    ? never
    : S extends PaymentCycleArgs | PaymentCycleFindManyArgs
    ?'include' extends U
    ? PaymentCycle  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plans' ? Array < PlanGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PaymentCycleCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plans' ? Array < PlanGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PaymentCycleCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof PaymentCycle ? PaymentCycle[P] : never
  } 
    : PaymentCycle
  : PaymentCycle


  type PaymentCycleCountArgs = Merge<
    Omit<PaymentCycleFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCycleCountAggregateInputType | true
    }
  >

  export interface PaymentCycleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PaymentCycle that matches the filter.
     * @param {PaymentCycleFindUniqueArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentCycleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentCycleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentCycle'> extends True ? CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>> : CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle | null, null>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T> | null, null>>

    /**
     * Find the first PaymentCycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleFindFirstArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentCycleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentCycleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentCycle'> extends True ? CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>> : CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle | null, null>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T> | null, null>>

    /**
     * Find zero or more PaymentCycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentCycles
     * const paymentCycles = await prisma.paymentCycle.findMany()
     * 
     * // Get first 10 PaymentCycles
     * const paymentCycles = await prisma.paymentCycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentCycleWithIdOnly = await prisma.paymentCycle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentCycleFindManyArgs>(
      args?: SelectSubset<T, PaymentCycleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PaymentCycle>>, PrismaPromise<Array<PaymentCycleGetPayload<T>>>>

    /**
     * Create a PaymentCycle.
     * @param {PaymentCycleCreateArgs} args - Arguments to create a PaymentCycle.
     * @example
     * // Create one PaymentCycle
     * const PaymentCycle = await prisma.paymentCycle.create({
     *   data: {
     *     // ... data to create a PaymentCycle
     *   }
     * })
     * 
    **/
    create<T extends PaymentCycleCreateArgs>(
      args: SelectSubset<T, PaymentCycleCreateArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Create many PaymentCycles.
     *     @param {PaymentCycleCreateManyArgs} args - Arguments to create many PaymentCycles.
     *     @example
     *     // Create many PaymentCycles
     *     const paymentCycle = await prisma.paymentCycle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCycleCreateManyArgs>(
      args?: SelectSubset<T, PaymentCycleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentCycle.
     * @param {PaymentCycleDeleteArgs} args - Arguments to delete one PaymentCycle.
     * @example
     * // Delete one PaymentCycle
     * const PaymentCycle = await prisma.paymentCycle.delete({
     *   where: {
     *     // ... filter to delete one PaymentCycle
     *   }
     * })
     * 
    **/
    delete<T extends PaymentCycleDeleteArgs>(
      args: SelectSubset<T, PaymentCycleDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Update one PaymentCycle.
     * @param {PaymentCycleUpdateArgs} args - Arguments to update one PaymentCycle.
     * @example
     * // Update one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentCycleUpdateArgs>(
      args: SelectSubset<T, PaymentCycleUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Delete zero or more PaymentCycles.
     * @param {PaymentCycleDeleteManyArgs} args - Arguments to filter PaymentCycles to delete.
     * @example
     * // Delete a few PaymentCycles
     * const { count } = await prisma.paymentCycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentCycleDeleteManyArgs>(
      args?: SelectSubset<T, PaymentCycleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentCycles
     * const paymentCycle = await prisma.paymentCycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentCycleUpdateManyArgs>(
      args: SelectSubset<T, PaymentCycleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentCycle.
     * @param {PaymentCycleUpsertArgs} args - Arguments to update or create a PaymentCycle.
     * @example
     * // Update or create a PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.upsert({
     *   create: {
     *     // ... data to create a PaymentCycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentCycle we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentCycleUpsertArgs>(
      args: SelectSubset<T, PaymentCycleUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Find one PaymentCycle that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PaymentCycleFindUniqueOrThrowArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentCycleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PaymentCycleFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Find the first PaymentCycle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleFindFirstOrThrowArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentCycleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentCycleFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Count the number of PaymentCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleCountArgs} args - Arguments to filter PaymentCycles to count.
     * @example
     * // Count the number of PaymentCycles
     * const count = await prisma.paymentCycle.count({
     *   where: {
     *     // ... the filter for the PaymentCycles we want to count
     *   }
     * })
    **/
    count<T extends PaymentCycleCountArgs>(
      args?: Subset<T, PaymentCycleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentCycleAggregateArgs>(args: Subset<T, PaymentCycleAggregateArgs>): PrismaPromise<GetPaymentCycleAggregateType<T>>

    /**
     * Group by PaymentCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentCycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentCycleGroupByArgs['orderBy'] }
        : { orderBy?: PaymentCycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentCycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentCycleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentCycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentCycleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plans<T extends PlanFindManyArgs = {}>(args?: Subset<T, PlanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Plan>| Null>, PrismaPromise<Array<PlanGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PaymentCycle base type for findUnique actions
   */
  export type PaymentCycleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter, which PaymentCycle to fetch.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
  }

  /**
   * PaymentCycle: findUnique
   */
  export interface PaymentCycleFindUniqueArgs extends PaymentCycleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentCycle base type for findFirst actions
   */
  export type PaymentCycleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter, which PaymentCycle to fetch.
     * 
    **/
    where?: PaymentCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCycles to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentCycleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentCycles.
     * 
    **/
    cursor?: PaymentCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCycles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCycles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentCycles.
     * 
    **/
    distinct?: Enumerable<PaymentCycleScalarFieldEnum>
  }

  /**
   * PaymentCycle: findFirst
   */
  export interface PaymentCycleFindFirstArgs extends PaymentCycleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentCycle findMany
   */
  export type PaymentCycleFindManyArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter, which PaymentCycles to fetch.
     * 
    **/
    where?: PaymentCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCycles to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentCycleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentCycles.
     * 
    **/
    cursor?: PaymentCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCycles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCycles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentCycleScalarFieldEnum>
  }


  /**
   * PaymentCycle create
   */
  export type PaymentCycleCreateArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * The data needed to create a PaymentCycle.
     * 
    **/
    data: XOR<PaymentCycleCreateInput, PaymentCycleUncheckedCreateInput>
  }


  /**
   * PaymentCycle createMany
   */
  export type PaymentCycleCreateManyArgs = {
    /**
     * The data used to create many PaymentCycles.
     * 
    **/
    data: Enumerable<PaymentCycleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PaymentCycle update
   */
  export type PaymentCycleUpdateArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * The data needed to update a PaymentCycle.
     * 
    **/
    data: XOR<PaymentCycleUpdateInput, PaymentCycleUncheckedUpdateInput>
    /**
     * Choose, which PaymentCycle to update.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
  }


  /**
   * PaymentCycle updateMany
   */
  export type PaymentCycleUpdateManyArgs = {
    /**
     * The data used to update PaymentCycles.
     * 
    **/
    data: XOR<PaymentCycleUpdateManyMutationInput, PaymentCycleUncheckedUpdateManyInput>
    /**
     * Filter which PaymentCycles to update
     * 
    **/
    where?: PaymentCycleWhereInput
  }


  /**
   * PaymentCycle upsert
   */
  export type PaymentCycleUpsertArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * The filter to search for the PaymentCycle to update in case it exists.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
    /**
     * In case the PaymentCycle found by the `where` argument doesn't exist, create a new PaymentCycle with this data.
     * 
    **/
    create: XOR<PaymentCycleCreateInput, PaymentCycleUncheckedCreateInput>
    /**
     * In case the PaymentCycle was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentCycleUpdateInput, PaymentCycleUncheckedUpdateInput>
  }


  /**
   * PaymentCycle delete
   */
  export type PaymentCycleDeleteArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter which PaymentCycle to delete.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
  }


  /**
   * PaymentCycle deleteMany
   */
  export type PaymentCycleDeleteManyArgs = {
    /**
     * Filter which PaymentCycles to delete
     * 
    **/
    where?: PaymentCycleWhereInput
  }


  /**
   * PaymentCycle: findUniqueOrThrow
   */
  export type PaymentCycleFindUniqueOrThrowArgs = PaymentCycleFindUniqueArgsBase
      

  /**
   * PaymentCycle: findFirstOrThrow
   */
  export type PaymentCycleFindFirstOrThrowArgs = PaymentCycleFindFirstArgsBase
      

  /**
   * PaymentCycle without action
   */
  export type PaymentCycleArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    plan_id: string | null
    account_id: string | null
    due: Date | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    plan_id: string | null
    account_id: string | null
    due: Date | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    plan_id: number
    account_id: number
    due: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    price?: true
  }

  export type SubscriptionSumAggregateInputType = {
    price?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    plan_id?: true
    account_id?: true
    due?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    plan_id?: true
    account_id?: true
    due?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    plan_id?: true
    account_id?: true
    due?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs = {
    /**
     * Filter which Subscription to aggregate.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs = {
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithAggregationInput>
    by: Array<SubscriptionScalarFieldEnum>
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: string
    plan_id: string
    account_id: string
    due: Date
    price: number
    created_at: Date
    updated_at: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect = {
    id?: boolean
    plan_id?: boolean
    plan?: boolean | PlanArgs
    account_id?: boolean
    account?: boolean | AccountArgs
    due?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubscriptionInclude = {
    plan?: boolean | PlanArgs
    account?: boolean | AccountArgs
  }

  export type SubscriptionGetPayload<
    S extends boolean | null | undefined | SubscriptionArgs,
    U = keyof S
      > = S extends true
        ? Subscription
    : S extends undefined
    ? never
    : S extends SubscriptionArgs | SubscriptionFindManyArgs
    ?'include' extends U
    ? Subscription  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plan' ? PlanGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plan' ? PlanGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Subscription ? Subscription[P] : never
  } 
    : Subscription
  : Subscription


  type SubscriptionCountArgs = Merge<
    Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }
  >

  export interface SubscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null, null>, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null, null>, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs>(
      args?: SelectSubset<T, SubscriptionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Subscription>>, PrismaPromise<Array<SubscriptionGetPayload<T>>>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs>(
      args: SelectSubset<T, SubscriptionCreateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs>(
      args: SelectSubset<T, SubscriptionDeleteArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs>(
      args: SelectSubset<T, SubscriptionUpdateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs>(
      args: SelectSubset<T, SubscriptionUpsertArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Find one Subscription that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Find the first Subscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plan<T extends PlanArgs = {}>(args?: Subset<T, PlanArgs>): CheckSelect<T, Prisma__PlanClient<Plan | Null>, Prisma__PlanClient<PlanGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subscription base type for findUnique actions
   */
  export type SubscriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription: findUnique
   */
  export interface SubscriptionFindUniqueArgs extends SubscriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription base type for findFirst actions
   */
  export type SubscriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     * 
    **/
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }

  /**
   * Subscription: findFirst
   */
  export interface SubscriptionFindFirstArgs extends SubscriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The data needed to create a Subscription.
     * 
    **/
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs = {
    /**
     * The data used to create many Subscriptions.
     * 
    **/
    data: Enumerable<SubscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The data needed to update a Subscription.
     * 
    **/
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs = {
    /**
     * The data used to update Subscriptions.
     * 
    **/
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     * 
    **/
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     * 
    **/
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     * 
    **/
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter which Subscription to delete.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs = {
    /**
     * Filter which Subscriptions to delete
     * 
    **/
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription: findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs = SubscriptionFindUniqueArgsBase
      

  /**
   * Subscription: findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs = SubscriptionFindFirstArgsBase
      

  /**
   * Subscription without action
   */
  export type SubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
  }



  /**
   * Model StockLabel
   */


  export type AggregateStockLabel = {
    _count: StockLabelCountAggregateOutputType | null
    _avg: StockLabelAvgAggregateOutputType | null
    _sum: StockLabelSumAggregateOutputType | null
    _min: StockLabelMinAggregateOutputType | null
    _max: StockLabelMaxAggregateOutputType | null
  }

  export type StockLabelAvgAggregateOutputType = {
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockLabelSumAggregateOutputType = {
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockLabelMinAggregateOutputType = {
    label_id: string | null
    account_id: string | null
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockLabelMaxAggregateOutputType = {
    label_id: string | null
    account_id: string | null
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockLabelCountAggregateOutputType = {
    label_id: number
    account_id: number
    min_quantity: number
    max_quantity: number
    _all: number
  }


  export type StockLabelAvgAggregateInputType = {
    min_quantity?: true
    max_quantity?: true
  }

  export type StockLabelSumAggregateInputType = {
    min_quantity?: true
    max_quantity?: true
  }

  export type StockLabelMinAggregateInputType = {
    label_id?: true
    account_id?: true
    min_quantity?: true
    max_quantity?: true
  }

  export type StockLabelMaxAggregateInputType = {
    label_id?: true
    account_id?: true
    min_quantity?: true
    max_quantity?: true
  }

  export type StockLabelCountAggregateInputType = {
    label_id?: true
    account_id?: true
    min_quantity?: true
    max_quantity?: true
    _all?: true
  }

  export type StockLabelAggregateArgs = {
    /**
     * Filter which StockLabel to aggregate.
     * 
    **/
    where?: StockLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLabels to fetch.
     * 
    **/
    orderBy?: Enumerable<StockLabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StockLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLabels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLabels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockLabels
    **/
    _count?: true | StockLabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockLabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockLabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockLabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockLabelMaxAggregateInputType
  }

  export type GetStockLabelAggregateType<T extends StockLabelAggregateArgs> = {
        [P in keyof T & keyof AggregateStockLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockLabel[P]>
      : GetScalarType<T[P], AggregateStockLabel[P]>
  }




  export type StockLabelGroupByArgs = {
    where?: StockLabelWhereInput
    orderBy?: Enumerable<StockLabelOrderByWithAggregationInput>
    by: Array<StockLabelScalarFieldEnum>
    having?: StockLabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockLabelCountAggregateInputType | true
    _avg?: StockLabelAvgAggregateInputType
    _sum?: StockLabelSumAggregateInputType
    _min?: StockLabelMinAggregateInputType
    _max?: StockLabelMaxAggregateInputType
  }


  export type StockLabelGroupByOutputType = {
    label_id: string
    account_id: string
    min_quantity: number
    max_quantity: number
    _count: StockLabelCountAggregateOutputType | null
    _avg: StockLabelAvgAggregateOutputType | null
    _sum: StockLabelSumAggregateOutputType | null
    _min: StockLabelMinAggregateOutputType | null
    _max: StockLabelMaxAggregateOutputType | null
  }

  type GetStockLabelGroupByPayload<T extends StockLabelGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StockLabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockLabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockLabelGroupByOutputType[P]>
            : GetScalarType<T[P], StockLabelGroupByOutputType[P]>
        }
      >
    >


  export type StockLabelSelect = {
    label_id?: boolean
    labels?: boolean | LabelArgs
    account_id?: boolean
    account?: boolean | AccountArgs
    min_quantity?: boolean
    max_quantity?: boolean
  }

  export type StockLabelInclude = {
    labels?: boolean | LabelArgs
    account?: boolean | AccountArgs
  }

  export type StockLabelGetPayload<
    S extends boolean | null | undefined | StockLabelArgs,
    U = keyof S
      > = S extends true
        ? StockLabel
    : S extends undefined
    ? never
    : S extends StockLabelArgs | StockLabelFindManyArgs
    ?'include' extends U
    ? StockLabel  & {
    [P in TrueKeys<S['include']>]:
        P extends 'labels' ? LabelGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'labels' ? LabelGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof StockLabel ? StockLabel[P] : never
  } 
    : StockLabel
  : StockLabel


  type StockLabelCountArgs = Merge<
    Omit<StockLabelFindManyArgs, 'select' | 'include'> & {
      select?: StockLabelCountAggregateInputType | true
    }
  >

  export interface StockLabelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StockLabel that matches the filter.
     * @param {StockLabelFindUniqueArgs} args - Arguments to find a StockLabel
     * @example
     * // Get one StockLabel
     * const stockLabel = await prisma.stockLabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockLabelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StockLabelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StockLabel'> extends True ? CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>> : CheckSelect<T, Prisma__StockLabelClient<StockLabel | null, null>, Prisma__StockLabelClient<StockLabelGetPayload<T> | null, null>>

    /**
     * Find the first StockLabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLabelFindFirstArgs} args - Arguments to find a StockLabel
     * @example
     * // Get one StockLabel
     * const stockLabel = await prisma.stockLabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockLabelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StockLabelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StockLabel'> extends True ? CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>> : CheckSelect<T, Prisma__StockLabelClient<StockLabel | null, null>, Prisma__StockLabelClient<StockLabelGetPayload<T> | null, null>>

    /**
     * Find zero or more StockLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLabelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockLabels
     * const stockLabels = await prisma.stockLabel.findMany()
     * 
     * // Get first 10 StockLabels
     * const stockLabels = await prisma.stockLabel.findMany({ take: 10 })
     * 
     * // Only select the `label_id`
     * const stockLabelWithLabel_idOnly = await prisma.stockLabel.findMany({ select: { label_id: true } })
     * 
    **/
    findMany<T extends StockLabelFindManyArgs>(
      args?: SelectSubset<T, StockLabelFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StockLabel>>, PrismaPromise<Array<StockLabelGetPayload<T>>>>

    /**
     * Create a StockLabel.
     * @param {StockLabelCreateArgs} args - Arguments to create a StockLabel.
     * @example
     * // Create one StockLabel
     * const StockLabel = await prisma.stockLabel.create({
     *   data: {
     *     // ... data to create a StockLabel
     *   }
     * })
     * 
    **/
    create<T extends StockLabelCreateArgs>(
      args: SelectSubset<T, StockLabelCreateArgs>
    ): CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>>

    /**
     * Create many StockLabels.
     *     @param {StockLabelCreateManyArgs} args - Arguments to create many StockLabels.
     *     @example
     *     // Create many StockLabels
     *     const stockLabel = await prisma.stockLabel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockLabelCreateManyArgs>(
      args?: SelectSubset<T, StockLabelCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StockLabel.
     * @param {StockLabelDeleteArgs} args - Arguments to delete one StockLabel.
     * @example
     * // Delete one StockLabel
     * const StockLabel = await prisma.stockLabel.delete({
     *   where: {
     *     // ... filter to delete one StockLabel
     *   }
     * })
     * 
    **/
    delete<T extends StockLabelDeleteArgs>(
      args: SelectSubset<T, StockLabelDeleteArgs>
    ): CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>>

    /**
     * Update one StockLabel.
     * @param {StockLabelUpdateArgs} args - Arguments to update one StockLabel.
     * @example
     * // Update one StockLabel
     * const stockLabel = await prisma.stockLabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockLabelUpdateArgs>(
      args: SelectSubset<T, StockLabelUpdateArgs>
    ): CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>>

    /**
     * Delete zero or more StockLabels.
     * @param {StockLabelDeleteManyArgs} args - Arguments to filter StockLabels to delete.
     * @example
     * // Delete a few StockLabels
     * const { count } = await prisma.stockLabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockLabelDeleteManyArgs>(
      args?: SelectSubset<T, StockLabelDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockLabels
     * const stockLabel = await prisma.stockLabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockLabelUpdateManyArgs>(
      args: SelectSubset<T, StockLabelUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StockLabel.
     * @param {StockLabelUpsertArgs} args - Arguments to update or create a StockLabel.
     * @example
     * // Update or create a StockLabel
     * const stockLabel = await prisma.stockLabel.upsert({
     *   create: {
     *     // ... data to create a StockLabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockLabel we want to update
     *   }
     * })
    **/
    upsert<T extends StockLabelUpsertArgs>(
      args: SelectSubset<T, StockLabelUpsertArgs>
    ): CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>>

    /**
     * Find one StockLabel that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StockLabelFindUniqueOrThrowArgs} args - Arguments to find a StockLabel
     * @example
     * // Get one StockLabel
     * const stockLabel = await prisma.stockLabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockLabelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StockLabelFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>>

    /**
     * Find the first StockLabel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLabelFindFirstOrThrowArgs} args - Arguments to find a StockLabel
     * @example
     * // Get one StockLabel
     * const stockLabel = await prisma.stockLabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockLabelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StockLabelFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StockLabelClient<StockLabel>, Prisma__StockLabelClient<StockLabelGetPayload<T>>>

    /**
     * Count the number of StockLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLabelCountArgs} args - Arguments to filter StockLabels to count.
     * @example
     * // Count the number of StockLabels
     * const count = await prisma.stockLabel.count({
     *   where: {
     *     // ... the filter for the StockLabels we want to count
     *   }
     * })
    **/
    count<T extends StockLabelCountArgs>(
      args?: Subset<T, StockLabelCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockLabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockLabelAggregateArgs>(args: Subset<T, StockLabelAggregateArgs>): PrismaPromise<GetStockLabelAggregateType<T>>

    /**
     * Group by StockLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockLabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockLabelGroupByArgs['orderBy'] }
        : { orderBy?: StockLabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockLabelGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StockLabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StockLabelClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    labels<T extends LabelArgs = {}>(args?: Subset<T, LabelArgs>): CheckSelect<T, Prisma__LabelClient<Label | Null>, Prisma__LabelClient<LabelGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StockLabel base type for findUnique actions
   */
  export type StockLabelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
    /**
     * Filter, which StockLabel to fetch.
     * 
    **/
    where: StockLabelWhereUniqueInput
  }

  /**
   * StockLabel: findUnique
   */
  export interface StockLabelFindUniqueArgs extends StockLabelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockLabel base type for findFirst actions
   */
  export type StockLabelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
    /**
     * Filter, which StockLabel to fetch.
     * 
    **/
    where?: StockLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLabels to fetch.
     * 
    **/
    orderBy?: Enumerable<StockLabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLabels.
     * 
    **/
    cursor?: StockLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLabels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLabels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLabels.
     * 
    **/
    distinct?: Enumerable<StockLabelScalarFieldEnum>
  }

  /**
   * StockLabel: findFirst
   */
  export interface StockLabelFindFirstArgs extends StockLabelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockLabel findMany
   */
  export type StockLabelFindManyArgs = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
    /**
     * Filter, which StockLabels to fetch.
     * 
    **/
    where?: StockLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLabels to fetch.
     * 
    **/
    orderBy?: Enumerable<StockLabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockLabels.
     * 
    **/
    cursor?: StockLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLabels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLabels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StockLabelScalarFieldEnum>
  }


  /**
   * StockLabel create
   */
  export type StockLabelCreateArgs = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
    /**
     * The data needed to create a StockLabel.
     * 
    **/
    data: XOR<StockLabelCreateInput, StockLabelUncheckedCreateInput>
  }


  /**
   * StockLabel createMany
   */
  export type StockLabelCreateManyArgs = {
    /**
     * The data used to create many StockLabels.
     * 
    **/
    data: Enumerable<StockLabelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StockLabel update
   */
  export type StockLabelUpdateArgs = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
    /**
     * The data needed to update a StockLabel.
     * 
    **/
    data: XOR<StockLabelUpdateInput, StockLabelUncheckedUpdateInput>
    /**
     * Choose, which StockLabel to update.
     * 
    **/
    where: StockLabelWhereUniqueInput
  }


  /**
   * StockLabel updateMany
   */
  export type StockLabelUpdateManyArgs = {
    /**
     * The data used to update StockLabels.
     * 
    **/
    data: XOR<StockLabelUpdateManyMutationInput, StockLabelUncheckedUpdateManyInput>
    /**
     * Filter which StockLabels to update
     * 
    **/
    where?: StockLabelWhereInput
  }


  /**
   * StockLabel upsert
   */
  export type StockLabelUpsertArgs = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
    /**
     * The filter to search for the StockLabel to update in case it exists.
     * 
    **/
    where: StockLabelWhereUniqueInput
    /**
     * In case the StockLabel found by the `where` argument doesn't exist, create a new StockLabel with this data.
     * 
    **/
    create: XOR<StockLabelCreateInput, StockLabelUncheckedCreateInput>
    /**
     * In case the StockLabel was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StockLabelUpdateInput, StockLabelUncheckedUpdateInput>
  }


  /**
   * StockLabel delete
   */
  export type StockLabelDeleteArgs = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
    /**
     * Filter which StockLabel to delete.
     * 
    **/
    where: StockLabelWhereUniqueInput
  }


  /**
   * StockLabel deleteMany
   */
  export type StockLabelDeleteManyArgs = {
    /**
     * Filter which StockLabels to delete
     * 
    **/
    where?: StockLabelWhereInput
  }


  /**
   * StockLabel: findUniqueOrThrow
   */
  export type StockLabelFindUniqueOrThrowArgs = StockLabelFindUniqueArgsBase
      

  /**
   * StockLabel: findFirstOrThrow
   */
  export type StockLabelFindFirstOrThrowArgs = StockLabelFindFirstArgsBase
      

  /**
   * StockLabel without action
   */
  export type StockLabelArgs = {
    /**
     * Select specific fields to fetch from the StockLabel
     * 
    **/
    select?: StockLabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockLabelInclude | null
  }



  /**
   * Model StockHistory
   */


  export type AggregateStockHistory = {
    _count: StockHistoryCountAggregateOutputType | null
    _avg: StockHistoryAvgAggregateOutputType | null
    _sum: StockHistorySumAggregateOutputType | null
    _min: StockHistoryMinAggregateOutputType | null
    _max: StockHistoryMaxAggregateOutputType | null
  }

  export type StockHistoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockHistorySumAggregateOutputType = {
    quantity: number | null
  }

  export type StockHistoryMinAggregateOutputType = {
    id: string | null
    label_id: string | null
    reason: string | null
    quantity: number | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StockHistoryMaxAggregateOutputType = {
    id: string | null
    label_id: string | null
    reason: string | null
    quantity: number | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StockHistoryCountAggregateOutputType = {
    id: number
    label_id: number
    reason: number
    quantity: number
    date: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StockHistoryAvgAggregateInputType = {
    quantity?: true
  }

  export type StockHistorySumAggregateInputType = {
    quantity?: true
  }

  export type StockHistoryMinAggregateInputType = {
    id?: true
    label_id?: true
    reason?: true
    quantity?: true
    date?: true
    created_at?: true
    updated_at?: true
  }

  export type StockHistoryMaxAggregateInputType = {
    id?: true
    label_id?: true
    reason?: true
    quantity?: true
    date?: true
    created_at?: true
    updated_at?: true
  }

  export type StockHistoryCountAggregateInputType = {
    id?: true
    label_id?: true
    reason?: true
    quantity?: true
    date?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StockHistoryAggregateArgs = {
    /**
     * Filter which StockHistory to aggregate.
     * 
    **/
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<StockHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockHistories
    **/
    _count?: true | StockHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockHistoryMaxAggregateInputType
  }

  export type GetStockHistoryAggregateType<T extends StockHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStockHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockHistory[P]>
      : GetScalarType<T[P], AggregateStockHistory[P]>
  }




  export type StockHistoryGroupByArgs = {
    where?: StockHistoryWhereInput
    orderBy?: Enumerable<StockHistoryOrderByWithAggregationInput>
    by: Array<StockHistoryScalarFieldEnum>
    having?: StockHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockHistoryCountAggregateInputType | true
    _avg?: StockHistoryAvgAggregateInputType
    _sum?: StockHistorySumAggregateInputType
    _min?: StockHistoryMinAggregateInputType
    _max?: StockHistoryMaxAggregateInputType
  }


  export type StockHistoryGroupByOutputType = {
    id: string
    label_id: string
    reason: string
    quantity: number
    date: Date
    created_at: Date
    updated_at: Date
    _count: StockHistoryCountAggregateOutputType | null
    _avg: StockHistoryAvgAggregateOutputType | null
    _sum: StockHistorySumAggregateOutputType | null
    _min: StockHistoryMinAggregateOutputType | null
    _max: StockHistoryMaxAggregateOutputType | null
  }

  type GetStockHistoryGroupByPayload<T extends StockHistoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StockHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], StockHistoryGroupByOutputType[P]>
        }
      >
    >


  export type StockHistorySelect = {
    id?: boolean
    label_id?: boolean
    labels?: boolean | LabelArgs
    reason?: boolean
    quantity?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StockHistoryInclude = {
    labels?: boolean | LabelArgs
  }

  export type StockHistoryGetPayload<
    S extends boolean | null | undefined | StockHistoryArgs,
    U = keyof S
      > = S extends true
        ? StockHistory
    : S extends undefined
    ? never
    : S extends StockHistoryArgs | StockHistoryFindManyArgs
    ?'include' extends U
    ? StockHistory  & {
    [P in TrueKeys<S['include']>]:
        P extends 'labels' ? LabelGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'labels' ? LabelGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof StockHistory ? StockHistory[P] : never
  } 
    : StockHistory
  : StockHistory


  type StockHistoryCountArgs = Merge<
    Omit<StockHistoryFindManyArgs, 'select' | 'include'> & {
      select?: StockHistoryCountAggregateInputType | true
    }
  >

  export interface StockHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StockHistory that matches the filter.
     * @param {StockHistoryFindUniqueArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StockHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StockHistory'> extends True ? CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>> : CheckSelect<T, Prisma__StockHistoryClient<StockHistory | null, null>, Prisma__StockHistoryClient<StockHistoryGetPayload<T> | null, null>>

    /**
     * Find the first StockHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindFirstArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StockHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StockHistory'> extends True ? CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>> : CheckSelect<T, Prisma__StockHistoryClient<StockHistory | null, null>, Prisma__StockHistoryClient<StockHistoryGetPayload<T> | null, null>>

    /**
     * Find zero or more StockHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockHistories
     * const stockHistories = await prisma.stockHistory.findMany()
     * 
     * // Get first 10 StockHistories
     * const stockHistories = await prisma.stockHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockHistoryWithIdOnly = await prisma.stockHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockHistoryFindManyArgs>(
      args?: SelectSubset<T, StockHistoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StockHistory>>, PrismaPromise<Array<StockHistoryGetPayload<T>>>>

    /**
     * Create a StockHistory.
     * @param {StockHistoryCreateArgs} args - Arguments to create a StockHistory.
     * @example
     * // Create one StockHistory
     * const StockHistory = await prisma.stockHistory.create({
     *   data: {
     *     // ... data to create a StockHistory
     *   }
     * })
     * 
    **/
    create<T extends StockHistoryCreateArgs>(
      args: SelectSubset<T, StockHistoryCreateArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Create many StockHistories.
     *     @param {StockHistoryCreateManyArgs} args - Arguments to create many StockHistories.
     *     @example
     *     // Create many StockHistories
     *     const stockHistory = await prisma.stockHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockHistoryCreateManyArgs>(
      args?: SelectSubset<T, StockHistoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StockHistory.
     * @param {StockHistoryDeleteArgs} args - Arguments to delete one StockHistory.
     * @example
     * // Delete one StockHistory
     * const StockHistory = await prisma.stockHistory.delete({
     *   where: {
     *     // ... filter to delete one StockHistory
     *   }
     * })
     * 
    **/
    delete<T extends StockHistoryDeleteArgs>(
      args: SelectSubset<T, StockHistoryDeleteArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Update one StockHistory.
     * @param {StockHistoryUpdateArgs} args - Arguments to update one StockHistory.
     * @example
     * // Update one StockHistory
     * const stockHistory = await prisma.stockHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockHistoryUpdateArgs>(
      args: SelectSubset<T, StockHistoryUpdateArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Delete zero or more StockHistories.
     * @param {StockHistoryDeleteManyArgs} args - Arguments to filter StockHistories to delete.
     * @example
     * // Delete a few StockHistories
     * const { count } = await prisma.stockHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockHistoryDeleteManyArgs>(
      args?: SelectSubset<T, StockHistoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockHistories
     * const stockHistory = await prisma.stockHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockHistoryUpdateManyArgs>(
      args: SelectSubset<T, StockHistoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StockHistory.
     * @param {StockHistoryUpsertArgs} args - Arguments to update or create a StockHistory.
     * @example
     * // Update or create a StockHistory
     * const stockHistory = await prisma.stockHistory.upsert({
     *   create: {
     *     // ... data to create a StockHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockHistory we want to update
     *   }
     * })
    **/
    upsert<T extends StockHistoryUpsertArgs>(
      args: SelectSubset<T, StockHistoryUpsertArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Find one StockHistory that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StockHistoryFindUniqueOrThrowArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StockHistoryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Find the first StockHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindFirstOrThrowArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StockHistoryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Count the number of StockHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryCountArgs} args - Arguments to filter StockHistories to count.
     * @example
     * // Count the number of StockHistories
     * const count = await prisma.stockHistory.count({
     *   where: {
     *     // ... the filter for the StockHistories we want to count
     *   }
     * })
    **/
    count<T extends StockHistoryCountArgs>(
      args?: Subset<T, StockHistoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockHistoryAggregateArgs>(args: Subset<T, StockHistoryAggregateArgs>): PrismaPromise<GetStockHistoryAggregateType<T>>

    /**
     * Group by StockHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockHistoryGroupByArgs['orderBy'] }
        : { orderBy?: StockHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockHistoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StockHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StockHistoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    labels<T extends LabelArgs = {}>(args?: Subset<T, LabelArgs>): CheckSelect<T, Prisma__LabelClient<Label | Null>, Prisma__LabelClient<LabelGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StockHistory base type for findUnique actions
   */
  export type StockHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter, which StockHistory to fetch.
     * 
    **/
    where: StockHistoryWhereUniqueInput
  }

  /**
   * StockHistory: findUnique
   */
  export interface StockHistoryFindUniqueArgs extends StockHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockHistory base type for findFirst actions
   */
  export type StockHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter, which StockHistory to fetch.
     * 
    **/
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<StockHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockHistories.
     * 
    **/
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockHistories.
     * 
    **/
    distinct?: Enumerable<StockHistoryScalarFieldEnum>
  }

  /**
   * StockHistory: findFirst
   */
  export interface StockHistoryFindFirstArgs extends StockHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockHistory findMany
   */
  export type StockHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter, which StockHistories to fetch.
     * 
    **/
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<StockHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockHistories.
     * 
    **/
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StockHistoryScalarFieldEnum>
  }


  /**
   * StockHistory create
   */
  export type StockHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * The data needed to create a StockHistory.
     * 
    **/
    data: XOR<StockHistoryCreateInput, StockHistoryUncheckedCreateInput>
  }


  /**
   * StockHistory createMany
   */
  export type StockHistoryCreateManyArgs = {
    /**
     * The data used to create many StockHistories.
     * 
    **/
    data: Enumerable<StockHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StockHistory update
   */
  export type StockHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * The data needed to update a StockHistory.
     * 
    **/
    data: XOR<StockHistoryUpdateInput, StockHistoryUncheckedUpdateInput>
    /**
     * Choose, which StockHistory to update.
     * 
    **/
    where: StockHistoryWhereUniqueInput
  }


  /**
   * StockHistory updateMany
   */
  export type StockHistoryUpdateManyArgs = {
    /**
     * The data used to update StockHistories.
     * 
    **/
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StockHistories to update
     * 
    **/
    where?: StockHistoryWhereInput
  }


  /**
   * StockHistory upsert
   */
  export type StockHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * The filter to search for the StockHistory to update in case it exists.
     * 
    **/
    where: StockHistoryWhereUniqueInput
    /**
     * In case the StockHistory found by the `where` argument doesn't exist, create a new StockHistory with this data.
     * 
    **/
    create: XOR<StockHistoryCreateInput, StockHistoryUncheckedCreateInput>
    /**
     * In case the StockHistory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StockHistoryUpdateInput, StockHistoryUncheckedUpdateInput>
  }


  /**
   * StockHistory delete
   */
  export type StockHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter which StockHistory to delete.
     * 
    **/
    where: StockHistoryWhereUniqueInput
  }


  /**
   * StockHistory deleteMany
   */
  export type StockHistoryDeleteManyArgs = {
    /**
     * Filter which StockHistories to delete
     * 
    **/
    where?: StockHistoryWhereInput
  }


  /**
   * StockHistory: findUniqueOrThrow
   */
  export type StockHistoryFindUniqueOrThrowArgs = StockHistoryFindUniqueArgsBase
      

  /**
   * StockHistory: findFirstOrThrow
   */
  export type StockHistoryFindFirstOrThrowArgs = StockHistoryFindFirstArgsBase
      

  /**
   * StockHistory without action
   */
  export type StockHistoryArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountActivitiesScalarFieldEnum: {
    account_id: 'account_id',
    activities_id: 'activities_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AccountActivitiesScalarFieldEnum = (typeof AccountActivitiesScalarFieldEnum)[keyof typeof AccountActivitiesScalarFieldEnum]


  export const AccountConfigurationScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    banner_market_url: 'banner_market_url',
    header_color: 'header_color'
  };

  export type AccountConfigurationScalarFieldEnum = (typeof AccountConfigurationScalarFieldEnum)[keyof typeof AccountConfigurationScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    cpf_cnpj: 'cpf_cnpj',
    market_name: 'market_name',
    email: 'email',
    phone: 'phone',
    whatsapp: 'whatsapp',
    logo: 'logo',
    person_type: 'person_type',
    site: 'site',
    social_reason: 'social_reason',
    facebook_url: 'facebook_url',
    instagram_url: 'instagram_url',
    banner: 'banner',
    gender: 'gender',
    street: 'street',
    number: 'number',
    district: 'district',
    country: 'country',
    state: 'state',
    complement: 'complement',
    zipcode: 'zipcode',
    plan_id: 'plan_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    domain: 'domain',
    isActive: 'isActive'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountUserScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type AccountUserScalarFieldEnum = (typeof AccountUserScalarFieldEnum)[keyof typeof AccountUserScalarFieldEnum]


  export const ActivitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivitiesScalarFieldEnum = (typeof ActivitiesScalarFieldEnum)[keyof typeof ActivitiesScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    percentage_discount: 'percentage_discount',
    start_date: 'start_date',
    expiration_date: 'expiration_date',
    type_id: 'type_id',
    account_id: 'account_id',
    account_user_id: 'account_user_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type CampaignTypeScalarFieldEnum = (typeof CampaignTypeScalarFieldEnum)[keyof typeof CampaignTypeScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    state_id: 'state_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    dicount_type: 'dicount_type',
    discount_value: 'discount_value',
    couponUse_type: 'couponUse_type',
    inital_date: 'inital_date',
    expiration_date: 'expiration_date',
    min_value: 'min_value',
    max_value: 'max_value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const DeviceNotificationScalarFieldEnum: {
    device_id: 'device_id',
    notification_id: 'notification_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeviceNotificationScalarFieldEnum = (typeof DeviceNotificationScalarFieldEnum)[keyof typeof DeviceNotificationScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    device_physical_id: 'device_physical_id',
    platform: 'platform',
    version: 'version',
    token_notification: 'token_notification',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const DeviceUserScalarFieldEnum: {
    device_id: 'device_id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeviceUserScalarFieldEnum = (typeof DeviceUserScalarFieldEnum)[keyof typeof DeviceUserScalarFieldEnum]


  export const EmailNotificationScalarFieldEnum: {
    id: 'id',
    notification_id: 'notification_id',
    to: 'to',
    from: 'from',
    from_name: 'from_name',
    cc: 'cc',
    bcc: 'bcc',
    type: 'type',
    subject: 'subject',
    body: 'body',
    url_callback: 'url_callback',
    opened: 'opened',
    clicked: 'clicked',
    failed: 'failed',
    error_description: 'error_description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EmailNotificationScalarFieldEnum = (typeof EmailNotificationScalarFieldEnum)[keyof typeof EmailNotificationScalarFieldEnum]


  export const GrapeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updatedAt: 'updatedAt'
  };

  export type GrapeScalarFieldEnum = (typeof GrapeScalarFieldEnum)[keyof typeof GrapeScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const LabelCampaignScalarFieldEnum: {
    label_id: 'label_id',
    campaign_id: 'campaign_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LabelCampaignScalarFieldEnum = (typeof LabelCampaignScalarFieldEnum)[keyof typeof LabelCampaignScalarFieldEnum]


  export const LabelGrapeScalarFieldEnum: {
    label_id: 'label_id',
    grape_id: 'grape_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LabelGrapeScalarFieldEnum = (typeof LabelGrapeScalarFieldEnum)[keyof typeof LabelGrapeScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type_id: 'type_id',
    country_id: 'country_id',
    region_id: 'region_id',
    harvest: 'harvest',
    wine_type_id: 'wine_type_id',
    alcohol_percentage: 'alcohol_percentage',
    price: 'price',
    promotional_price: 'promotional_price',
    is_active: 'is_active',
    stock: 'stock',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const LabelTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LabelTypeScalarFieldEnum = (typeof LabelTypeScalarFieldEnum)[keyof typeof LabelTypeScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    created_at: 'created_at',
    updated_at: 'updated_at',
    type: 'type'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const OrderLabelScalarFieldEnum: {
    order_id: 'order_id',
    label_id: 'label_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    quantity: 'quantity'
  };

  export type OrderLabelScalarFieldEnum = (typeof OrderLabelScalarFieldEnum)[keyof typeof OrderLabelScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    code: 'code',
    account_id: 'account_id',
    total: 'total',
    coupon_id: 'coupon_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PaymentCycleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentCycleScalarFieldEnum = (typeof PaymentCycleScalarFieldEnum)[keyof typeof PaymentCycleScalarFieldEnum]


  export const PermisionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PermisionScalarFieldEnum = (typeof PermisionScalarFieldEnum)[keyof typeof PermisionScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    price: 'price',
    max_users: 'max_users',
    max_labels: 'max_labels',
    payment_cycle_id: 'payment_cycle_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PushNotificationScalarFieldEnum: {
    id: 'id',
    notification_id: 'notification_id',
    title: 'title',
    subject: 'subject',
    send: 'send',
    device_id: 'device_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PushNotificationScalarFieldEnum = (typeof PushNotificationScalarFieldEnum)[keyof typeof PushNotificationScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    state_id: 'state_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    role_id: 'role_id',
    permission_id: 'permission_id'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SmsNotificationScalarFieldEnum: {
    id: 'id',
    notification_id: 'notification_id',
    device_id: 'device_id',
    to: 'to',
    subject: 'subject',
    body: 'body',
    send: 'send',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SmsNotificationScalarFieldEnum = (typeof SmsNotificationScalarFieldEnum)[keyof typeof SmsNotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    country_id: 'country_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const StockHistoryScalarFieldEnum: {
    id: 'id',
    label_id: 'label_id',
    reason: 'reason',
    quantity: 'quantity',
    date: 'date',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StockHistoryScalarFieldEnum = (typeof StockHistoryScalarFieldEnum)[keyof typeof StockHistoryScalarFieldEnum]


  export const StockLabelScalarFieldEnum: {
    label_id: 'label_id',
    account_id: 'account_id',
    min_quantity: 'min_quantity',
    max_quantity: 'max_quantity'
  };

  export type StockLabelScalarFieldEnum = (typeof StockLabelScalarFieldEnum)[keyof typeof StockLabelScalarFieldEnum]


  export const SubRegionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    region_id: 'region_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubRegionScalarFieldEnum = (typeof SubRegionScalarFieldEnum)[keyof typeof SubRegionScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    plan_id: 'plan_id',
    account_id: 'account_id',
    due: 'due',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    whatsapp: 'whatsapp',
    phone: 'phone',
    cpf_cnpj: 'cpf_cnpj',
    street: 'street',
    number: 'number',
    district: 'district',
    country: 'country',
    state: 'state',
    complement: 'complement',
    city: 'city',
    zipcode: 'zipcode',
    photo: 'photo',
    gender: 'gender',
    birthdate: 'birthdate',
    google_id: 'google_id',
    apple_id: 'apple_id',
    facebook_id: 'facebook_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WineTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WineTypeScalarFieldEnum = (typeof WineTypeScalarFieldEnum)[keyof typeof WineTypeScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    external_id?: IntFilter | number
    name?: StringFilter | string
    cpf_cnpj?: StringNullableFilter | string | null
    market_name?: StringFilter | string
    email?: StringFilter | string
    phone?: StringNullableFilter | string | null
    whatsapp?: StringNullableFilter | string | null
    logo?: StringNullableFilter | string | null
    person_type?: EnumPersonTypeFilter | PersonType
    site?: StringNullableFilter | string | null
    social_reason?: StringNullableFilter | string | null
    facebook_url?: StringNullableFilter | string | null
    instagram_url?: StringNullableFilter | string | null
    banner?: StringNullableFilter | string | null
    gender?: EnumGenderTypeFilter | GenderType
    campaign?: CampaignListRelationFilter
    street?: StringFilter | string
    number?: StringFilter | string
    district?: StringFilter | string
    country?: StringFilter | string
    state?: StringFilter | string
    complement?: StringNullableFilter | string | null
    zipcode?: StringFilter | string
    plan_id?: StringNullableFilter | string | null
    plan?: XOR<PlanRelationFilter, PlanWhereInput> | null
    subscription?: SubscriptionListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    order?: OrderListRelationFilter
    account_activities?: AccountActivitiesListRelationFilter
    account_users?: AccountUserListRelationFilter
    domain?: StringFilter | string
    StockLabel?: StockLabelListRelationFilter
    account_configuration?: XOR<AccountConfigurationRelationFilter, AccountConfigurationWhereInput> | null
    isActive?: BoolFilter | boolean
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    campaign?: CampaignOrderByRelationAggregateInput
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    plan?: PlanOrderByWithRelationInput
    subscription?: SubscriptionOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
    order?: OrderOrderByRelationAggregateInput
    account_activities?: AccountActivitiesOrderByRelationAggregateInput
    account_users?: AccountUserOrderByRelationAggregateInput
    domain?: SortOrder
    StockLabel?: StockLabelOrderByRelationAggregateInput
    account_configuration?: AccountConfigurationOrderByWithRelationInput
    isActive?: SortOrder
  }

  export type AccountWhereUniqueInput = {
    id?: string
    external_id?: number
    email?: string
    domain?: string
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    cpf_cnpj?: StringNullableWithAggregatesFilter | string | null
    market_name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    whatsapp?: StringNullableWithAggregatesFilter | string | null
    logo?: StringNullableWithAggregatesFilter | string | null
    person_type?: EnumPersonTypeWithAggregatesFilter | PersonType
    site?: StringNullableWithAggregatesFilter | string | null
    social_reason?: StringNullableWithAggregatesFilter | string | null
    facebook_url?: StringNullableWithAggregatesFilter | string | null
    instagram_url?: StringNullableWithAggregatesFilter | string | null
    banner?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeWithAggregatesFilter | GenderType
    street?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    district?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
    zipcode?: StringWithAggregatesFilter | string
    plan_id?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    domain?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type AccountConfigurationWhereInput = {
    AND?: Enumerable<AccountConfigurationWhereInput>
    OR?: Enumerable<AccountConfigurationWhereInput>
    NOT?: Enumerable<AccountConfigurationWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    banner_market_url?: StringNullableFilter | string | null
    header_color?: StringNullableFilter | string | null
  }

  export type AccountConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type AccountConfigurationWhereUniqueInput = {
    id?: string
    account_id?: string
  }

  export type AccountConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
    _count?: AccountConfigurationCountOrderByAggregateInput
    _max?: AccountConfigurationMaxOrderByAggregateInput
    _min?: AccountConfigurationMinOrderByAggregateInput
  }

  export type AccountConfigurationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountConfigurationScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountConfigurationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountConfigurationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    banner_market_url?: StringNullableWithAggregatesFilter | string | null
    header_color?: StringNullableWithAggregatesFilter | string | null
  }

  export type AccountActivitiesWhereInput = {
    AND?: Enumerable<AccountActivitiesWhereInput>
    OR?: Enumerable<AccountActivitiesWhereInput>
    NOT?: Enumerable<AccountActivitiesWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    activities_id?: StringFilter | string
    activities?: XOR<ActivitiesRelationFilter, ActivitiesWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountActivitiesOrderByWithRelationInput = {
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    activities_id?: SortOrder
    activities?: ActivitiesOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountActivitiesWhereUniqueInput = {
    account_id_activities_id?: AccountActivitiesAccount_idActivities_idCompoundUniqueInput
  }

  export type AccountActivitiesOrderByWithAggregationInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AccountActivitiesCountOrderByAggregateInput
    _max?: AccountActivitiesMaxOrderByAggregateInput
    _min?: AccountActivitiesMinOrderByAggregateInput
  }

  export type AccountActivitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountActivitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountActivitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountActivitiesScalarWhereWithAggregatesInput>
    account_id?: StringWithAggregatesFilter | string
    activities_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ActivitiesWhereInput = {
    AND?: Enumerable<ActivitiesWhereInput>
    OR?: Enumerable<ActivitiesWhereInput>
    NOT?: Enumerable<ActivitiesWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    account_activities?: AccountActivitiesListRelationFilter
  }

  export type ActivitiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_activities?: AccountActivitiesOrderByRelationAggregateInput
  }

  export type ActivitiesWhereUniqueInput = {
    id?: string
  }

  export type ActivitiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivitiesCountOrderByAggregateInput
    _max?: ActivitiesMaxOrderByAggregateInput
    _min?: ActivitiesMinOrderByAggregateInput
  }

  export type ActivitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivitiesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    whatsapp?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    cpf_cnpj?: StringNullableFilter | string | null
    street?: StringFilter | string
    number?: StringFilter | string
    district?: StringFilter | string
    country?: StringFilter | string
    state?: StringFilter | string
    complement?: StringNullableFilter | string | null
    city?: StringFilter | string
    zipcode?: StringFilter | string
    photo?: StringNullableFilter | string | null
    gender?: EnumGenderTypeFilter | GenderType
    birthdate?: DateTimeNullableFilter | Date | string | null
    google_id?: StringNullableFilter | string | null
    apple_id?: StringNullableFilter | string | null
    facebook_id?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    lastLogin?: DateTimeFilter | Date | string
    device_user?: DeviceUserListRelationFilter
    account_user?: AccountUserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
    device_user?: DeviceUserOrderByRelationAggregateInput
    account_user?: AccountUserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    cpf_cnpj?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    whatsapp?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    cpf_cnpj?: StringNullableWithAggregatesFilter | string | null
    street?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    district?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
    city?: StringWithAggregatesFilter | string
    zipcode?: StringWithAggregatesFilter | string
    photo?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeWithAggregatesFilter | GenderType
    birthdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    google_id?: StringNullableWithAggregatesFilter | string | null
    apple_id?: StringNullableWithAggregatesFilter | string | null
    facebook_id?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    lastLogin?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountUserWhereInput = {
    AND?: Enumerable<AccountUserWhereInput>
    OR?: Enumerable<AccountUserWhereInput>
    NOT?: Enumerable<AccountUserWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role_id?: StringFilter | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    campaigns?: CampaignListRelationFilter
  }

  export type AccountUserOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    role_id?: SortOrder
    role?: RoleOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type AccountUserWhereUniqueInput = {
    id?: string
    account_id_user_id_id?: AccountUserAccount_idUser_idIdCompoundUniqueInput
  }

  export type AccountUserOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
    _count?: AccountUserCountOrderByAggregateInput
    _max?: AccountUserMaxOrderByAggregateInput
    _min?: AccountUserMinOrderByAggregateInput
  }

  export type AccountUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountUserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    role_id?: StringWithAggregatesFilter | string
  }

  export type PermisionWhereInput = {
    AND?: Enumerable<PermisionWhereInput>
    OR?: Enumerable<PermisionWhereInput>
    NOT?: Enumerable<PermisionWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    RolePermission?: RolePermissionListRelationFilter
  }

  export type PermisionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    RolePermission?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermisionWhereUniqueInput = {
    id?: string
  }

  export type PermisionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PermisionCountOrderByAggregateInput
    _max?: PermisionMaxOrderByAggregateInput
    _min?: PermisionMinOrderByAggregateInput
  }

  export type PermisionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermisionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermisionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermisionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type RolePermissionWhereInput = {
    AND?: Enumerable<RolePermissionWhereInput>
    OR?: Enumerable<RolePermissionWhereInput>
    NOT?: Enumerable<RolePermissionWhereInput>
    role_id?: StringFilter | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission_id?: StringFilter | string
    permission?: XOR<PermisionRelationFilter, PermisionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    role_id?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission_id?: SortOrder
    permission?: PermisionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = {
    role_id_permission_id?: RolePermissionRole_idPermission_idCompoundUniqueInput
  }

  export type RolePermissionOrderByWithAggregationInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    role_id?: StringWithAggregatesFilter | string
    permission_id?: StringWithAggregatesFilter | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    RolePermission?: RolePermissionListRelationFilter
    AccountUser?: AccountUserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    RolePermission?: RolePermissionOrderByRelationAggregateInput
    AccountUser?: AccountUserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type CampaignWhereInput = {
    AND?: Enumerable<CampaignWhereInput>
    OR?: Enumerable<CampaignWhereInput>
    NOT?: Enumerable<CampaignWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    percentage_discount?: FloatNullableFilter | number | null
    start_date?: DateTimeNullableFilter | Date | string | null
    expiration_date?: DateTimeNullableFilter | Date | string | null
    type_id?: StringFilter | string
    campaign_type?: XOR<CampaignTypeRelationFilter, CampaignTypeWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    account_id?: StringFilter | string
    account_user_id?: StringFilter | string
    account_user?: XOR<AccountUserRelationFilter, AccountUserWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    label_campaign?: LabelCampaignListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    percentage_discount?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    type_id?: SortOrder
    campaign_type?: CampaignTypeOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    account_id?: SortOrder
    account_user_id?: SortOrder
    account_user?: AccountUserOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
    label_campaign?: LabelCampaignOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = {
    id?: string
  }

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    percentage_discount?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    type_id?: SortOrder
    account_id?: SortOrder
    account_user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    percentage_discount?: FloatNullableWithAggregatesFilter | number | null
    start_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    expiration_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    type_id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    account_user_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CampaignTypeWhereInput = {
    AND?: Enumerable<CampaignTypeWhereInput>
    OR?: Enumerable<CampaignTypeWhereInput>
    NOT?: Enumerable<CampaignTypeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    Campaign?: CampaignListRelationFilter
  }

  export type CampaignTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    Campaign?: CampaignOrderByRelationAggregateInput
  }

  export type CampaignTypeWhereUniqueInput = {
    id?: string
  }

  export type CampaignTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: CampaignTypeCountOrderByAggregateInput
    _max?: CampaignTypeMaxOrderByAggregateInput
    _min?: CampaignTypeMinOrderByAggregateInput
  }

  export type CampaignTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
  }

  export type CouponWhereInput = {
    AND?: Enumerable<CouponWhereInput>
    OR?: Enumerable<CouponWhereInput>
    NOT?: Enumerable<CouponWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    dicount_type?: EnumCouponDiscountTypeFilter | CouponDiscountType
    discount_value?: FloatFilter | number
    couponUse_type?: EnumCouponUseTypeFilter | CouponUseType
    inital_date?: DateTimeFilter | Date | string
    expiration_date?: DateTimeNullableFilter | Date | string | null
    min_value?: FloatNullableFilter | number | null
    max_value?: FloatNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponWhereUniqueInput = {
    id?: string
  }

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CouponScalarWhereWithAggregatesInput>
    OR?: Enumerable<CouponScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CouponScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    dicount_type?: EnumCouponDiscountTypeWithAggregatesFilter | CouponDiscountType
    discount_value?: FloatWithAggregatesFilter | number
    couponUse_type?: EnumCouponUseTypeWithAggregatesFilter | CouponUseType
    inital_date?: DateTimeWithAggregatesFilter | Date | string
    expiration_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    min_value?: FloatNullableWithAggregatesFilter | number | null
    max_value?: FloatNullableWithAggregatesFilter | number | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LabelWhereInput = {
    AND?: Enumerable<LabelWhereInput>
    OR?: Enumerable<LabelWhereInput>
    NOT?: Enumerable<LabelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    type_id?: StringFilter | string
    labelType?: XOR<LabelTypeRelationFilter, LabelTypeWhereInput>
    country_id?: StringFilter | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    region_id?: StringFilter | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    harvest?: StringNullableFilter | string | null
    wine_type_id?: StringFilter | string
    wine_type?: XOR<WineTypeRelationFilter, WineTypeWhereInput>
    alcohol_percentage?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    price?: FloatFilter | number
    promotional_price?: FloatNullableFilter | number | null
    is_active?: BoolFilter | boolean
    stock?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    label_grape?: LabelGrapeListRelationFilter
    order_label?: OrderLabelListRelationFilter
    label_campaign?: LabelCampaignListRelationFilter
    StockLabel?: StockLabelListRelationFilter
    StockHistory?: StockHistoryListRelationFilter
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    labelType?: LabelTypeOrderByWithRelationInput
    country_id?: SortOrder
    country?: CountryOrderByWithRelationInput
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    harvest?: SortOrder
    wine_type_id?: SortOrder
    wine_type?: WineTypeOrderByWithRelationInput
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    is_active?: SortOrder
    stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    label_grape?: LabelGrapeOrderByRelationAggregateInput
    order_label?: OrderLabelOrderByRelationAggregateInput
    label_campaign?: LabelCampaignOrderByRelationAggregateInput
    StockLabel?: StockLabelOrderByRelationAggregateInput
    StockHistory?: StockHistoryOrderByRelationAggregateInput
  }

  export type LabelWhereUniqueInput = {
    id?: string
  }

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    is_active?: SortOrder
    stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LabelCountOrderByAggregateInput
    _avg?: LabelAvgOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
    _sum?: LabelSumOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LabelScalarWhereWithAggregatesInput>
    OR?: Enumerable<LabelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LabelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    type_id?: StringWithAggregatesFilter | string
    country_id?: StringWithAggregatesFilter | string
    region_id?: StringWithAggregatesFilter | string
    harvest?: StringNullableWithAggregatesFilter | string | null
    wine_type_id?: StringWithAggregatesFilter | string
    alcohol_percentage?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    price?: FloatWithAggregatesFilter | number
    promotional_price?: FloatNullableWithAggregatesFilter | number | null
    is_active?: BoolWithAggregatesFilter | boolean
    stock?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LabelCampaignWhereInput = {
    AND?: Enumerable<LabelCampaignWhereInput>
    OR?: Enumerable<LabelCampaignWhereInput>
    NOT?: Enumerable<LabelCampaignWhereInput>
    label_id?: StringFilter | string
    label?: XOR<LabelRelationFilter, LabelWhereInput>
    campaign_id?: StringFilter | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type LabelCampaignOrderByWithRelationInput = {
    label_id?: SortOrder
    label?: LabelOrderByWithRelationInput
    campaign_id?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelCampaignWhereUniqueInput = {
    label_id_campaign_id?: LabelCampaignLabel_idCampaign_idCompoundUniqueInput
  }

  export type LabelCampaignOrderByWithAggregationInput = {
    label_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LabelCampaignCountOrderByAggregateInput
    _max?: LabelCampaignMaxOrderByAggregateInput
    _min?: LabelCampaignMinOrderByAggregateInput
  }

  export type LabelCampaignScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LabelCampaignScalarWhereWithAggregatesInput>
    OR?: Enumerable<LabelCampaignScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LabelCampaignScalarWhereWithAggregatesInput>
    label_id?: StringWithAggregatesFilter | string
    campaign_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LabelGrapeWhereInput = {
    AND?: Enumerable<LabelGrapeWhereInput>
    OR?: Enumerable<LabelGrapeWhereInput>
    NOT?: Enumerable<LabelGrapeWhereInput>
    label_id?: StringFilter | string
    label?: XOR<LabelRelationFilter, LabelWhereInput>
    grape_id?: StringFilter | string
    grape?: XOR<GrapeRelationFilter, GrapeWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type LabelGrapeOrderByWithRelationInput = {
    label_id?: SortOrder
    label?: LabelOrderByWithRelationInput
    grape_id?: SortOrder
    grape?: GrapeOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelGrapeWhereUniqueInput = {
    label_id_grape_id?: LabelGrapeLabel_idGrape_idCompoundUniqueInput
  }

  export type LabelGrapeOrderByWithAggregationInput = {
    label_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LabelGrapeCountOrderByAggregateInput
    _max?: LabelGrapeMaxOrderByAggregateInput
    _min?: LabelGrapeMinOrderByAggregateInput
  }

  export type LabelGrapeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LabelGrapeScalarWhereWithAggregatesInput>
    OR?: Enumerable<LabelGrapeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LabelGrapeScalarWhereWithAggregatesInput>
    label_id?: StringWithAggregatesFilter | string
    grape_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GrapeWhereInput = {
    AND?: Enumerable<GrapeWhereInput>
    OR?: Enumerable<GrapeWhereInput>
    NOT?: Enumerable<GrapeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    LabelGrape?: LabelGrapeListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type GrapeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    LabelGrape?: LabelGrapeOrderByRelationAggregateInput
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrapeWhereUniqueInput = {
    id?: string
  }

  export type GrapeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
    _count?: GrapeCountOrderByAggregateInput
    _max?: GrapeMaxOrderByAggregateInput
    _min?: GrapeMinOrderByAggregateInput
  }

  export type GrapeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GrapeScalarWhereWithAggregatesInput>
    OR?: Enumerable<GrapeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GrapeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LabelTypeWhereInput = {
    AND?: Enumerable<LabelTypeWhereInput>
    OR?: Enumerable<LabelTypeWhereInput>
    NOT?: Enumerable<LabelTypeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    labels?: LabelListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type LabelTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    labels?: LabelOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelTypeWhereUniqueInput = {
    id?: string
  }

  export type LabelTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LabelTypeCountOrderByAggregateInput
    _max?: LabelTypeMaxOrderByAggregateInput
    _min?: LabelTypeMinOrderByAggregateInput
  }

  export type LabelTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LabelTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<LabelTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LabelTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    value?: StringFilter | string
    states?: StateListRelationFilter
    labels?: LabelListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    states?: StateOrderByRelationAggregateInput
    labels?: LabelOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CountryWhereUniqueInput = {
    id?: string
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StateWhereInput = {
    AND?: Enumerable<StateWhereInput>
    OR?: Enumerable<StateWhereInput>
    NOT?: Enumerable<StateWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    country_id?: StringFilter | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    regions?: RegionListRelationFilter
    cities?: CityListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    country?: CountryOrderByWithRelationInput
    regions?: RegionOrderByRelationAggregateInput
    cities?: CityOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateWhereUniqueInput = {
    id?: string
  }

  export type StateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StateCountOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StateScalarWhereWithAggregatesInput>
    OR?: Enumerable<StateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    country_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    state_id?: StringFilter | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    state?: StateOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CityWhereUniqueInput = {
    id?: string
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    state_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RegionWhereInput = {
    AND?: Enumerable<RegionWhereInput>
    OR?: Enumerable<RegionWhereInput>
    NOT?: Enumerable<RegionWhereInput>
    id?: StringFilter | string
    state_id?: StringFilter | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    name?: StringFilter | string
    slug?: StringFilter | string
    subregion?: SubRegionListRelationFilter
    labels?: LabelListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    state_id?: SortOrder
    state?: StateOrderByWithRelationInput
    name?: SortOrder
    slug?: SortOrder
    subregion?: SubRegionOrderByRelationAggregateInput
    labels?: LabelOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionWhereUniqueInput = {
    id?: string
  }

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    state_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubRegionWhereInput = {
    AND?: Enumerable<SubRegionWhereInput>
    OR?: Enumerable<SubRegionWhereInput>
    NOT?: Enumerable<SubRegionWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    region_id?: StringFilter | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SubRegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionWhereUniqueInput = {
    id?: string
    name?: string
    slug?: string
  }

  export type SubRegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubRegionCountOrderByAggregateInput
    _max?: SubRegionMaxOrderByAggregateInput
    _min?: SubRegionMinOrderByAggregateInput
  }

  export type SubRegionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubRegionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubRegionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubRegionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    region_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WineTypeWhereInput = {
    AND?: Enumerable<WineTypeWhereInput>
    OR?: Enumerable<WineTypeWhereInput>
    NOT?: Enumerable<WineTypeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    labels?: LabelListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type WineTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    labels?: LabelOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeWhereUniqueInput = {
    id?: string
  }

  export type WineTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WineTypeCountOrderByAggregateInput
    _max?: WineTypeMaxOrderByAggregateInput
    _min?: WineTypeMinOrderByAggregateInput
  }

  export type WineTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WineTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<WineTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WineTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    total?: FloatFilter | number
    coupon_id?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    order_label?: OrderLabelListRelationFilter
    invoice?: InvoiceListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    total?: SortOrder
    coupon_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    order_label?: OrderLabelOrderByRelationAggregateInput
    invoice?: InvoiceOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    total?: FloatWithAggregatesFilter | number
    coupon_id?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderLabelWhereInput = {
    AND?: Enumerable<OrderLabelWhereInput>
    OR?: Enumerable<OrderLabelWhereInput>
    NOT?: Enumerable<OrderLabelWhereInput>
    order_id?: StringFilter | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    label_id?: StringFilter | string
    label?: XOR<LabelRelationFilter, LabelWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    quantity?: IntFilter | number
  }

  export type OrderLabelOrderByWithRelationInput = {
    order_id?: SortOrder
    order?: OrderOrderByWithRelationInput
    label_id?: SortOrder
    label?: LabelOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
    quantity?: SortOrder
  }

  export type OrderLabelWhereUniqueInput = {
    order_id_label_id?: OrderLabelOrder_idLabel_idCompoundUniqueInput
  }

  export type OrderLabelOrderByWithAggregationInput = {
    order_id?: SortOrder
    label_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    quantity?: SortOrder
    _count?: OrderLabelCountOrderByAggregateInput
    _avg?: OrderLabelAvgOrderByAggregateInput
    _max?: OrderLabelMaxOrderByAggregateInput
    _min?: OrderLabelMinOrderByAggregateInput
    _sum?: OrderLabelSumOrderByAggregateInput
  }

  export type OrderLabelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderLabelScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderLabelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderLabelScalarWhereWithAggregatesInput>
    order_id?: StringWithAggregatesFilter | string
    label_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    quantity?: IntWithAggregatesFilter | number
  }

  export type InvoiceWhereInput = {
    AND?: Enumerable<InvoiceWhereInput>
    OR?: Enumerable<InvoiceWhereInput>
    NOT?: Enumerable<InvoiceWhereInput>
    id?: StringFilter | string
    order_id?: StringFilter | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    order?: OrderOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceWhereUniqueInput = {
    id?: string
  }

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    order_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DeviceWhereInput = {
    AND?: Enumerable<DeviceWhereInput>
    OR?: Enumerable<DeviceWhereInput>
    NOT?: Enumerable<DeviceWhereInput>
    id?: StringFilter | string
    device_physical_id?: StringFilter | string
    platform?: EnumPlatformTypeFilter | PlatformType
    version?: StringFilter | string
    token_notification?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    device_user?: DeviceUserListRelationFilter
    push_notification?: PushNotificationListRelationFilter
    sms_notification?: SmsNotificationListRelationFilter
    device_notification?: DeviceNotificationListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    device_user?: DeviceUserOrderByRelationAggregateInput
    push_notification?: PushNotificationOrderByRelationAggregateInput
    sms_notification?: SmsNotificationOrderByRelationAggregateInput
    device_notification?: DeviceNotificationOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = {
    id?: string
    device_physical_id?: string
  }

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    device_physical_id?: StringWithAggregatesFilter | string
    platform?: EnumPlatformTypeWithAggregatesFilter | PlatformType
    version?: StringWithAggregatesFilter | string
    token_notification?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DeviceUserWhereInput = {
    AND?: Enumerable<DeviceUserWhereInput>
    OR?: Enumerable<DeviceUserWhereInput>
    NOT?: Enumerable<DeviceUserWhereInput>
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceUserOrderByWithRelationInput = {
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceUserWhereUniqueInput = {
    device_id_user_id?: DeviceUserDevice_idUser_idCompoundUniqueInput
  }

  export type DeviceUserOrderByWithAggregationInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeviceUserCountOrderByAggregateInput
    _max?: DeviceUserMaxOrderByAggregateInput
    _min?: DeviceUserMinOrderByAggregateInput
  }

  export type DeviceUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeviceUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeviceUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeviceUserScalarWhereWithAggregatesInput>
    device_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NotificationsWhereInput = {
    AND?: Enumerable<NotificationsWhereInput>
    OR?: Enumerable<NotificationsWhereInput>
    NOT?: Enumerable<NotificationsWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    message?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    type?: EnumTypeNotificationFilter | TypeNotification
    sms_notification?: SmsNotificationListRelationFilter
    email_notification?: EmailNotificationListRelationFilter
    push_notification?: PushNotificationListRelationFilter
    device_notification?: DeviceNotificationListRelationFilter
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    sms_notification?: SmsNotificationOrderByRelationAggregateInput
    email_notification?: EmailNotificationOrderByRelationAggregateInput
    push_notification?: PushNotificationOrderByRelationAggregateInput
    device_notification?: DeviceNotificationOrderByRelationAggregateInput
  }

  export type NotificationsWhereUniqueInput = {
    id?: string
  }

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumTypeNotificationWithAggregatesFilter | TypeNotification
  }

  export type EmailNotificationWhereInput = {
    AND?: Enumerable<EmailNotificationWhereInput>
    OR?: Enumerable<EmailNotificationWhereInput>
    NOT?: Enumerable<EmailNotificationWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    to?: StringFilter | string
    from?: StringFilter | string
    from_name?: StringFilter | string
    cc?: StringNullableFilter | string | null
    bcc?: StringNullableFilter | string | null
    type?: EnumEmailTypeNotificationFilter | EmailTypeNotification
    subject?: StringFilter | string
    body?: StringFilter | string
    url_callback?: StringFilter | string
    opened?: StringNullableFilter | string | null
    clicked?: StringNullableFilter | string | null
    failed?: StringNullableFilter | string | null
    error_description?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type EmailNotificationOrderByWithRelationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmailNotificationWhereUniqueInput = {
    id?: string
  }

  export type EmailNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: EmailNotificationCountOrderByAggregateInput
    _max?: EmailNotificationMaxOrderByAggregateInput
    _min?: EmailNotificationMinOrderByAggregateInput
  }

  export type EmailNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmailNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmailNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmailNotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    to?: StringWithAggregatesFilter | string
    from?: StringWithAggregatesFilter | string
    from_name?: StringWithAggregatesFilter | string
    cc?: StringNullableWithAggregatesFilter | string | null
    bcc?: StringNullableWithAggregatesFilter | string | null
    type?: EnumEmailTypeNotificationWithAggregatesFilter | EmailTypeNotification
    subject?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    url_callback?: StringWithAggregatesFilter | string
    opened?: StringNullableWithAggregatesFilter | string | null
    clicked?: StringNullableWithAggregatesFilter | string | null
    failed?: StringNullableWithAggregatesFilter | string | null
    error_description?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SmsNotificationWhereInput = {
    AND?: Enumerable<SmsNotificationWhereInput>
    OR?: Enumerable<SmsNotificationWhereInput>
    NOT?: Enumerable<SmsNotificationWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    to?: StringFilter | string
    subject?: StringFilter | string
    body?: StringFilter | string
    send?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SmsNotificationOrderByWithRelationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SmsNotificationWhereUniqueInput = {
    id?: string
  }

  export type SmsNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SmsNotificationCountOrderByAggregateInput
    _max?: SmsNotificationMaxOrderByAggregateInput
    _min?: SmsNotificationMinOrderByAggregateInput
  }

  export type SmsNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SmsNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<SmsNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SmsNotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    device_id?: StringWithAggregatesFilter | string
    to?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    send?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PushNotificationWhereInput = {
    AND?: Enumerable<PushNotificationWhereInput>
    OR?: Enumerable<PushNotificationWhereInput>
    NOT?: Enumerable<PushNotificationWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    title?: StringFilter | string
    subject?: StringFilter | string
    send?: StringNullableFilter | string | null
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PushNotificationOrderByWithRelationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationWhereUniqueInput = {
    id?: string
  }

  export type PushNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PushNotificationCountOrderByAggregateInput
    _max?: PushNotificationMaxOrderByAggregateInput
    _min?: PushNotificationMinOrderByAggregateInput
  }

  export type PushNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PushNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<PushNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PushNotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    send?: StringNullableWithAggregatesFilter | string | null
    device_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DeviceNotificationWhereInput = {
    AND?: Enumerable<DeviceNotificationWhereInput>
    OR?: Enumerable<DeviceNotificationWhereInput>
    NOT?: Enumerable<DeviceNotificationWhereInput>
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceNotificationOrderByWithRelationInput = {
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationWhereUniqueInput = {
    device_id_notification_id?: DeviceNotificationDevice_idNotification_idCompoundUniqueInput
  }

  export type DeviceNotificationOrderByWithAggregationInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeviceNotificationCountOrderByAggregateInput
    _max?: DeviceNotificationMaxOrderByAggregateInput
    _min?: DeviceNotificationMinOrderByAggregateInput
  }

  export type DeviceNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeviceNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeviceNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeviceNotificationScalarWhereWithAggregatesInput>
    device_id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PlanWhereInput = {
    AND?: Enumerable<PlanWhereInput>
    OR?: Enumerable<PlanWhereInput>
    NOT?: Enumerable<PlanWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    slug?: StringFilter | string
    price?: FloatFilter | number
    max_users?: IntFilter | number
    max_labels?: IntFilter | number
    payment_cycle_id?: StringFilter | string
    payment_cycle?: XOR<PaymentCycleRelationFilter, PaymentCycleWhereInput>
    account?: AccountListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    subscription?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    payment_cycle?: PaymentCycleOrderByWithRelationInput
    account?: AccountOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
    subscription?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = {
    id?: string
  }

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlanScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlanScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    max_users?: IntWithAggregatesFilter | number
    max_labels?: IntWithAggregatesFilter | number
    payment_cycle_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PaymentCycleWhereInput = {
    AND?: Enumerable<PaymentCycleWhereInput>
    OR?: Enumerable<PaymentCycleWhereInput>
    NOT?: Enumerable<PaymentCycleWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    plans?: PlanListRelationFilter
  }

  export type PaymentCycleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plans?: PlanOrderByRelationAggregateInput
  }

  export type PaymentCycleWhereUniqueInput = {
    id?: string
  }

  export type PaymentCycleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PaymentCycleCountOrderByAggregateInput
    _max?: PaymentCycleMaxOrderByAggregateInput
    _min?: PaymentCycleMinOrderByAggregateInput
  }

  export type PaymentCycleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentCycleScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentCycleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentCycleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: Enumerable<SubscriptionWhereInput>
    OR?: Enumerable<SubscriptionWhereInput>
    NOT?: Enumerable<SubscriptionWhereInput>
    id?: StringFilter | string
    plan_id?: StringFilter | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    due?: DateTimeFilter | Date | string
    price?: FloatFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    plan?: PlanOrderByWithRelationInput
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionWhereUniqueInput = {
    id?: string
  }

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    plan_id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    due?: DateTimeWithAggregatesFilter | Date | string
    price?: FloatWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StockLabelWhereInput = {
    AND?: Enumerable<StockLabelWhereInput>
    OR?: Enumerable<StockLabelWhereInput>
    NOT?: Enumerable<StockLabelWhereInput>
    label_id?: StringFilter | string
    labels?: XOR<LabelRelationFilter, LabelWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    min_quantity?: IntFilter | number
    max_quantity?: IntFilter | number
  }

  export type StockLabelOrderByWithRelationInput = {
    label_id?: SortOrder
    labels?: LabelOrderByWithRelationInput
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockLabelWhereUniqueInput = {
    label_id_account_id?: StockLabelLabel_idAccount_idCompoundUniqueInput
  }

  export type StockLabelOrderByWithAggregationInput = {
    label_id?: SortOrder
    account_id?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
    _count?: StockLabelCountOrderByAggregateInput
    _avg?: StockLabelAvgOrderByAggregateInput
    _max?: StockLabelMaxOrderByAggregateInput
    _min?: StockLabelMinOrderByAggregateInput
    _sum?: StockLabelSumOrderByAggregateInput
  }

  export type StockLabelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StockLabelScalarWhereWithAggregatesInput>
    OR?: Enumerable<StockLabelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StockLabelScalarWhereWithAggregatesInput>
    label_id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    min_quantity?: IntWithAggregatesFilter | number
    max_quantity?: IntWithAggregatesFilter | number
  }

  export type StockHistoryWhereInput = {
    AND?: Enumerable<StockHistoryWhereInput>
    OR?: Enumerable<StockHistoryWhereInput>
    NOT?: Enumerable<StockHistoryWhereInput>
    id?: StringFilter | string
    label_id?: StringFilter | string
    labels?: XOR<LabelRelationFilter, LabelWhereInput>
    reason?: StringFilter | string
    quantity?: IntFilter | number
    date?: DateTimeFilter | Date | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StockHistoryOrderByWithRelationInput = {
    id?: SortOrder
    label_id?: SortOrder
    labels?: LabelOrderByWithRelationInput
    reason?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistoryWhereUniqueInput = {
    id?: string
  }

  export type StockHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    label_id?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StockHistoryCountOrderByAggregateInput
    _avg?: StockHistoryAvgOrderByAggregateInput
    _max?: StockHistoryMaxOrderByAggregateInput
    _min?: StockHistoryMinOrderByAggregateInput
    _sum?: StockHistorySumOrderByAggregateInput
  }

  export type StockHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StockHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<StockHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StockHistoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    label_id?: StringWithAggregatesFilter | string
    reason?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateManyInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    domain: string
    isActive?: boolean
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountConfigurationCreateInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_configurationInput
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUncheckedCreateInput = {
    id?: string
    account_id: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_configurationNestedInput
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationCreateManyInput = {
    id?: string
    account_id: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountActivitiesCreateInput = {
    account: AccountCreateNestedOneWithoutAccount_activitiesInput
    activities: ActivitiesCreateNestedOneWithoutAccount_activitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUncheckedCreateInput = {
    account_id: string
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUpdateInput = {
    account?: AccountUpdateOneRequiredWithoutAccount_activitiesNestedInput
    activities?: ActivitiesUpdateOneRequiredWithoutAccount_activitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesCreateManyInput = {
    account_id: string
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateManyInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivitiesCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesCreateNestedManyWithoutActivitiesInput
  }

  export type ActivitiesUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivitiesCreateManyInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    city: string
    zipcode: string
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutUserInput
    account_user?: AccountUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    city: string
    zipcode: string
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    account_user?: AccountUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    city: string
    zipcode: string
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserCreateInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_usersInput
    user: UserCreateNestedOneWithoutAccount_userInput
    role: RoleCreateNestedOneWithoutAccountUserInput
    campaigns?: CampaignCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserUncheckedCreateInput = {
    id?: string
    account_id: string
    user_id: string
    role_id: string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_usersNestedInput
    user?: UserUpdateOneRequiredWithoutAccount_userNestedInput
    role?: RoleUpdateOneRequiredWithoutAccountUserNestedInput
    campaigns?: CampaignUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    campaigns?: CampaignUncheckedUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserCreateManyInput = {
    id?: string
    account_id: string
    user_id: string
    role_id: string
  }

  export type AccountUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type PermisionCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermisionUncheckedCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermisionCreateManyInput = {
    id?: string
    name: string
  }

  export type PermisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateInput = {
    role: RoleCreateNestedOneWithoutRolePermissionInput
    permission: PermisionCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateInput = {
    role_id: string
    permission_id: string
  }

  export type RolePermissionUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionNestedInput
    permission?: PermisionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    permission_id?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyInput = {
    role_id: string
    permission_id: string
  }

  export type RolePermissionUpdateManyMutationInput = {

  }

  export type RolePermissionUncheckedUpdateManyInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    permission_id?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionCreateNestedManyWithoutRoleInput
    AccountUser?: AccountUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    AccountUser?: AccountUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUpdateManyWithoutRoleNestedInput
    AccountUser?: AccountUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    AccountUser?: AccountUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    account: AccountCreateNestedOneWithoutCampaignInput
    account_user: AccountUserCreateNestedOneWithoutCampaignsInput
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    type_id: string
    account_id: string
    account_user_id: string
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    account_user?: AccountUserUpdateOneRequiredWithoutCampaignsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    account_user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    type_id: string
    account_id: string
    account_user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    account_user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTypeCreateInput = {
    id?: string
    name: string
    slug: string
    Campaign?: CampaignCreateNestedManyWithoutCampaign_typeInput
  }

  export type CampaignTypeUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    Campaign?: CampaignUncheckedCreateNestedManyWithoutCampaign_typeInput
  }

  export type CampaignTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Campaign?: CampaignUpdateManyWithoutCampaign_typeNestedInput
  }

  export type CampaignTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Campaign?: CampaignUncheckedUpdateManyWithoutCampaign_typeNestedInput
  }

  export type CampaignTypeCreateManyInput = {
    id?: string
    name: string
    slug: string
  }

  export type CampaignTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type LabelCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCampaignCreateInput = {
    label: LabelCreateNestedOneWithoutLabel_campaignInput
    campaign: CampaignCreateNestedOneWithoutLabel_campaignInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignUncheckedCreateInput = {
    label_id: string
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignUpdateInput = {
    label?: LabelUpdateOneRequiredWithoutLabel_campaignNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutLabel_campaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCampaignUncheckedUpdateInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCampaignCreateManyInput = {
    label_id: string
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCampaignUncheckedUpdateManyInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeCreateInput = {
    label: LabelCreateNestedOneWithoutLabel_grapeInput
    grape: GrapeCreateNestedOneWithoutLabelGrapeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeUncheckedCreateInput = {
    label_id: string
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeUpdateInput = {
    label?: LabelUpdateOneRequiredWithoutLabel_grapeNestedInput
    grape?: GrapeUpdateOneRequiredWithoutLabelGrapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeUncheckedUpdateInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeCreateManyInput = {
    label_id: string
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeUncheckedUpdateManyInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeCreateInput = {
    id?: string
    name: string
    LabelGrape?: LabelGrapeCreateNestedManyWithoutGrapeInput
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUncheckedCreateInput = {
    id?: string
    name: string
    LabelGrape?: LabelGrapeUncheckedCreateNestedManyWithoutGrapeInput
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    LabelGrape?: LabelGrapeUpdateManyWithoutGrapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    LabelGrape?: LabelGrapeUncheckedUpdateManyWithoutGrapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelTypeCreateInput = {
    id?: string
    name: string
    labels?: LabelCreateNestedManyWithoutLabelTypeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelTypeUncheckedCreateInput = {
    id?: string
    name: string
    labels?: LabelUncheckedCreateNestedManyWithoutLabelTypeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateManyWithoutLabelTypeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUncheckedUpdateManyWithoutLabelTypeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelTypeCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    slug: string
    value: string
    states?: StateCreateNestedManyWithoutCountryInput
    labels?: LabelCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    value: string
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
    labels?: LabelUncheckedCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUpdateManyWithoutCountryNestedInput
    labels?: LabelUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUncheckedUpdateManyWithoutCountryNestedInput
    labels?: LabelUncheckedUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    slug: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateInput = {
    id?: string
    name: string
    slug: string
    country: CountryCreateNestedOneWithoutStatesInput
    regions?: RegionCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    country_id: string
    regions?: RegionUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    regions?: RegionUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    regions?: RegionUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateManyInput = {
    id?: string
    name: string
    slug: string
    country_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    slug: string
    state: StateCreateNestedOneWithoutCitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    state_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    slug: string
    state_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateInput = {
    id?: string
    state: StateCreateNestedOneWithoutRegionsInput
    name: string
    slug: string
    subregion?: SubRegionCreateNestedManyWithoutRegionInput
    labels?: LabelCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateInput = {
    id?: string
    state_id: string
    name: string
    slug: string
    subregion?: SubRegionUncheckedCreateNestedManyWithoutRegionInput
    labels?: LabelUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutRegionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUpdateManyWithoutRegionNestedInput
    labels?: LabelUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUncheckedUpdateManyWithoutRegionNestedInput
    labels?: LabelUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateManyInput = {
    id?: string
    state_id: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionCreateInput = {
    id?: string
    name: string
    slug: string
    region: RegionCreateNestedOneWithoutSubregionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    region_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutSubregionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionCreateManyInput = {
    id?: string
    name: string
    slug: string
    region_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeCreateInput = {
    id?: string
    name: string
    slug: string
    labels?: LabelCreateNestedManyWithoutWine_typeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    labels?: LabelUncheckedCreateNestedManyWithoutWine_typeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateManyWithoutWine_typeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    labels?: LabelUncheckedUpdateManyWithoutWine_typeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeCreateManyInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    code: string
    account_id: string
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    code: string
    account_id: string
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderLabelCreateInput = {
    order: OrderCreateNestedOneWithoutOrder_labelInput
    label: LabelCreateNestedOneWithoutOrder_labelInput
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type OrderLabelUncheckedCreateInput = {
    order_id: string
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type OrderLabelUpdateInput = {
    order?: OrderUpdateOneRequiredWithoutOrder_labelNestedInput
    label?: LabelUpdateOneRequiredWithoutOrder_labelNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderLabelUncheckedUpdateInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderLabelCreateManyInput = {
    order_id: string
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type OrderLabelUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderLabelUncheckedUpdateManyInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateInput = {
    id?: string
    order: OrderCreateNestedOneWithoutInvoiceInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateInput = {
    device: DeviceCreateNestedOneWithoutDevice_userInput
    user: UserCreateNestedOneWithoutDevice_userInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUncheckedCreateInput = {
    device_id: string
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUpdateInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_userNestedInput
    user?: UserUpdateOneRequiredWithoutDevice_userNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateManyInput = {
    device_id: string
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateManyInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsCreateManyInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
  }

  export type NotificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
  }

  export type EmailNotificationCreateInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutEmail_notificationInput
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUncheckedCreateInput = {
    id?: string
    notification_id: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutEmail_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationCreateManyInput = {
    id?: string
    notification_id: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationCreateInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutSms_notificationInput
    device: DeviceCreateNestedOneWithoutSms_notificationInput
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUncheckedCreateInput = {
    id?: string
    notification_id: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutSms_notificationNestedInput
    device?: DeviceUpdateOneRequiredWithoutSms_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationCreateManyInput = {
    id?: string
    notification_id: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationCreateInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutPush_notificationInput
    title: string
    subject: string
    send?: string | null
    device: DeviceCreateNestedOneWithoutPush_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUncheckedCreateInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutPush_notificationNestedInput
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutPush_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationCreateManyInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationCreateInput = {
    device: DeviceCreateNestedOneWithoutDevice_notificationInput
    notification: NotificationsCreateNestedOneWithoutDevice_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUncheckedCreateInput = {
    device_id: string
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUpdateInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_notificationNestedInput
    notification?: NotificationsUpdateOneRequiredWithoutDevice_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationCreateManyInput = {
    device_id: string
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateManyInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle: PaymentCycleCreateNestedOneWithoutPlansInput
    account?: AccountCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    account?: AccountUncheckedCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle?: PaymentCycleUpdateOneRequiredWithoutPlansNestedInput
    account?: AccountUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    account?: AccountUncheckedUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCycleCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    plans?: PlanCreateNestedManyWithoutPayment_cycleInput
  }

  export type PaymentCycleUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    plans?: PlanUncheckedCreateNestedManyWithoutPayment_cycleInput
  }

  export type PaymentCycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUpdateManyWithoutPayment_cycleNestedInput
  }

  export type PaymentCycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUncheckedUpdateManyWithoutPayment_cycleNestedInput
  }

  export type PaymentCycleCreateManyInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: PlanCreateNestedOneWithoutSubscriptionInput
    account: AccountCreateNestedOneWithoutSubscriptionInput
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    plan_id: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
    account?: AccountUpdateOneRequiredWithoutSubscriptionNestedInput
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    plan_id: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLabelCreateInput = {
    labels: LabelCreateNestedOneWithoutStockLabelInput
    account: AccountCreateNestedOneWithoutStockLabelInput
    min_quantity: number
    max_quantity: number
  }

  export type StockLabelUncheckedCreateInput = {
    label_id: string
    account_id: string
    min_quantity: number
    max_quantity: number
  }

  export type StockLabelUpdateInput = {
    labels?: LabelUpdateOneRequiredWithoutStockLabelNestedInput
    account?: AccountUpdateOneRequiredWithoutStockLabelNestedInput
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockLabelUncheckedUpdateInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockLabelCreateManyInput = {
    label_id: string
    account_id: string
    min_quantity: number
    max_quantity: number
  }

  export type StockLabelUpdateManyMutationInput = {
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockLabelUncheckedUpdateManyInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockHistoryCreateInput = {
    id?: string
    labels: LabelCreateNestedOneWithoutStockHistoryInput
    reason: string
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUncheckedCreateInput = {
    id?: string
    label_id: string
    reason: string
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateOneRequiredWithoutStockHistoryNestedInput
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryCreateManyInput = {
    id?: string
    label_id: string
    reason: string
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label_id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumPersonTypeFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeFilter | PersonType
  }

  export type EnumGenderTypeFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeFilter | GenderType
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type AccountActivitiesListRelationFilter = {
    every?: AccountActivitiesWhereInput
    some?: AccountActivitiesWhereInput
    none?: AccountActivitiesWhereInput
  }

  export type AccountUserListRelationFilter = {
    every?: AccountUserWhereInput
    some?: AccountUserWhereInput
    none?: AccountUserWhereInput
  }

  export type StockLabelListRelationFilter = {
    every?: StockLabelWhereInput
    some?: StockLabelWhereInput
    none?: StockLabelWhereInput
  }

  export type AccountConfigurationRelationFilter = {
    is?: AccountConfigurationWhereInput | null
    isNot?: AccountConfigurationWhereInput | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountActivitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockLabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumPersonTypeWithAggregatesFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeWithAggregatesFilter | PersonType
    _count?: NestedIntFilter
    _min?: NestedEnumPersonTypeFilter
    _max?: NestedEnumPersonTypeFilter
  }

  export type EnumGenderTypeWithAggregatesFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeWithAggregatesFilter | GenderType
    _count?: NestedIntFilter
    _min?: NestedEnumGenderTypeFilter
    _max?: NestedEnumGenderTypeFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type AccountConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type AccountConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type ActivitiesRelationFilter = {
    is?: ActivitiesWhereInput
    isNot?: ActivitiesWhereInput
  }

  export type AccountActivitiesAccount_idActivities_idCompoundUniqueInput = {
    account_id: string
    activities_id: string
  }

  export type AccountActivitiesCountOrderByAggregateInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountActivitiesMaxOrderByAggregateInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountActivitiesMinOrderByAggregateInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DeviceUserListRelationFilter = {
    every?: DeviceUserWhereInput
    some?: DeviceUserWhereInput
    none?: DeviceUserWhereInput
  }

  export type DeviceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    country?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    city?: SortOrder
    zipcode?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type AccountUserAccount_idUser_idIdCompoundUniqueInput = {
    account_id: string
    user_id: string
    id: string
  }

  export type AccountUserCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type AccountUserMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type AccountUserMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermisionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermisionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermisionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermisionRelationFilter = {
    is?: PermisionWhereInput
    isNot?: PermisionWhereInput
  }

  export type RolePermissionRole_idPermission_idCompoundUniqueInput = {
    role_id: string
    permission_id: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type CampaignTypeRelationFilter = {
    is?: CampaignTypeWhereInput
    isNot?: CampaignTypeWhereInput
  }

  export type AccountUserRelationFilter = {
    is?: AccountUserWhereInput
    isNot?: AccountUserWhereInput
  }

  export type LabelCampaignListRelationFilter = {
    every?: LabelCampaignWhereInput
    some?: LabelCampaignWhereInput
    none?: LabelCampaignWhereInput
  }

  export type LabelCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    percentage_discount?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    type_id?: SortOrder
    account_id?: SortOrder
    account_user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    percentage_discount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    percentage_discount?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    type_id?: SortOrder
    account_id?: SortOrder
    account_user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    percentage_discount?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    type_id?: SortOrder
    account_id?: SortOrder
    account_user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    percentage_discount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type CampaignTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CampaignTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CampaignTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type EnumCouponDiscountTypeFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeFilter | CouponDiscountType
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type EnumCouponUseTypeFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeFilter | CouponUseType
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    discount_value?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    discount_value?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
  }

  export type EnumCouponDiscountTypeWithAggregatesFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeWithAggregatesFilter | CouponDiscountType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponDiscountTypeFilter
    _max?: NestedEnumCouponDiscountTypeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type EnumCouponUseTypeWithAggregatesFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeWithAggregatesFilter | CouponUseType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponUseTypeFilter
    _max?: NestedEnumCouponUseTypeFilter
  }

  export type LabelTypeRelationFilter = {
    is?: LabelTypeWhereInput
    isNot?: LabelTypeWhereInput
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type WineTypeRelationFilter = {
    is?: WineTypeWhereInput
    isNot?: WineTypeWhereInput
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type LabelGrapeListRelationFilter = {
    every?: LabelGrapeWhereInput
    some?: LabelGrapeWhereInput
    none?: LabelGrapeWhereInput
  }

  export type OrderLabelListRelationFilter = {
    every?: OrderLabelWhereInput
    some?: OrderLabelWhereInput
    none?: OrderLabelWhereInput
  }

  export type StockHistoryListRelationFilter = {
    every?: StockHistoryWhereInput
    some?: StockHistoryWhereInput
    none?: StockHistoryWhereInput
  }

  export type LabelGrapeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderLabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    is_active?: SortOrder
    stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelAvgOrderByAggregateInput = {
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    is_active?: SortOrder
    stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    is_active?: SortOrder
    stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelSumOrderByAggregateInput = {
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type LabelRelationFilter = {
    is?: LabelWhereInput
    isNot?: LabelWhereInput
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type LabelCampaignLabel_idCampaign_idCompoundUniqueInput = {
    label_id: string
    campaign_id: string
  }

  export type LabelCampaignCountOrderByAggregateInput = {
    label_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelCampaignMaxOrderByAggregateInput = {
    label_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelCampaignMinOrderByAggregateInput = {
    label_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GrapeRelationFilter = {
    is?: GrapeWhereInput
    isNot?: GrapeWhereInput
  }

  export type LabelGrapeLabel_idGrape_idCompoundUniqueInput = {
    label_id: string
    grape_id: string
  }

  export type LabelGrapeCountOrderByAggregateInput = {
    label_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelGrapeMaxOrderByAggregateInput = {
    label_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelGrapeMinOrderByAggregateInput = {
    label_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GrapeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrapeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrapeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabelListRelationFilter = {
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
  }

  export type LabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LabelTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateListRelationFilter = {
    every?: StateWhereInput
    some?: StateWhereInput
    none?: StateWhereInput
  }

  export type StateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionListRelationFilter = {
    every?: RegionWhereInput
    some?: RegionWhereInput
    none?: RegionWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type RegionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionListRelationFilter = {
    every?: SubRegionWhereInput
    some?: SubRegionWhereInput
    none?: SubRegionWhereInput
  }

  export type SubRegionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    total?: SortOrder
    coupon_id?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    total?: SortOrder
    coupon_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderLabelOrder_idLabel_idCompoundUniqueInput = {
    order_id: string
    label_id: string
  }

  export type OrderLabelCountOrderByAggregateInput = {
    order_id?: SortOrder
    label_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    quantity?: SortOrder
  }

  export type OrderLabelAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OrderLabelMaxOrderByAggregateInput = {
    order_id?: SortOrder
    label_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    quantity?: SortOrder
  }

  export type OrderLabelMinOrderByAggregateInput = {
    order_id?: SortOrder
    label_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    quantity?: SortOrder
  }

  export type OrderLabelSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumPlatformTypeFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeFilter | PlatformType
  }

  export type PushNotificationListRelationFilter = {
    every?: PushNotificationWhereInput
    some?: PushNotificationWhereInput
    none?: PushNotificationWhereInput
  }

  export type SmsNotificationListRelationFilter = {
    every?: SmsNotificationWhereInput
    some?: SmsNotificationWhereInput
    none?: SmsNotificationWhereInput
  }

  export type DeviceNotificationListRelationFilter = {
    every?: DeviceNotificationWhereInput
    some?: DeviceNotificationWhereInput
    none?: DeviceNotificationWhereInput
  }

  export type PushNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SmsNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumPlatformTypeWithAggregatesFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeWithAggregatesFilter | PlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumPlatformTypeFilter
    _max?: NestedEnumPlatformTypeFilter
  }

  export type DeviceRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type DeviceUserDevice_idUser_idCompoundUniqueInput = {
    device_id: string
    user_id: string
  }

  export type DeviceUserCountOrderByAggregateInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceUserMaxOrderByAggregateInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceUserMinOrderByAggregateInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumTypeNotificationFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationFilter | TypeNotification
  }

  export type EmailNotificationListRelationFilter = {
    every?: EmailNotificationWhereInput
    some?: EmailNotificationWhereInput
    none?: EmailNotificationWhereInput
  }

  export type EmailNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
  }

  export type EnumTypeNotificationWithAggregatesFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationWithAggregatesFilter | TypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumTypeNotificationFilter
    _max?: NestedEnumTypeNotificationFilter
  }

  export type NotificationsRelationFilter = {
    is?: NotificationsWhereInput
    isNot?: NotificationsWhereInput
  }

  export type EnumEmailTypeNotificationFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationFilter | EmailTypeNotification
  }

  export type EmailNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmailNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmailNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumEmailTypeNotificationWithAggregatesFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationWithAggregatesFilter | EmailTypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumEmailTypeNotificationFilter
    _max?: NestedEnumEmailTypeNotificationFilter
  }

  export type SmsNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SmsNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SmsNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationDevice_idNotification_idCompoundUniqueInput = {
    device_id: string
    notification_id: string
  }

  export type DeviceNotificationCountOrderByAggregateInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationMaxOrderByAggregateInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationMinOrderByAggregateInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentCycleRelationFilter = {
    is?: PaymentCycleWhereInput
    isNot?: PaymentCycleWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCycleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentCycleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentCycleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type StockLabelLabel_idAccount_idCompoundUniqueInput = {
    label_id: string
    account_id: string
  }

  export type StockLabelCountOrderByAggregateInput = {
    label_id?: SortOrder
    account_id?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockLabelAvgOrderByAggregateInput = {
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockLabelMaxOrderByAggregateInput = {
    label_id?: SortOrder
    account_id?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockLabelMinOrderByAggregateInput = {
    label_id?: SortOrder
    account_id?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockLabelSumOrderByAggregateInput = {
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    label_id?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    label_id?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    label_id?: SortOrder
    reason?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CampaignCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type PlanCreateNestedOneWithoutAccountInput = {
    create?: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
    connectOrCreate?: PlanCreateOrConnectWithoutAccountInput
    connect?: PlanWhereUniqueInput
  }

  export type SubscriptionCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AccountActivitiesCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountUserCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type StockLabelCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutAccountInput>, Enumerable<StockLabelUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutAccountInput>
    createMany?: StockLabelCreateManyAccountInputEnvelope
    connect?: Enumerable<StockLabelWhereUniqueInput>
  }

  export type AccountConfigurationCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    connect?: AccountConfigurationWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountUserUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type StockLabelUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutAccountInput>, Enumerable<StockLabelUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutAccountInput>
    createMany?: StockLabelCreateManyAccountInputEnvelope
    connect?: Enumerable<StockLabelWhereUniqueInput>
  }

  export type AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    connect?: AccountConfigurationWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPersonTypeFieldUpdateOperationsInput = {
    set?: PersonType
  }

  export type EnumGenderTypeFieldUpdateOperationsInput = {
    set?: GenderType
  }

  export type CampaignUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type PlanUpdateOneWithoutAccountNestedInput = {
    create?: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
    connectOrCreate?: PlanCreateOrConnectWithoutAccountInput
    upsert?: PlanUpsertWithoutAccountInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<PlanUpdateWithoutAccountInput, PlanUncheckedUpdateWithoutAccountInput>
  }

  export type SubscriptionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrderUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AccountActivitiesUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type AccountUserUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type StockLabelUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutAccountInput>, Enumerable<StockLabelUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<StockLabelUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: StockLabelCreateManyAccountInputEnvelope
    set?: Enumerable<StockLabelWhereUniqueInput>
    disconnect?: Enumerable<StockLabelWhereUniqueInput>
    delete?: Enumerable<StockLabelWhereUniqueInput>
    connect?: Enumerable<StockLabelWhereUniqueInput>
    update?: Enumerable<StockLabelUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<StockLabelUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<StockLabelScalarWhereInput>
  }

  export type AccountConfigurationUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    upsert?: AccountConfigurationUpsertWithoutAccountInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountConfigurationWhereUniqueInput
    update?: XOR<AccountConfigurationUpdateWithoutAccountInput, AccountConfigurationUncheckedUpdateWithoutAccountInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CampaignUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type AccountUserUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type StockLabelUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutAccountInput>, Enumerable<StockLabelUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<StockLabelUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: StockLabelCreateManyAccountInputEnvelope
    set?: Enumerable<StockLabelWhereUniqueInput>
    disconnect?: Enumerable<StockLabelWhereUniqueInput>
    delete?: Enumerable<StockLabelWhereUniqueInput>
    connect?: Enumerable<StockLabelWhereUniqueInput>
    update?: Enumerable<StockLabelUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<StockLabelUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<StockLabelScalarWhereInput>
  }

  export type AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    upsert?: AccountConfigurationUpsertWithoutAccountInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountConfigurationWhereUniqueInput
    update?: XOR<AccountConfigurationUpdateWithoutAccountInput, AccountConfigurationUncheckedUpdateWithoutAccountInput>
  }

  export type AccountCreateNestedOneWithoutAccount_configurationInput = {
    create?: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_configurationInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_configurationNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_configurationInput
    upsert?: AccountUpsertWithoutAccount_configurationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_configurationInput, AccountUncheckedUpdateWithoutAccount_configurationInput>
  }

  export type AccountCreateNestedOneWithoutAccount_activitiesInput = {
    create?: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_activitiesInput
    connect?: AccountWhereUniqueInput
  }

  export type ActivitiesCreateNestedOneWithoutAccount_activitiesInput = {
    create?: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: ActivitiesCreateOrConnectWithoutAccount_activitiesInput
    connect?: ActivitiesWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_activitiesNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_activitiesInput
    upsert?: AccountUpsertWithoutAccount_activitiesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_activitiesInput, AccountUncheckedUpdateWithoutAccount_activitiesInput>
  }

  export type ActivitiesUpdateOneRequiredWithoutAccount_activitiesNestedInput = {
    create?: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: ActivitiesCreateOrConnectWithoutAccount_activitiesInput
    upsert?: ActivitiesUpsertWithoutAccount_activitiesInput
    connect?: ActivitiesWhereUniqueInput
    update?: XOR<ActivitiesUpdateWithoutAccount_activitiesInput, ActivitiesUncheckedUpdateWithoutAccount_activitiesInput>
  }

  export type AccountActivitiesCreateNestedManyWithoutActivitiesInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountActivitiesUncheckedCreateNestedManyWithoutActivitiesInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountActivitiesUpdateManyWithoutActivitiesNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutActivitiesInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutActivitiesInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type AccountActivitiesUncheckedUpdateManyWithoutActivitiesNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutActivitiesInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutActivitiesInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type DeviceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type AccountUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type DeviceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type AccountUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DeviceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type AccountUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type DeviceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type AccountUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutAccount_usersInput = {
    create?: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_usersInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAccount_userInput = {
    create?: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccount_userInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutAccountUserInput = {
    create?: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAccountUserInput
    connect?: RoleWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutAccount_userInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccount_userInput>, Enumerable<CampaignUncheckedCreateWithoutAccount_userInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccount_userInput>
    createMany?: CampaignCreateManyAccount_userInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutAccount_userInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccount_userInput>, Enumerable<CampaignUncheckedCreateWithoutAccount_userInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccount_userInput>
    createMany?: CampaignCreateManyAccount_userInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type AccountUpdateOneRequiredWithoutAccount_usersNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_usersInput
    upsert?: AccountUpsertWithoutAccount_usersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_usersInput, AccountUncheckedUpdateWithoutAccount_usersInput>
  }

  export type UserUpdateOneRequiredWithoutAccount_userNestedInput = {
    create?: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccount_userInput
    upsert?: UserUpsertWithoutAccount_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccount_userInput, UserUncheckedUpdateWithoutAccount_userInput>
  }

  export type RoleUpdateOneRequiredWithoutAccountUserNestedInput = {
    create?: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAccountUserInput
    upsert?: RoleUpsertWithoutAccountUserInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutAccountUserInput, RoleUncheckedUpdateWithoutAccountUserInput>
  }

  export type CampaignUpdateManyWithoutAccount_userNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccount_userInput>, Enumerable<CampaignUncheckedCreateWithoutAccount_userInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccount_userInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAccount_userInput>
    createMany?: CampaignCreateManyAccount_userInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAccount_userInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAccount_userInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutAccount_userNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccount_userInput>, Enumerable<CampaignUncheckedCreateWithoutAccount_userInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccount_userInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAccount_userInput>
    createMany?: CampaignCreateManyAccount_userInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAccount_userInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAccount_userInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type RoleCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionInput
    connect?: RoleWhereUniqueInput
  }

  export type PermisionCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermisionCreateOrConnectWithoutRolePermissionInput
    connect?: PermisionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionInput
    upsert?: RoleUpsertWithoutRolePermissionInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutRolePermissionInput, RoleUncheckedUpdateWithoutRolePermissionInput>
  }

  export type PermisionUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermisionCreateOrConnectWithoutRolePermissionInput
    upsert?: PermisionUpsertWithoutRolePermissionInput
    connect?: PermisionWhereUniqueInput
    update?: XOR<PermisionUpdateWithoutRolePermissionInput, PermisionUncheckedUpdateWithoutRolePermissionInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type AccountUserCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type AccountUserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type AccountUserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type AccountUserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type CampaignTypeCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutCampaignInput
    connect?: CampaignTypeWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutCampaignInput = {
    create?: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCampaignInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<AccountUserCreateWithoutCampaignsInput, AccountUserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: AccountUserCreateOrConnectWithoutCampaignsInput
    connect?: AccountUserWhereUniqueInput
  }

  export type LabelCampaignCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutCampaignInput>, Enumerable<LabelCampaignUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutCampaignInput>
    createMany?: LabelCampaignCreateManyCampaignInputEnvelope
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
  }

  export type LabelCampaignUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutCampaignInput>, Enumerable<LabelCampaignUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutCampaignInput>
    createMany?: LabelCampaignCreateManyCampaignInputEnvelope
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutCampaignInput
    upsert?: CampaignTypeUpsertWithoutCampaignInput
    connect?: CampaignTypeWhereUniqueInput
    update?: XOR<CampaignTypeUpdateWithoutCampaignInput, CampaignTypeUncheckedUpdateWithoutCampaignInput>
  }

  export type AccountUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCampaignInput
    upsert?: AccountUpsertWithoutCampaignInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutCampaignInput, AccountUncheckedUpdateWithoutCampaignInput>
  }

  export type AccountUserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<AccountUserCreateWithoutCampaignsInput, AccountUserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: AccountUserCreateOrConnectWithoutCampaignsInput
    upsert?: AccountUserUpsertWithoutCampaignsInput
    connect?: AccountUserWhereUniqueInput
    update?: XOR<AccountUserUpdateWithoutCampaignsInput, AccountUserUncheckedUpdateWithoutCampaignsInput>
  }

  export type LabelCampaignUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutCampaignInput>, Enumerable<LabelCampaignUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<LabelCampaignUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: LabelCampaignCreateManyCampaignInputEnvelope
    set?: Enumerable<LabelCampaignWhereUniqueInput>
    disconnect?: Enumerable<LabelCampaignWhereUniqueInput>
    delete?: Enumerable<LabelCampaignWhereUniqueInput>
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
    update?: Enumerable<LabelCampaignUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<LabelCampaignUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<LabelCampaignScalarWhereInput>
  }

  export type LabelCampaignUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutCampaignInput>, Enumerable<LabelCampaignUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<LabelCampaignUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: LabelCampaignCreateManyCampaignInputEnvelope
    set?: Enumerable<LabelCampaignWhereUniqueInput>
    disconnect?: Enumerable<LabelCampaignWhereUniqueInput>
    delete?: Enumerable<LabelCampaignWhereUniqueInput>
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
    update?: Enumerable<LabelCampaignUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<LabelCampaignUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<LabelCampaignScalarWhereInput>
  }

  export type CampaignCreateNestedManyWithoutCampaign_typeInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutCampaign_typeInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignUpdateManyWithoutCampaign_typeNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutCampaign_typeInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutCampaign_typeInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutCampaign_typeNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutCampaign_typeInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutCampaign_typeInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type EnumCouponDiscountTypeFieldUpdateOperationsInput = {
    set?: CouponDiscountType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCouponUseTypeFieldUpdateOperationsInput = {
    set?: CouponUseType
  }

  export type LabelTypeCreateNestedOneWithoutLabelsInput = {
    create?: XOR<LabelTypeCreateWithoutLabelsInput, LabelTypeUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: LabelTypeCreateOrConnectWithoutLabelsInput
    connect?: LabelTypeWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutLabelsInput = {
    create?: XOR<CountryCreateWithoutLabelsInput, CountryUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutLabelsInput
    connect?: CountryWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutLabelsInput = {
    create?: XOR<RegionCreateWithoutLabelsInput, RegionUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutLabelsInput
    connect?: RegionWhereUniqueInput
  }

  export type WineTypeCreateNestedOneWithoutLabelsInput = {
    create?: XOR<WineTypeCreateWithoutLabelsInput, WineTypeUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: WineTypeCreateOrConnectWithoutLabelsInput
    connect?: WineTypeWhereUniqueInput
  }

  export type LabelGrapeCreateNestedManyWithoutLabelInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutLabelInput>, Enumerable<LabelGrapeUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutLabelInput>
    createMany?: LabelGrapeCreateManyLabelInputEnvelope
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
  }

  export type OrderLabelCreateNestedManyWithoutLabelInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutLabelInput>, Enumerable<OrderLabelUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutLabelInput>
    createMany?: OrderLabelCreateManyLabelInputEnvelope
    connect?: Enumerable<OrderLabelWhereUniqueInput>
  }

  export type LabelCampaignCreateNestedManyWithoutLabelInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutLabelInput>, Enumerable<LabelCampaignUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutLabelInput>
    createMany?: LabelCampaignCreateManyLabelInputEnvelope
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
  }

  export type StockLabelCreateNestedManyWithoutLabelsInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutLabelsInput>, Enumerable<StockLabelUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutLabelsInput>
    createMany?: StockLabelCreateManyLabelsInputEnvelope
    connect?: Enumerable<StockLabelWhereUniqueInput>
  }

  export type StockHistoryCreateNestedManyWithoutLabelsInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutLabelsInput>, Enumerable<StockHistoryUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutLabelsInput>
    createMany?: StockHistoryCreateManyLabelsInputEnvelope
    connect?: Enumerable<StockHistoryWhereUniqueInput>
  }

  export type LabelGrapeUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutLabelInput>, Enumerable<LabelGrapeUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutLabelInput>
    createMany?: LabelGrapeCreateManyLabelInputEnvelope
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
  }

  export type OrderLabelUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutLabelInput>, Enumerable<OrderLabelUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutLabelInput>
    createMany?: OrderLabelCreateManyLabelInputEnvelope
    connect?: Enumerable<OrderLabelWhereUniqueInput>
  }

  export type LabelCampaignUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutLabelInput>, Enumerable<LabelCampaignUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutLabelInput>
    createMany?: LabelCampaignCreateManyLabelInputEnvelope
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
  }

  export type StockLabelUncheckedCreateNestedManyWithoutLabelsInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutLabelsInput>, Enumerable<StockLabelUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutLabelsInput>
    createMany?: StockLabelCreateManyLabelsInputEnvelope
    connect?: Enumerable<StockLabelWhereUniqueInput>
  }

  export type StockHistoryUncheckedCreateNestedManyWithoutLabelsInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutLabelsInput>, Enumerable<StockHistoryUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutLabelsInput>
    createMany?: StockHistoryCreateManyLabelsInputEnvelope
    connect?: Enumerable<StockHistoryWhereUniqueInput>
  }

  export type LabelTypeUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<LabelTypeCreateWithoutLabelsInput, LabelTypeUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: LabelTypeCreateOrConnectWithoutLabelsInput
    upsert?: LabelTypeUpsertWithoutLabelsInput
    connect?: LabelTypeWhereUniqueInput
    update?: XOR<LabelTypeUpdateWithoutLabelsInput, LabelTypeUncheckedUpdateWithoutLabelsInput>
  }

  export type CountryUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<CountryCreateWithoutLabelsInput, CountryUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutLabelsInput
    upsert?: CountryUpsertWithoutLabelsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutLabelsInput, CountryUncheckedUpdateWithoutLabelsInput>
  }

  export type RegionUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<RegionCreateWithoutLabelsInput, RegionUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutLabelsInput
    upsert?: RegionUpsertWithoutLabelsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<RegionUpdateWithoutLabelsInput, RegionUncheckedUpdateWithoutLabelsInput>
  }

  export type WineTypeUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<WineTypeCreateWithoutLabelsInput, WineTypeUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: WineTypeCreateOrConnectWithoutLabelsInput
    upsert?: WineTypeUpsertWithoutLabelsInput
    connect?: WineTypeWhereUniqueInput
    update?: XOR<WineTypeUpdateWithoutLabelsInput, WineTypeUncheckedUpdateWithoutLabelsInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LabelGrapeUpdateManyWithoutLabelNestedInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutLabelInput>, Enumerable<LabelGrapeUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutLabelInput>
    upsert?: Enumerable<LabelGrapeUpsertWithWhereUniqueWithoutLabelInput>
    createMany?: LabelGrapeCreateManyLabelInputEnvelope
    set?: Enumerable<LabelGrapeWhereUniqueInput>
    disconnect?: Enumerable<LabelGrapeWhereUniqueInput>
    delete?: Enumerable<LabelGrapeWhereUniqueInput>
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
    update?: Enumerable<LabelGrapeUpdateWithWhereUniqueWithoutLabelInput>
    updateMany?: Enumerable<LabelGrapeUpdateManyWithWhereWithoutLabelInput>
    deleteMany?: Enumerable<LabelGrapeScalarWhereInput>
  }

  export type OrderLabelUpdateManyWithoutLabelNestedInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutLabelInput>, Enumerable<OrderLabelUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutLabelInput>
    upsert?: Enumerable<OrderLabelUpsertWithWhereUniqueWithoutLabelInput>
    createMany?: OrderLabelCreateManyLabelInputEnvelope
    set?: Enumerable<OrderLabelWhereUniqueInput>
    disconnect?: Enumerable<OrderLabelWhereUniqueInput>
    delete?: Enumerable<OrderLabelWhereUniqueInput>
    connect?: Enumerable<OrderLabelWhereUniqueInput>
    update?: Enumerable<OrderLabelUpdateWithWhereUniqueWithoutLabelInput>
    updateMany?: Enumerable<OrderLabelUpdateManyWithWhereWithoutLabelInput>
    deleteMany?: Enumerable<OrderLabelScalarWhereInput>
  }

  export type LabelCampaignUpdateManyWithoutLabelNestedInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutLabelInput>, Enumerable<LabelCampaignUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutLabelInput>
    upsert?: Enumerable<LabelCampaignUpsertWithWhereUniqueWithoutLabelInput>
    createMany?: LabelCampaignCreateManyLabelInputEnvelope
    set?: Enumerable<LabelCampaignWhereUniqueInput>
    disconnect?: Enumerable<LabelCampaignWhereUniqueInput>
    delete?: Enumerable<LabelCampaignWhereUniqueInput>
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
    update?: Enumerable<LabelCampaignUpdateWithWhereUniqueWithoutLabelInput>
    updateMany?: Enumerable<LabelCampaignUpdateManyWithWhereWithoutLabelInput>
    deleteMany?: Enumerable<LabelCampaignScalarWhereInput>
  }

  export type StockLabelUpdateManyWithoutLabelsNestedInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutLabelsInput>, Enumerable<StockLabelUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutLabelsInput>
    upsert?: Enumerable<StockLabelUpsertWithWhereUniqueWithoutLabelsInput>
    createMany?: StockLabelCreateManyLabelsInputEnvelope
    set?: Enumerable<StockLabelWhereUniqueInput>
    disconnect?: Enumerable<StockLabelWhereUniqueInput>
    delete?: Enumerable<StockLabelWhereUniqueInput>
    connect?: Enumerable<StockLabelWhereUniqueInput>
    update?: Enumerable<StockLabelUpdateWithWhereUniqueWithoutLabelsInput>
    updateMany?: Enumerable<StockLabelUpdateManyWithWhereWithoutLabelsInput>
    deleteMany?: Enumerable<StockLabelScalarWhereInput>
  }

  export type StockHistoryUpdateManyWithoutLabelsNestedInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutLabelsInput>, Enumerable<StockHistoryUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutLabelsInput>
    upsert?: Enumerable<StockHistoryUpsertWithWhereUniqueWithoutLabelsInput>
    createMany?: StockHistoryCreateManyLabelsInputEnvelope
    set?: Enumerable<StockHistoryWhereUniqueInput>
    disconnect?: Enumerable<StockHistoryWhereUniqueInput>
    delete?: Enumerable<StockHistoryWhereUniqueInput>
    connect?: Enumerable<StockHistoryWhereUniqueInput>
    update?: Enumerable<StockHistoryUpdateWithWhereUniqueWithoutLabelsInput>
    updateMany?: Enumerable<StockHistoryUpdateManyWithWhereWithoutLabelsInput>
    deleteMany?: Enumerable<StockHistoryScalarWhereInput>
  }

  export type LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutLabelInput>, Enumerable<LabelGrapeUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutLabelInput>
    upsert?: Enumerable<LabelGrapeUpsertWithWhereUniqueWithoutLabelInput>
    createMany?: LabelGrapeCreateManyLabelInputEnvelope
    set?: Enumerable<LabelGrapeWhereUniqueInput>
    disconnect?: Enumerable<LabelGrapeWhereUniqueInput>
    delete?: Enumerable<LabelGrapeWhereUniqueInput>
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
    update?: Enumerable<LabelGrapeUpdateWithWhereUniqueWithoutLabelInput>
    updateMany?: Enumerable<LabelGrapeUpdateManyWithWhereWithoutLabelInput>
    deleteMany?: Enumerable<LabelGrapeScalarWhereInput>
  }

  export type OrderLabelUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutLabelInput>, Enumerable<OrderLabelUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutLabelInput>
    upsert?: Enumerable<OrderLabelUpsertWithWhereUniqueWithoutLabelInput>
    createMany?: OrderLabelCreateManyLabelInputEnvelope
    set?: Enumerable<OrderLabelWhereUniqueInput>
    disconnect?: Enumerable<OrderLabelWhereUniqueInput>
    delete?: Enumerable<OrderLabelWhereUniqueInput>
    connect?: Enumerable<OrderLabelWhereUniqueInput>
    update?: Enumerable<OrderLabelUpdateWithWhereUniqueWithoutLabelInput>
    updateMany?: Enumerable<OrderLabelUpdateManyWithWhereWithoutLabelInput>
    deleteMany?: Enumerable<OrderLabelScalarWhereInput>
  }

  export type LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<Enumerable<LabelCampaignCreateWithoutLabelInput>, Enumerable<LabelCampaignUncheckedCreateWithoutLabelInput>>
    connectOrCreate?: Enumerable<LabelCampaignCreateOrConnectWithoutLabelInput>
    upsert?: Enumerable<LabelCampaignUpsertWithWhereUniqueWithoutLabelInput>
    createMany?: LabelCampaignCreateManyLabelInputEnvelope
    set?: Enumerable<LabelCampaignWhereUniqueInput>
    disconnect?: Enumerable<LabelCampaignWhereUniqueInput>
    delete?: Enumerable<LabelCampaignWhereUniqueInput>
    connect?: Enumerable<LabelCampaignWhereUniqueInput>
    update?: Enumerable<LabelCampaignUpdateWithWhereUniqueWithoutLabelInput>
    updateMany?: Enumerable<LabelCampaignUpdateManyWithWhereWithoutLabelInput>
    deleteMany?: Enumerable<LabelCampaignScalarWhereInput>
  }

  export type StockLabelUncheckedUpdateManyWithoutLabelsNestedInput = {
    create?: XOR<Enumerable<StockLabelCreateWithoutLabelsInput>, Enumerable<StockLabelUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockLabelCreateOrConnectWithoutLabelsInput>
    upsert?: Enumerable<StockLabelUpsertWithWhereUniqueWithoutLabelsInput>
    createMany?: StockLabelCreateManyLabelsInputEnvelope
    set?: Enumerable<StockLabelWhereUniqueInput>
    disconnect?: Enumerable<StockLabelWhereUniqueInput>
    delete?: Enumerable<StockLabelWhereUniqueInput>
    connect?: Enumerable<StockLabelWhereUniqueInput>
    update?: Enumerable<StockLabelUpdateWithWhereUniqueWithoutLabelsInput>
    updateMany?: Enumerable<StockLabelUpdateManyWithWhereWithoutLabelsInput>
    deleteMany?: Enumerable<StockLabelScalarWhereInput>
  }

  export type StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutLabelsInput>, Enumerable<StockHistoryUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutLabelsInput>
    upsert?: Enumerable<StockHistoryUpsertWithWhereUniqueWithoutLabelsInput>
    createMany?: StockHistoryCreateManyLabelsInputEnvelope
    set?: Enumerable<StockHistoryWhereUniqueInput>
    disconnect?: Enumerable<StockHistoryWhereUniqueInput>
    delete?: Enumerable<StockHistoryWhereUniqueInput>
    connect?: Enumerable<StockHistoryWhereUniqueInput>
    update?: Enumerable<StockHistoryUpdateWithWhereUniqueWithoutLabelsInput>
    updateMany?: Enumerable<StockHistoryUpdateManyWithWhereWithoutLabelsInput>
    deleteMany?: Enumerable<StockHistoryScalarWhereInput>
  }

  export type LabelCreateNestedOneWithoutLabel_campaignInput = {
    create?: XOR<LabelCreateWithoutLabel_campaignInput, LabelUncheckedCreateWithoutLabel_campaignInput>
    connectOrCreate?: LabelCreateOrConnectWithoutLabel_campaignInput
    connect?: LabelWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutLabel_campaignInput = {
    create?: XOR<CampaignCreateWithoutLabel_campaignInput, CampaignUncheckedCreateWithoutLabel_campaignInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLabel_campaignInput
    connect?: CampaignWhereUniqueInput
  }

  export type LabelUpdateOneRequiredWithoutLabel_campaignNestedInput = {
    create?: XOR<LabelCreateWithoutLabel_campaignInput, LabelUncheckedCreateWithoutLabel_campaignInput>
    connectOrCreate?: LabelCreateOrConnectWithoutLabel_campaignInput
    upsert?: LabelUpsertWithoutLabel_campaignInput
    connect?: LabelWhereUniqueInput
    update?: XOR<LabelUpdateWithoutLabel_campaignInput, LabelUncheckedUpdateWithoutLabel_campaignInput>
  }

  export type CampaignUpdateOneRequiredWithoutLabel_campaignNestedInput = {
    create?: XOR<CampaignCreateWithoutLabel_campaignInput, CampaignUncheckedCreateWithoutLabel_campaignInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLabel_campaignInput
    upsert?: CampaignUpsertWithoutLabel_campaignInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutLabel_campaignInput, CampaignUncheckedUpdateWithoutLabel_campaignInput>
  }

  export type LabelCreateNestedOneWithoutLabel_grapeInput = {
    create?: XOR<LabelCreateWithoutLabel_grapeInput, LabelUncheckedCreateWithoutLabel_grapeInput>
    connectOrCreate?: LabelCreateOrConnectWithoutLabel_grapeInput
    connect?: LabelWhereUniqueInput
  }

  export type GrapeCreateNestedOneWithoutLabelGrapeInput = {
    create?: XOR<GrapeCreateWithoutLabelGrapeInput, GrapeUncheckedCreateWithoutLabelGrapeInput>
    connectOrCreate?: GrapeCreateOrConnectWithoutLabelGrapeInput
    connect?: GrapeWhereUniqueInput
  }

  export type LabelUpdateOneRequiredWithoutLabel_grapeNestedInput = {
    create?: XOR<LabelCreateWithoutLabel_grapeInput, LabelUncheckedCreateWithoutLabel_grapeInput>
    connectOrCreate?: LabelCreateOrConnectWithoutLabel_grapeInput
    upsert?: LabelUpsertWithoutLabel_grapeInput
    connect?: LabelWhereUniqueInput
    update?: XOR<LabelUpdateWithoutLabel_grapeInput, LabelUncheckedUpdateWithoutLabel_grapeInput>
  }

  export type GrapeUpdateOneRequiredWithoutLabelGrapeNestedInput = {
    create?: XOR<GrapeCreateWithoutLabelGrapeInput, GrapeUncheckedCreateWithoutLabelGrapeInput>
    connectOrCreate?: GrapeCreateOrConnectWithoutLabelGrapeInput
    upsert?: GrapeUpsertWithoutLabelGrapeInput
    connect?: GrapeWhereUniqueInput
    update?: XOR<GrapeUpdateWithoutLabelGrapeInput, GrapeUncheckedUpdateWithoutLabelGrapeInput>
  }

  export type LabelGrapeCreateNestedManyWithoutGrapeInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutGrapeInput>, Enumerable<LabelGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutGrapeInput>
    createMany?: LabelGrapeCreateManyGrapeInputEnvelope
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
  }

  export type LabelGrapeUncheckedCreateNestedManyWithoutGrapeInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutGrapeInput>, Enumerable<LabelGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutGrapeInput>
    createMany?: LabelGrapeCreateManyGrapeInputEnvelope
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
  }

  export type LabelGrapeUpdateManyWithoutGrapeNestedInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutGrapeInput>, Enumerable<LabelGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutGrapeInput>
    upsert?: Enumerable<LabelGrapeUpsertWithWhereUniqueWithoutGrapeInput>
    createMany?: LabelGrapeCreateManyGrapeInputEnvelope
    set?: Enumerable<LabelGrapeWhereUniqueInput>
    disconnect?: Enumerable<LabelGrapeWhereUniqueInput>
    delete?: Enumerable<LabelGrapeWhereUniqueInput>
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
    update?: Enumerable<LabelGrapeUpdateWithWhereUniqueWithoutGrapeInput>
    updateMany?: Enumerable<LabelGrapeUpdateManyWithWhereWithoutGrapeInput>
    deleteMany?: Enumerable<LabelGrapeScalarWhereInput>
  }

  export type LabelGrapeUncheckedUpdateManyWithoutGrapeNestedInput = {
    create?: XOR<Enumerable<LabelGrapeCreateWithoutGrapeInput>, Enumerable<LabelGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<LabelGrapeCreateOrConnectWithoutGrapeInput>
    upsert?: Enumerable<LabelGrapeUpsertWithWhereUniqueWithoutGrapeInput>
    createMany?: LabelGrapeCreateManyGrapeInputEnvelope
    set?: Enumerable<LabelGrapeWhereUniqueInput>
    disconnect?: Enumerable<LabelGrapeWhereUniqueInput>
    delete?: Enumerable<LabelGrapeWhereUniqueInput>
    connect?: Enumerable<LabelGrapeWhereUniqueInput>
    update?: Enumerable<LabelGrapeUpdateWithWhereUniqueWithoutGrapeInput>
    updateMany?: Enumerable<LabelGrapeUpdateManyWithWhereWithoutGrapeInput>
    deleteMany?: Enumerable<LabelGrapeScalarWhereInput>
  }

  export type LabelCreateNestedManyWithoutLabelTypeInput = {
    create?: XOR<Enumerable<LabelCreateWithoutLabelTypeInput>, Enumerable<LabelUncheckedCreateWithoutLabelTypeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutLabelTypeInput>
    createMany?: LabelCreateManyLabelTypeInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type LabelUncheckedCreateNestedManyWithoutLabelTypeInput = {
    create?: XOR<Enumerable<LabelCreateWithoutLabelTypeInput>, Enumerable<LabelUncheckedCreateWithoutLabelTypeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutLabelTypeInput>
    createMany?: LabelCreateManyLabelTypeInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type LabelUpdateManyWithoutLabelTypeNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutLabelTypeInput>, Enumerable<LabelUncheckedCreateWithoutLabelTypeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutLabelTypeInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutLabelTypeInput>
    createMany?: LabelCreateManyLabelTypeInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutLabelTypeInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutLabelTypeInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type LabelUncheckedUpdateManyWithoutLabelTypeNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutLabelTypeInput>, Enumerable<LabelUncheckedCreateWithoutLabelTypeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutLabelTypeInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutLabelTypeInput>
    createMany?: LabelCreateManyLabelTypeInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutLabelTypeInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutLabelTypeInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type StateCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type LabelCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<LabelCreateWithoutCountryInput>, Enumerable<LabelUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutCountryInput>
    createMany?: LabelCreateManyCountryInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type StateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type LabelUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<LabelCreateWithoutCountryInput>, Enumerable<LabelUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutCountryInput>
    createMany?: LabelCreateManyCountryInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type StateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type LabelUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutCountryInput>, Enumerable<LabelUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: LabelCreateManyCountryInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type StateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type LabelUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutCountryInput>, Enumerable<LabelUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: LabelCreateManyCountryInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type CountryCreateNestedOneWithoutStatesInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    connect?: CountryWhereUniqueInput
  }

  export type RegionCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    connect?: Enumerable<RegionWhereUniqueInput>
  }

  export type CityCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type RegionUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    connect?: Enumerable<RegionWhereUniqueInput>
  }

  export type CityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CountryUpdateOneRequiredWithoutStatesNestedInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    upsert?: CountryUpsertWithoutStatesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
  }

  export type RegionUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<RegionUpsertWithWhereUniqueWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    set?: Enumerable<RegionWhereUniqueInput>
    disconnect?: Enumerable<RegionWhereUniqueInput>
    delete?: Enumerable<RegionWhereUniqueInput>
    connect?: Enumerable<RegionWhereUniqueInput>
    update?: Enumerable<RegionUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<RegionUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<RegionScalarWhereInput>
  }

  export type CityUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type RegionUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<RegionUpsertWithWhereUniqueWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    set?: Enumerable<RegionWhereUniqueInput>
    disconnect?: Enumerable<RegionWhereUniqueInput>
    delete?: Enumerable<RegionWhereUniqueInput>
    connect?: Enumerable<RegionWhereUniqueInput>
    update?: Enumerable<RegionUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<RegionUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<RegionScalarWhereInput>
  }

  export type CityUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type StateCreateNestedOneWithoutCitiesInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    connect?: StateWhereUniqueInput
  }

  export type StateUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    upsert?: StateUpsertWithoutCitiesInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type StateCreateNestedOneWithoutRegionsInput = {
    create?: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: StateCreateOrConnectWithoutRegionsInput
    connect?: StateWhereUniqueInput
  }

  export type SubRegionCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    connect?: Enumerable<SubRegionWhereUniqueInput>
  }

  export type LabelCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<LabelCreateWithoutRegionInput>, Enumerable<LabelUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutRegionInput>
    createMany?: LabelCreateManyRegionInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type SubRegionUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    connect?: Enumerable<SubRegionWhereUniqueInput>
  }

  export type LabelUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<LabelCreateWithoutRegionInput>, Enumerable<LabelUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutRegionInput>
    createMany?: LabelCreateManyRegionInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type StateUpdateOneRequiredWithoutRegionsNestedInput = {
    create?: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: StateCreateOrConnectWithoutRegionsInput
    upsert?: StateUpsertWithoutRegionsInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutRegionsInput, StateUncheckedUpdateWithoutRegionsInput>
  }

  export type SubRegionUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<SubRegionUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    set?: Enumerable<SubRegionWhereUniqueInput>
    disconnect?: Enumerable<SubRegionWhereUniqueInput>
    delete?: Enumerable<SubRegionWhereUniqueInput>
    connect?: Enumerable<SubRegionWhereUniqueInput>
    update?: Enumerable<SubRegionUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<SubRegionUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<SubRegionScalarWhereInput>
  }

  export type LabelUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutRegionInput>, Enumerable<LabelUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: LabelCreateManyRegionInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type SubRegionUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<SubRegionUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    set?: Enumerable<SubRegionWhereUniqueInput>
    disconnect?: Enumerable<SubRegionWhereUniqueInput>
    delete?: Enumerable<SubRegionWhereUniqueInput>
    connect?: Enumerable<SubRegionWhereUniqueInput>
    update?: Enumerable<SubRegionUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<SubRegionUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<SubRegionScalarWhereInput>
  }

  export type LabelUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutRegionInput>, Enumerable<LabelUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: LabelCreateManyRegionInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type RegionCreateNestedOneWithoutSubregionInput = {
    create?: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
    connectOrCreate?: RegionCreateOrConnectWithoutSubregionInput
    connect?: RegionWhereUniqueInput
  }

  export type RegionUpdateOneRequiredWithoutSubregionNestedInput = {
    create?: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
    connectOrCreate?: RegionCreateOrConnectWithoutSubregionInput
    upsert?: RegionUpsertWithoutSubregionInput
    connect?: RegionWhereUniqueInput
    update?: XOR<RegionUpdateWithoutSubregionInput, RegionUncheckedUpdateWithoutSubregionInput>
  }

  export type LabelCreateNestedManyWithoutWine_typeInput = {
    create?: XOR<Enumerable<LabelCreateWithoutWine_typeInput>, Enumerable<LabelUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutWine_typeInput>
    createMany?: LabelCreateManyWine_typeInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type LabelUncheckedCreateNestedManyWithoutWine_typeInput = {
    create?: XOR<Enumerable<LabelCreateWithoutWine_typeInput>, Enumerable<LabelUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutWine_typeInput>
    createMany?: LabelCreateManyWine_typeInputEnvelope
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type LabelUpdateManyWithoutWine_typeNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutWine_typeInput>, Enumerable<LabelUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutWine_typeInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutWine_typeInput>
    createMany?: LabelCreateManyWine_typeInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutWine_typeInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutWine_typeInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type LabelUncheckedUpdateManyWithoutWine_typeNestedInput = {
    create?: XOR<Enumerable<LabelCreateWithoutWine_typeInput>, Enumerable<LabelUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutWine_typeInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutWine_typeInput>
    createMany?: LabelCreateManyWine_typeInputEnvelope
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutWine_typeInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutWine_typeInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutOrderInput = {
    create?: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOrderInput
    connect?: AccountWhereUniqueInput
  }

  export type OrderLabelCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutOrderInput>, Enumerable<OrderLabelUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutOrderInput>
    createMany?: OrderLabelCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderLabelWhereUniqueInput>
  }

  export type InvoiceCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type OrderLabelUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutOrderInput>, Enumerable<OrderLabelUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutOrderInput>
    createMany?: OrderLabelCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderLabelWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type AccountUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOrderInput
    upsert?: AccountUpsertWithoutOrderInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutOrderInput, AccountUncheckedUpdateWithoutOrderInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderLabelUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutOrderInput>, Enumerable<OrderLabelUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderLabelUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderLabelCreateManyOrderInputEnvelope
    set?: Enumerable<OrderLabelWhereUniqueInput>
    disconnect?: Enumerable<OrderLabelWhereUniqueInput>
    delete?: Enumerable<OrderLabelWhereUniqueInput>
    connect?: Enumerable<OrderLabelWhereUniqueInput>
    update?: Enumerable<OrderLabelUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderLabelUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderLabelScalarWhereInput>
  }

  export type InvoiceUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type OrderLabelUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderLabelCreateWithoutOrderInput>, Enumerable<OrderLabelUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderLabelCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderLabelUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderLabelCreateManyOrderInputEnvelope
    set?: Enumerable<OrderLabelWhereUniqueInput>
    disconnect?: Enumerable<OrderLabelWhereUniqueInput>
    delete?: Enumerable<OrderLabelWhereUniqueInput>
    connect?: Enumerable<OrderLabelWhereUniqueInput>
    update?: Enumerable<OrderLabelUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderLabelUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderLabelScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type OrderCreateNestedOneWithoutOrder_labelInput = {
    create?: XOR<OrderCreateWithoutOrder_labelInput, OrderUncheckedCreateWithoutOrder_labelInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrder_labelInput
    connect?: OrderWhereUniqueInput
  }

  export type LabelCreateNestedOneWithoutOrder_labelInput = {
    create?: XOR<LabelCreateWithoutOrder_labelInput, LabelUncheckedCreateWithoutOrder_labelInput>
    connectOrCreate?: LabelCreateOrConnectWithoutOrder_labelInput
    connect?: LabelWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrder_labelNestedInput = {
    create?: XOR<OrderCreateWithoutOrder_labelInput, OrderUncheckedCreateWithoutOrder_labelInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrder_labelInput
    upsert?: OrderUpsertWithoutOrder_labelInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutOrder_labelInput, OrderUncheckedUpdateWithoutOrder_labelInput>
  }

  export type LabelUpdateOneRequiredWithoutOrder_labelNestedInput = {
    create?: XOR<LabelCreateWithoutOrder_labelInput, LabelUncheckedCreateWithoutOrder_labelInput>
    connectOrCreate?: LabelCreateOrConnectWithoutOrder_labelInput
    upsert?: LabelUpsertWithoutOrder_labelInput
    connect?: LabelWhereUniqueInput
    update?: XOR<LabelUpdateWithoutOrder_labelInput, LabelUncheckedUpdateWithoutOrder_labelInput>
  }

  export type OrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    upsert?: OrderUpsertWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type DeviceUserCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type PushNotificationCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type SmsNotificationCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type DeviceNotificationCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type DeviceUserUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type PushNotificationUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type EnumPlatformTypeFieldUpdateOperationsInput = {
    set?: PlatformType
  }

  export type DeviceUserUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type PushNotificationUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type SmsNotificationUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type DeviceNotificationUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type DeviceCreateNestedOneWithoutDevice_userInput = {
    create?: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_userInput
    connect?: DeviceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDevice_userInput = {
    create?: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevice_userInput
    connect?: UserWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDevice_userNestedInput = {
    create?: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_userInput
    upsert?: DeviceUpsertWithoutDevice_userInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutDevice_userInput, DeviceUncheckedUpdateWithoutDevice_userInput>
  }

  export type UserUpdateOneRequiredWithoutDevice_userNestedInput = {
    create?: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevice_userInput
    upsert?: UserUpsertWithoutDevice_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDevice_userInput, UserUncheckedUpdateWithoutDevice_userInput>
  }

  export type SmsNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type EmailNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
  }

  export type PushNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type DeviceNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
  }

  export type PushNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type EnumTypeNotificationFieldUpdateOperationsInput = {
    set?: TypeNotification
  }

  export type SmsNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type EmailNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<EmailNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<EmailNotificationWhereUniqueInput>
    disconnect?: Enumerable<EmailNotificationWhereUniqueInput>
    delete?: Enumerable<EmailNotificationWhereUniqueInput>
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
    update?: Enumerable<EmailNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<EmailNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<EmailNotificationScalarWhereInput>
  }

  export type PushNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type DeviceNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<EmailNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<EmailNotificationWhereUniqueInput>
    disconnect?: Enumerable<EmailNotificationWhereUniqueInput>
    delete?: Enumerable<EmailNotificationWhereUniqueInput>
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
    update?: Enumerable<EmailNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<EmailNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<EmailNotificationScalarWhereInput>
  }

  export type PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type NotificationsCreateNestedOneWithoutEmail_notificationInput = {
    create?: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutEmail_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type NotificationsUpdateOneRequiredWithoutEmail_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutEmail_notificationInput
    upsert?: NotificationsUpsertWithoutEmail_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutEmail_notificationInput, NotificationsUncheckedUpdateWithoutEmail_notificationInput>
  }

  export type EnumEmailTypeNotificationFieldUpdateOperationsInput = {
    set?: EmailTypeNotification
  }

  export type NotificationsCreateNestedOneWithoutSms_notificationInput = {
    create?: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutSms_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutSms_notificationInput = {
    create?: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSms_notificationInput
    connect?: DeviceWhereUniqueInput
  }

  export type NotificationsUpdateOneRequiredWithoutSms_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutSms_notificationInput
    upsert?: NotificationsUpsertWithoutSms_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutSms_notificationInput, NotificationsUncheckedUpdateWithoutSms_notificationInput>
  }

  export type DeviceUpdateOneRequiredWithoutSms_notificationNestedInput = {
    create?: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSms_notificationInput
    upsert?: DeviceUpsertWithoutSms_notificationInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutSms_notificationInput, DeviceUncheckedUpdateWithoutSms_notificationInput>
  }

  export type NotificationsCreateNestedOneWithoutPush_notificationInput = {
    create?: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutPush_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutPush_notificationInput = {
    create?: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPush_notificationInput
    connect?: DeviceWhereUniqueInput
  }

  export type NotificationsUpdateOneRequiredWithoutPush_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutPush_notificationInput
    upsert?: NotificationsUpsertWithoutPush_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutPush_notificationInput, NotificationsUncheckedUpdateWithoutPush_notificationInput>
  }

  export type DeviceUpdateOneRequiredWithoutPush_notificationNestedInput = {
    create?: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPush_notificationInput
    upsert?: DeviceUpsertWithoutPush_notificationInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutPush_notificationInput, DeviceUncheckedUpdateWithoutPush_notificationInput>
  }

  export type DeviceCreateNestedOneWithoutDevice_notificationInput = {
    create?: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_notificationInput
    connect?: DeviceWhereUniqueInput
  }

  export type NotificationsCreateNestedOneWithoutDevice_notificationInput = {
    create?: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutDevice_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDevice_notificationNestedInput = {
    create?: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_notificationInput
    upsert?: DeviceUpsertWithoutDevice_notificationInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutDevice_notificationInput, DeviceUncheckedUpdateWithoutDevice_notificationInput>
  }

  export type NotificationsUpdateOneRequiredWithoutDevice_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutDevice_notificationInput
    upsert?: NotificationsUpsertWithoutDevice_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutDevice_notificationInput, NotificationsUncheckedUpdateWithoutDevice_notificationInput>
  }

  export type PaymentCycleCreateNestedOneWithoutPlansInput = {
    create?: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
    connectOrCreate?: PaymentCycleCreateOrConnectWithoutPlansInput
    connect?: PaymentCycleWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type PaymentCycleUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
    connectOrCreate?: PaymentCycleCreateOrConnectWithoutPlansInput
    upsert?: PaymentCycleUpsertWithoutPlansInput
    connect?: PaymentCycleWhereUniqueInput
    update?: XOR<PaymentCycleUpdateWithoutPlansInput, PaymentCycleUncheckedUpdateWithoutPlansInput>
  }

  export type AccountUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type PlanCreateNestedManyWithoutPayment_cycleInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    connect?: Enumerable<PlanWhereUniqueInput>
  }

  export type PlanUncheckedCreateNestedManyWithoutPayment_cycleInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    connect?: Enumerable<PlanWhereUniqueInput>
  }

  export type PlanUpdateManyWithoutPayment_cycleNestedInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    upsert?: Enumerable<PlanUpsertWithWhereUniqueWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    set?: Enumerable<PlanWhereUniqueInput>
    disconnect?: Enumerable<PlanWhereUniqueInput>
    delete?: Enumerable<PlanWhereUniqueInput>
    connect?: Enumerable<PlanWhereUniqueInput>
    update?: Enumerable<PlanUpdateWithWhereUniqueWithoutPayment_cycleInput>
    updateMany?: Enumerable<PlanUpdateManyWithWhereWithoutPayment_cycleInput>
    deleteMany?: Enumerable<PlanScalarWhereInput>
  }

  export type PlanUncheckedUpdateManyWithoutPayment_cycleNestedInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    upsert?: Enumerable<PlanUpsertWithWhereUniqueWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    set?: Enumerable<PlanWhereUniqueInput>
    disconnect?: Enumerable<PlanWhereUniqueInput>
    delete?: Enumerable<PlanWhereUniqueInput>
    connect?: Enumerable<PlanWhereUniqueInput>
    update?: Enumerable<PlanUpdateWithWhereUniqueWithoutPayment_cycleInput>
    updateMany?: Enumerable<PlanUpdateManyWithWhereWithoutPayment_cycleInput>
    deleteMany?: Enumerable<PlanScalarWhereInput>
  }

  export type PlanCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionInput
    connect?: PlanWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSubscriptionInput
    connect?: AccountWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionInput
    upsert?: PlanUpsertWithoutSubscriptionInput
    connect?: PlanWhereUniqueInput
    update?: XOR<PlanUpdateWithoutSubscriptionInput, PlanUncheckedUpdateWithoutSubscriptionInput>
  }

  export type AccountUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSubscriptionInput
    upsert?: AccountUpsertWithoutSubscriptionInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutSubscriptionInput, AccountUncheckedUpdateWithoutSubscriptionInput>
  }

  export type LabelCreateNestedOneWithoutStockLabelInput = {
    create?: XOR<LabelCreateWithoutStockLabelInput, LabelUncheckedCreateWithoutStockLabelInput>
    connectOrCreate?: LabelCreateOrConnectWithoutStockLabelInput
    connect?: LabelWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutStockLabelInput = {
    create?: XOR<AccountCreateWithoutStockLabelInput, AccountUncheckedCreateWithoutStockLabelInput>
    connectOrCreate?: AccountCreateOrConnectWithoutStockLabelInput
    connect?: AccountWhereUniqueInput
  }

  export type LabelUpdateOneRequiredWithoutStockLabelNestedInput = {
    create?: XOR<LabelCreateWithoutStockLabelInput, LabelUncheckedCreateWithoutStockLabelInput>
    connectOrCreate?: LabelCreateOrConnectWithoutStockLabelInput
    upsert?: LabelUpsertWithoutStockLabelInput
    connect?: LabelWhereUniqueInput
    update?: XOR<LabelUpdateWithoutStockLabelInput, LabelUncheckedUpdateWithoutStockLabelInput>
  }

  export type AccountUpdateOneRequiredWithoutStockLabelNestedInput = {
    create?: XOR<AccountCreateWithoutStockLabelInput, AccountUncheckedCreateWithoutStockLabelInput>
    connectOrCreate?: AccountCreateOrConnectWithoutStockLabelInput
    upsert?: AccountUpsertWithoutStockLabelInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutStockLabelInput, AccountUncheckedUpdateWithoutStockLabelInput>
  }

  export type LabelCreateNestedOneWithoutStockHistoryInput = {
    create?: XOR<LabelCreateWithoutStockHistoryInput, LabelUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: LabelCreateOrConnectWithoutStockHistoryInput
    connect?: LabelWhereUniqueInput
  }

  export type LabelUpdateOneRequiredWithoutStockHistoryNestedInput = {
    create?: XOR<LabelCreateWithoutStockHistoryInput, LabelUncheckedCreateWithoutStockHistoryInput>
    connectOrCreate?: LabelCreateOrConnectWithoutStockHistoryInput
    upsert?: LabelUpsertWithoutStockHistoryInput
    connect?: LabelWhereUniqueInput
    update?: XOR<LabelUpdateWithoutStockHistoryInput, LabelUncheckedUpdateWithoutStockHistoryInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumPersonTypeFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeFilter | PersonType
  }

  export type NestedEnumGenderTypeFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeFilter | GenderType
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumPersonTypeWithAggregatesFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeWithAggregatesFilter | PersonType
    _count?: NestedIntFilter
    _min?: NestedEnumPersonTypeFilter
    _max?: NestedEnumPersonTypeFilter
  }

  export type NestedEnumGenderTypeWithAggregatesFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeWithAggregatesFilter | GenderType
    _count?: NestedIntFilter
    _min?: NestedEnumGenderTypeFilter
    _max?: NestedEnumGenderTypeFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumCouponDiscountTypeFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeFilter | CouponDiscountType
  }

  export type NestedEnumCouponUseTypeFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeFilter | CouponUseType
  }

  export type NestedEnumCouponDiscountTypeWithAggregatesFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeWithAggregatesFilter | CouponDiscountType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponDiscountTypeFilter
    _max?: NestedEnumCouponDiscountTypeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumCouponUseTypeWithAggregatesFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeWithAggregatesFilter | CouponUseType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponUseTypeFilter
    _max?: NestedEnumCouponUseTypeFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedEnumPlatformTypeFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeFilter | PlatformType
  }

  export type NestedEnumPlatformTypeWithAggregatesFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeWithAggregatesFilter | PlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumPlatformTypeFilter
    _max?: NestedEnumPlatformTypeFilter
  }

  export type NestedEnumTypeNotificationFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationFilter | TypeNotification
  }

  export type NestedEnumTypeNotificationWithAggregatesFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationWithAggregatesFilter | TypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumTypeNotificationFilter
    _max?: NestedEnumTypeNotificationFilter
  }

  export type NestedEnumEmailTypeNotificationFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationFilter | EmailTypeNotification
  }

  export type NestedEnumEmailTypeNotificationWithAggregatesFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationWithAggregatesFilter | EmailTypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumEmailTypeNotificationFilter
    _max?: NestedEnumEmailTypeNotificationFilter
  }

  export type CampaignCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    account_user: AccountUserCreateNestedOneWithoutCampaignsInput
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    type_id: string
    account_user_id: string
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAccountInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAccountInput, CampaignUncheckedCreateWithoutAccountInput>
  }

  export type CampaignCreateManyAccountInputEnvelope = {
    data: Enumerable<CampaignCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutAccountInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle: PaymentCycleCreateNestedOneWithoutPlansInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutAccountInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
  }

  export type SubscriptionCreateWithoutAccountInput = {
    id?: string
    plan: PlanCreateNestedOneWithoutSubscriptionInput
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutAccountInput = {
    id?: string
    plan_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutAccountInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutAccountInput, SubscriptionUncheckedCreateWithoutAccountInput>
  }

  export type SubscriptionCreateManyAccountInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutAccountInput = {
    id?: string
    code: string
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAccountInput = {
    id?: string
    code: string
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAccountInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
  }

  export type OrderCreateManyAccountInputEnvelope = {
    data: Enumerable<OrderCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type AccountActivitiesCreateWithoutAccountInput = {
    activities: ActivitiesCreateNestedOneWithoutAccount_activitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUncheckedCreateWithoutAccountInput = {
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesCreateOrConnectWithoutAccountInput = {
    where: AccountActivitiesWhereUniqueInput
    create: XOR<AccountActivitiesCreateWithoutAccountInput, AccountActivitiesUncheckedCreateWithoutAccountInput>
  }

  export type AccountActivitiesCreateManyAccountInputEnvelope = {
    data: Enumerable<AccountActivitiesCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type AccountUserCreateWithoutAccountInput = {
    id?: string
    user: UserCreateNestedOneWithoutAccount_userInput
    role: RoleCreateNestedOneWithoutAccountUserInput
    campaigns?: CampaignCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserUncheckedCreateWithoutAccountInput = {
    id?: string
    user_id: string
    role_id: string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserCreateOrConnectWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput>
  }

  export type AccountUserCreateManyAccountInputEnvelope = {
    data: Enumerable<AccountUserCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type StockLabelCreateWithoutAccountInput = {
    labels: LabelCreateNestedOneWithoutStockLabelInput
    min_quantity: number
    max_quantity: number
  }

  export type StockLabelUncheckedCreateWithoutAccountInput = {
    label_id: string
    min_quantity: number
    max_quantity: number
  }

  export type StockLabelCreateOrConnectWithoutAccountInput = {
    where: StockLabelWhereUniqueInput
    create: XOR<StockLabelCreateWithoutAccountInput, StockLabelUncheckedCreateWithoutAccountInput>
  }

  export type StockLabelCreateManyAccountInputEnvelope = {
    data: Enumerable<StockLabelCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type AccountConfigurationCreateWithoutAccountInput = {
    id?: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUncheckedCreateWithoutAccountInput = {
    id?: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationCreateOrConnectWithoutAccountInput = {
    where: AccountConfigurationWhereUniqueInput
    create: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutAccountInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutAccountInput, CampaignUncheckedUpdateWithoutAccountInput>
    create: XOR<CampaignCreateWithoutAccountInput, CampaignUncheckedCreateWithoutAccountInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutAccountInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutAccountInput, CampaignUncheckedUpdateWithoutAccountInput>
  }

  export type CampaignUpdateManyWithWhereWithoutAccountInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: Enumerable<CampaignScalarWhereInput>
    OR?: Enumerable<CampaignScalarWhereInput>
    NOT?: Enumerable<CampaignScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    percentage_discount?: FloatNullableFilter | number | null
    start_date?: DateTimeNullableFilter | Date | string | null
    expiration_date?: DateTimeNullableFilter | Date | string | null
    type_id?: StringFilter | string
    account_id?: StringFilter | string
    account_user_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PlanUpsertWithoutAccountInput = {
    update: XOR<PlanUpdateWithoutAccountInput, PlanUncheckedUpdateWithoutAccountInput>
    create: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
  }

  export type PlanUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle?: PaymentCycleUpdateOneRequiredWithoutPlansNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutAccountInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutAccountInput, SubscriptionUncheckedUpdateWithoutAccountInput>
    create: XOR<SubscriptionCreateWithoutAccountInput, SubscriptionUncheckedCreateWithoutAccountInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutAccountInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutAccountInput, SubscriptionUncheckedUpdateWithoutAccountInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutAccountInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: Enumerable<SubscriptionScalarWhereInput>
    OR?: Enumerable<SubscriptionScalarWhereInput>
    NOT?: Enumerable<SubscriptionScalarWhereInput>
    id?: StringFilter | string
    plan_id?: StringFilter | string
    account_id?: StringFilter | string
    due?: DateTimeFilter | Date | string
    price?: FloatFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutAccountInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutAccountInput, OrderUncheckedUpdateWithoutAccountInput>
    create: XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutAccountInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutAccountInput, OrderUncheckedUpdateWithoutAccountInput>
  }

  export type OrderUpdateManyWithWhereWithoutAccountInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    account_id?: StringFilter | string
    total?: FloatFilter | number
    coupon_id?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountActivitiesUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountActivitiesWhereUniqueInput
    update: XOR<AccountActivitiesUpdateWithoutAccountInput, AccountActivitiesUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountActivitiesCreateWithoutAccountInput, AccountActivitiesUncheckedCreateWithoutAccountInput>
  }

  export type AccountActivitiesUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountActivitiesWhereUniqueInput
    data: XOR<AccountActivitiesUpdateWithoutAccountInput, AccountActivitiesUncheckedUpdateWithoutAccountInput>
  }

  export type AccountActivitiesUpdateManyWithWhereWithoutAccountInput = {
    where: AccountActivitiesScalarWhereInput
    data: XOR<AccountActivitiesUpdateManyMutationInput, AccountActivitiesUncheckedUpdateManyWithoutAccount_activitiesInput>
  }

  export type AccountActivitiesScalarWhereInput = {
    AND?: Enumerable<AccountActivitiesScalarWhereInput>
    OR?: Enumerable<AccountActivitiesScalarWhereInput>
    NOT?: Enumerable<AccountActivitiesScalarWhereInput>
    account_id?: StringFilter | string
    activities_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountUserUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutAccountInput, AccountUserUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutAccountInput, AccountUserUncheckedUpdateWithoutAccountInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutAccountInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutAccount_usersInput>
  }

  export type AccountUserScalarWhereInput = {
    AND?: Enumerable<AccountUserScalarWhereInput>
    OR?: Enumerable<AccountUserScalarWhereInput>
    NOT?: Enumerable<AccountUserScalarWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    user_id?: StringFilter | string
    role_id?: StringFilter | string
  }

  export type StockLabelUpsertWithWhereUniqueWithoutAccountInput = {
    where: StockLabelWhereUniqueInput
    update: XOR<StockLabelUpdateWithoutAccountInput, StockLabelUncheckedUpdateWithoutAccountInput>
    create: XOR<StockLabelCreateWithoutAccountInput, StockLabelUncheckedCreateWithoutAccountInput>
  }

  export type StockLabelUpdateWithWhereUniqueWithoutAccountInput = {
    where: StockLabelWhereUniqueInput
    data: XOR<StockLabelUpdateWithoutAccountInput, StockLabelUncheckedUpdateWithoutAccountInput>
  }

  export type StockLabelUpdateManyWithWhereWithoutAccountInput = {
    where: StockLabelScalarWhereInput
    data: XOR<StockLabelUpdateManyMutationInput, StockLabelUncheckedUpdateManyWithoutStockLabelInput>
  }

  export type StockLabelScalarWhereInput = {
    AND?: Enumerable<StockLabelScalarWhereInput>
    OR?: Enumerable<StockLabelScalarWhereInput>
    NOT?: Enumerable<StockLabelScalarWhereInput>
    label_id?: StringFilter | string
    account_id?: StringFilter | string
    min_quantity?: IntFilter | number
    max_quantity?: IntFilter | number
  }

  export type AccountConfigurationUpsertWithoutAccountInput = {
    update: XOR<AccountConfigurationUpdateWithoutAccountInput, AccountConfigurationUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
  }

  export type AccountConfigurationUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateWithoutAccount_configurationInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutAccount_configurationInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutAccount_configurationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
  }

  export type AccountUpsertWithoutAccount_configurationInput = {
    update: XOR<AccountUpdateWithoutAccount_configurationInput, AccountUncheckedUpdateWithoutAccount_configurationInput>
    create: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
  }

  export type AccountUpdateWithoutAccount_configurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutAccount_configurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateWithoutAccount_activitiesInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutAccount_activitiesInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutAccount_activitiesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type ActivitiesCreateWithoutAccount_activitiesInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivitiesUncheckedCreateWithoutAccount_activitiesInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivitiesCreateOrConnectWithoutAccount_activitiesInput = {
    where: ActivitiesWhereUniqueInput
    create: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type AccountUpsertWithoutAccount_activitiesInput = {
    update: XOR<AccountUpdateWithoutAccount_activitiesInput, AccountUncheckedUpdateWithoutAccount_activitiesInput>
    create: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type AccountUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivitiesUpsertWithoutAccount_activitiesInput = {
    update: XOR<ActivitiesUpdateWithoutAccount_activitiesInput, ActivitiesUncheckedUpdateWithoutAccount_activitiesInput>
    create: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type ActivitiesUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivitiesUncheckedUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesCreateWithoutActivitiesInput = {
    account: AccountCreateNestedOneWithoutAccount_activitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUncheckedCreateWithoutActivitiesInput = {
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesCreateOrConnectWithoutActivitiesInput = {
    where: AccountActivitiesWhereUniqueInput
    create: XOR<AccountActivitiesCreateWithoutActivitiesInput, AccountActivitiesUncheckedCreateWithoutActivitiesInput>
  }

  export type AccountActivitiesCreateManyActivitiesInputEnvelope = {
    data: Enumerable<AccountActivitiesCreateManyActivitiesInput>
    skipDuplicates?: boolean
  }

  export type AccountActivitiesUpsertWithWhereUniqueWithoutActivitiesInput = {
    where: AccountActivitiesWhereUniqueInput
    update: XOR<AccountActivitiesUpdateWithoutActivitiesInput, AccountActivitiesUncheckedUpdateWithoutActivitiesInput>
    create: XOR<AccountActivitiesCreateWithoutActivitiesInput, AccountActivitiesUncheckedCreateWithoutActivitiesInput>
  }

  export type AccountActivitiesUpdateWithWhereUniqueWithoutActivitiesInput = {
    where: AccountActivitiesWhereUniqueInput
    data: XOR<AccountActivitiesUpdateWithoutActivitiesInput, AccountActivitiesUncheckedUpdateWithoutActivitiesInput>
  }

  export type AccountActivitiesUpdateManyWithWhereWithoutActivitiesInput = {
    where: AccountActivitiesScalarWhereInput
    data: XOR<AccountActivitiesUpdateManyMutationInput, AccountActivitiesUncheckedUpdateManyWithoutAccount_activitiesInput>
  }

  export type DeviceUserCreateWithoutUserInput = {
    device: DeviceCreateNestedOneWithoutDevice_userInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUncheckedCreateWithoutUserInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserCreateOrConnectWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    create: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput>
  }

  export type DeviceUserCreateManyUserInputEnvelope = {
    data: Enumerable<DeviceUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountUserCreateWithoutUserInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_usersInput
    role: RoleCreateNestedOneWithoutAccountUserInput
    campaigns?: CampaignCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserUncheckedCreateWithoutUserInput = {
    id?: string
    account_id: string
    role_id: string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserCreateOrConnectWithoutUserInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutUserInput, AccountUserUncheckedCreateWithoutUserInput>
  }

  export type AccountUserCreateManyUserInputEnvelope = {
    data: Enumerable<AccountUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DeviceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    update: XOR<DeviceUserUpdateWithoutUserInput, DeviceUserUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput>
  }

  export type DeviceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    data: XOR<DeviceUserUpdateWithoutUserInput, DeviceUserUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUserUpdateManyWithWhereWithoutUserInput = {
    where: DeviceUserScalarWhereInput
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyWithoutDevice_userInput>
  }

  export type DeviceUserScalarWhereInput = {
    AND?: Enumerable<DeviceUserScalarWhereInput>
    OR?: Enumerable<DeviceUserScalarWhereInput>
    NOT?: Enumerable<DeviceUserScalarWhereInput>
    device_id?: StringFilter | string
    user_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountUserUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutUserInput, AccountUserUncheckedUpdateWithoutUserInput>
    create: XOR<AccountUserCreateWithoutUserInput, AccountUserUncheckedCreateWithoutUserInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutUserInput, AccountUserUncheckedUpdateWithoutUserInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutUserInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutAccount_userInput>
  }

  export type AccountCreateWithoutAccount_usersInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutAccount_usersInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutAccount_usersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
  }

  export type UserCreateWithoutAccount_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    city: string
    zipcode: string
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccount_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    city: string
    zipcode: string
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccount_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
  }

  export type RoleCreateWithoutAccountUserInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutAccountUserInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutAccountUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
  }

  export type CampaignCreateWithoutAccount_userInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    account: AccountCreateNestedOneWithoutCampaignInput
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAccount_userInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    type_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAccount_userInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAccount_userInput, CampaignUncheckedCreateWithoutAccount_userInput>
  }

  export type CampaignCreateManyAccount_userInputEnvelope = {
    data: Enumerable<CampaignCreateManyAccount_userInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutAccount_usersInput = {
    update: XOR<AccountUpdateWithoutAccount_usersInput, AccountUncheckedUpdateWithoutAccount_usersInput>
    create: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
  }

  export type AccountUpdateWithoutAccount_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutAccount_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutAccount_userInput = {
    update: XOR<UserUpdateWithoutAccount_userInput, UserUncheckedUpdateWithoutAccount_userInput>
    create: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
  }

  export type UserUpdateWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutAccountUserInput = {
    update: XOR<RoleUpdateWithoutAccountUserInput, RoleUncheckedUpdateWithoutAccountUserInput>
    create: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
  }

  export type RoleUpdateWithoutAccountUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutAccountUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutAccount_userInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutAccount_userInput, CampaignUncheckedUpdateWithoutAccount_userInput>
    create: XOR<CampaignCreateWithoutAccount_userInput, CampaignUncheckedCreateWithoutAccount_userInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutAccount_userInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutAccount_userInput, CampaignUncheckedUpdateWithoutAccount_userInput>
  }

  export type CampaignUpdateManyWithWhereWithoutAccount_userInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    role: RoleCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    role_id: string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: Enumerable<RolePermissionCreateManyPermissionInput>
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: Enumerable<RolePermissionScalarWhereInput>
    OR?: Enumerable<RolePermissionScalarWhereInput>
    NOT?: Enumerable<RolePermissionScalarWhereInput>
    role_id?: StringFilter | string
    permission_id?: StringFilter | string
  }

  export type RoleCreateWithoutRolePermissionInput = {
    id?: string
    name: string
    AccountUser?: AccountUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionInput = {
    id?: string
    name: string
    AccountUser?: AccountUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
  }

  export type PermisionCreateWithoutRolePermissionInput = {
    id?: string
    name: string
  }

  export type PermisionUncheckedCreateWithoutRolePermissionInput = {
    id?: string
    name: string
  }

  export type PermisionCreateOrConnectWithoutRolePermissionInput = {
    where: PermisionWhereUniqueInput
    create: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
  }

  export type RoleUpsertWithoutRolePermissionInput = {
    update: XOR<RoleUpdateWithoutRolePermissionInput, RoleUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
  }

  export type RoleUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    AccountUser?: AccountUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    AccountUser?: AccountUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermisionUpsertWithoutRolePermissionInput = {
    update: XOR<PermisionUpdateWithoutRolePermissionInput, PermisionUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
  }

  export type PermisionUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermisionUncheckedUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateWithoutRoleInput = {
    permission: PermisionCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permission_id: string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: Enumerable<RolePermissionCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type AccountUserCreateWithoutRoleInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_usersInput
    user: UserCreateNestedOneWithoutAccount_userInput
    campaigns?: CampaignCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserUncheckedCreateWithoutRoleInput = {
    id?: string
    account_id: string
    user_id: string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAccount_userInput
  }

  export type AccountUserCreateOrConnectWithoutRoleInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutRoleInput, AccountUserUncheckedCreateWithoutRoleInput>
  }

  export type AccountUserCreateManyRoleInputEnvelope = {
    data: Enumerable<AccountUserCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type AccountUserUpsertWithWhereUniqueWithoutRoleInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutRoleInput, AccountUserUncheckedUpdateWithoutRoleInput>
    create: XOR<AccountUserCreateWithoutRoleInput, AccountUserUncheckedCreateWithoutRoleInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutRoleInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutRoleInput, AccountUserUncheckedUpdateWithoutRoleInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutRoleInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutAccountUserInput>
  }

  export type CampaignTypeCreateWithoutCampaignInput = {
    id?: string
    name: string
    slug: string
  }

  export type CampaignTypeUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    slug: string
  }

  export type CampaignTypeCreateOrConnectWithoutCampaignInput = {
    where: CampaignTypeWhereUniqueInput
    create: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
  }

  export type AccountCreateWithoutCampaignInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutCampaignInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutCampaignInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
  }

  export type AccountUserCreateWithoutCampaignsInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_usersInput
    user: UserCreateNestedOneWithoutAccount_userInput
    role: RoleCreateNestedOneWithoutAccountUserInput
  }

  export type AccountUserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    account_id: string
    user_id: string
    role_id: string
  }

  export type AccountUserCreateOrConnectWithoutCampaignsInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutCampaignsInput, AccountUserUncheckedCreateWithoutCampaignsInput>
  }

  export type LabelCampaignCreateWithoutCampaignInput = {
    label: LabelCreateNestedOneWithoutLabel_campaignInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignUncheckedCreateWithoutCampaignInput = {
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignCreateOrConnectWithoutCampaignInput = {
    where: LabelCampaignWhereUniqueInput
    create: XOR<LabelCampaignCreateWithoutCampaignInput, LabelCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type LabelCampaignCreateManyCampaignInputEnvelope = {
    data: Enumerable<LabelCampaignCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type CampaignTypeUpsertWithoutCampaignInput = {
    update: XOR<CampaignTypeUpdateWithoutCampaignInput, CampaignTypeUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTypeUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignTypeUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUpsertWithoutCampaignInput = {
    update: XOR<AccountUpdateWithoutCampaignInput, AccountUncheckedUpdateWithoutCampaignInput>
    create: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
  }

  export type AccountUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUserUpsertWithoutCampaignsInput = {
    update: XOR<AccountUserUpdateWithoutCampaignsInput, AccountUserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<AccountUserCreateWithoutCampaignsInput, AccountUserUncheckedCreateWithoutCampaignsInput>
  }

  export type AccountUserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_usersNestedInput
    user?: UserUpdateOneRequiredWithoutAccount_userNestedInput
    role?: RoleUpdateOneRequiredWithoutAccountUserNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type LabelCampaignUpsertWithWhereUniqueWithoutCampaignInput = {
    where: LabelCampaignWhereUniqueInput
    update: XOR<LabelCampaignUpdateWithoutCampaignInput, LabelCampaignUncheckedUpdateWithoutCampaignInput>
    create: XOR<LabelCampaignCreateWithoutCampaignInput, LabelCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type LabelCampaignUpdateWithWhereUniqueWithoutCampaignInput = {
    where: LabelCampaignWhereUniqueInput
    data: XOR<LabelCampaignUpdateWithoutCampaignInput, LabelCampaignUncheckedUpdateWithoutCampaignInput>
  }

  export type LabelCampaignUpdateManyWithWhereWithoutCampaignInput = {
    where: LabelCampaignScalarWhereInput
    data: XOR<LabelCampaignUpdateManyMutationInput, LabelCampaignUncheckedUpdateManyWithoutLabel_campaignInput>
  }

  export type LabelCampaignScalarWhereInput = {
    AND?: Enumerable<LabelCampaignScalarWhereInput>
    OR?: Enumerable<LabelCampaignScalarWhereInput>
    NOT?: Enumerable<LabelCampaignScalarWhereInput>
    label_id?: StringFilter | string
    campaign_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CampaignCreateWithoutCampaign_typeInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    account: AccountCreateNestedOneWithoutCampaignInput
    account_user: AccountUserCreateNestedOneWithoutCampaignsInput
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaign_typeInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    account_id: string
    account_user_id: string
    created_at?: Date | string
    updated_at?: Date | string
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaign_typeInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaign_typeInput, CampaignUncheckedCreateWithoutCampaign_typeInput>
  }

  export type CampaignCreateManyCampaign_typeInputEnvelope = {
    data: Enumerable<CampaignCreateManyCampaign_typeInput>
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutCampaign_typeInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCampaign_typeInput, CampaignUncheckedUpdateWithoutCampaign_typeInput>
    create: XOR<CampaignCreateWithoutCampaign_typeInput, CampaignUncheckedCreateWithoutCampaign_typeInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCampaign_typeInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCampaign_typeInput, CampaignUncheckedUpdateWithoutCampaign_typeInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCampaign_typeInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type LabelTypeCreateWithoutLabelsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelTypeUncheckedCreateWithoutLabelsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelTypeCreateOrConnectWithoutLabelsInput = {
    where: LabelTypeWhereUniqueInput
    create: XOR<LabelTypeCreateWithoutLabelsInput, LabelTypeUncheckedCreateWithoutLabelsInput>
  }

  export type CountryCreateWithoutLabelsInput = {
    id?: string
    name: string
    slug: string
    value: string
    states?: StateCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUncheckedCreateWithoutLabelsInput = {
    id?: string
    name: string
    slug: string
    value: string
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryCreateOrConnectWithoutLabelsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutLabelsInput, CountryUncheckedCreateWithoutLabelsInput>
  }

  export type RegionCreateWithoutLabelsInput = {
    id?: string
    state: StateCreateNestedOneWithoutRegionsInput
    name: string
    slug: string
    subregion?: SubRegionCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateWithoutLabelsInput = {
    id?: string
    state_id: string
    name: string
    slug: string
    subregion?: SubRegionUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionCreateOrConnectWithoutLabelsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutLabelsInput, RegionUncheckedCreateWithoutLabelsInput>
  }

  export type WineTypeCreateWithoutLabelsInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUncheckedCreateWithoutLabelsInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeCreateOrConnectWithoutLabelsInput = {
    where: WineTypeWhereUniqueInput
    create: XOR<WineTypeCreateWithoutLabelsInput, WineTypeUncheckedCreateWithoutLabelsInput>
  }

  export type LabelGrapeCreateWithoutLabelInput = {
    grape: GrapeCreateNestedOneWithoutLabelGrapeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeUncheckedCreateWithoutLabelInput = {
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeCreateOrConnectWithoutLabelInput = {
    where: LabelGrapeWhereUniqueInput
    create: XOR<LabelGrapeCreateWithoutLabelInput, LabelGrapeUncheckedCreateWithoutLabelInput>
  }

  export type LabelGrapeCreateManyLabelInputEnvelope = {
    data: Enumerable<LabelGrapeCreateManyLabelInput>
    skipDuplicates?: boolean
  }

  export type OrderLabelCreateWithoutLabelInput = {
    order: OrderCreateNestedOneWithoutOrder_labelInput
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type OrderLabelUncheckedCreateWithoutLabelInput = {
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type OrderLabelCreateOrConnectWithoutLabelInput = {
    where: OrderLabelWhereUniqueInput
    create: XOR<OrderLabelCreateWithoutLabelInput, OrderLabelUncheckedCreateWithoutLabelInput>
  }

  export type OrderLabelCreateManyLabelInputEnvelope = {
    data: Enumerable<OrderLabelCreateManyLabelInput>
    skipDuplicates?: boolean
  }

  export type LabelCampaignCreateWithoutLabelInput = {
    campaign: CampaignCreateNestedOneWithoutLabel_campaignInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignUncheckedCreateWithoutLabelInput = {
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignCreateOrConnectWithoutLabelInput = {
    where: LabelCampaignWhereUniqueInput
    create: XOR<LabelCampaignCreateWithoutLabelInput, LabelCampaignUncheckedCreateWithoutLabelInput>
  }

  export type LabelCampaignCreateManyLabelInputEnvelope = {
    data: Enumerable<LabelCampaignCreateManyLabelInput>
    skipDuplicates?: boolean
  }

  export type StockLabelCreateWithoutLabelsInput = {
    account: AccountCreateNestedOneWithoutStockLabelInput
    min_quantity: number
    max_quantity: number
  }

  export type StockLabelUncheckedCreateWithoutLabelsInput = {
    account_id: string
    min_quantity: number
    max_quantity: number
  }

  export type StockLabelCreateOrConnectWithoutLabelsInput = {
    where: StockLabelWhereUniqueInput
    create: XOR<StockLabelCreateWithoutLabelsInput, StockLabelUncheckedCreateWithoutLabelsInput>
  }

  export type StockLabelCreateManyLabelsInputEnvelope = {
    data: Enumerable<StockLabelCreateManyLabelsInput>
    skipDuplicates?: boolean
  }

  export type StockHistoryCreateWithoutLabelsInput = {
    id?: string
    reason: string
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUncheckedCreateWithoutLabelsInput = {
    id?: string
    reason: string
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryCreateOrConnectWithoutLabelsInput = {
    where: StockHistoryWhereUniqueInput
    create: XOR<StockHistoryCreateWithoutLabelsInput, StockHistoryUncheckedCreateWithoutLabelsInput>
  }

  export type StockHistoryCreateManyLabelsInputEnvelope = {
    data: Enumerable<StockHistoryCreateManyLabelsInput>
    skipDuplicates?: boolean
  }

  export type LabelTypeUpsertWithoutLabelsInput = {
    update: XOR<LabelTypeUpdateWithoutLabelsInput, LabelTypeUncheckedUpdateWithoutLabelsInput>
    create: XOR<LabelTypeCreateWithoutLabelsInput, LabelTypeUncheckedCreateWithoutLabelsInput>
  }

  export type LabelTypeUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelTypeUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUpsertWithoutLabelsInput = {
    update: XOR<CountryUpdateWithoutLabelsInput, CountryUncheckedUpdateWithoutLabelsInput>
    create: XOR<CountryCreateWithoutLabelsInput, CountryUncheckedCreateWithoutLabelsInput>
  }

  export type CountryUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUncheckedUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpsertWithoutLabelsInput = {
    update: XOR<RegionUpdateWithoutLabelsInput, RegionUncheckedUpdateWithoutLabelsInput>
    create: XOR<RegionCreateWithoutLabelsInput, RegionUncheckedCreateWithoutLabelsInput>
  }

  export type RegionUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutRegionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUpsertWithoutLabelsInput = {
    update: XOR<WineTypeUpdateWithoutLabelsInput, WineTypeUncheckedUpdateWithoutLabelsInput>
    create: XOR<WineTypeCreateWithoutLabelsInput, WineTypeUncheckedCreateWithoutLabelsInput>
  }

  export type WineTypeUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeUpsertWithWhereUniqueWithoutLabelInput = {
    where: LabelGrapeWhereUniqueInput
    update: XOR<LabelGrapeUpdateWithoutLabelInput, LabelGrapeUncheckedUpdateWithoutLabelInput>
    create: XOR<LabelGrapeCreateWithoutLabelInput, LabelGrapeUncheckedCreateWithoutLabelInput>
  }

  export type LabelGrapeUpdateWithWhereUniqueWithoutLabelInput = {
    where: LabelGrapeWhereUniqueInput
    data: XOR<LabelGrapeUpdateWithoutLabelInput, LabelGrapeUncheckedUpdateWithoutLabelInput>
  }

  export type LabelGrapeUpdateManyWithWhereWithoutLabelInput = {
    where: LabelGrapeScalarWhereInput
    data: XOR<LabelGrapeUpdateManyMutationInput, LabelGrapeUncheckedUpdateManyWithoutLabel_grapeInput>
  }

  export type LabelGrapeScalarWhereInput = {
    AND?: Enumerable<LabelGrapeScalarWhereInput>
    OR?: Enumerable<LabelGrapeScalarWhereInput>
    NOT?: Enumerable<LabelGrapeScalarWhereInput>
    label_id?: StringFilter | string
    grape_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type OrderLabelUpsertWithWhereUniqueWithoutLabelInput = {
    where: OrderLabelWhereUniqueInput
    update: XOR<OrderLabelUpdateWithoutLabelInput, OrderLabelUncheckedUpdateWithoutLabelInput>
    create: XOR<OrderLabelCreateWithoutLabelInput, OrderLabelUncheckedCreateWithoutLabelInput>
  }

  export type OrderLabelUpdateWithWhereUniqueWithoutLabelInput = {
    where: OrderLabelWhereUniqueInput
    data: XOR<OrderLabelUpdateWithoutLabelInput, OrderLabelUncheckedUpdateWithoutLabelInput>
  }

  export type OrderLabelUpdateManyWithWhereWithoutLabelInput = {
    where: OrderLabelScalarWhereInput
    data: XOR<OrderLabelUpdateManyMutationInput, OrderLabelUncheckedUpdateManyWithoutOrder_labelInput>
  }

  export type OrderLabelScalarWhereInput = {
    AND?: Enumerable<OrderLabelScalarWhereInput>
    OR?: Enumerable<OrderLabelScalarWhereInput>
    NOT?: Enumerable<OrderLabelScalarWhereInput>
    order_id?: StringFilter | string
    label_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    quantity?: IntFilter | number
  }

  export type LabelCampaignUpsertWithWhereUniqueWithoutLabelInput = {
    where: LabelCampaignWhereUniqueInput
    update: XOR<LabelCampaignUpdateWithoutLabelInput, LabelCampaignUncheckedUpdateWithoutLabelInput>
    create: XOR<LabelCampaignCreateWithoutLabelInput, LabelCampaignUncheckedCreateWithoutLabelInput>
  }

  export type LabelCampaignUpdateWithWhereUniqueWithoutLabelInput = {
    where: LabelCampaignWhereUniqueInput
    data: XOR<LabelCampaignUpdateWithoutLabelInput, LabelCampaignUncheckedUpdateWithoutLabelInput>
  }

  export type LabelCampaignUpdateManyWithWhereWithoutLabelInput = {
    where: LabelCampaignScalarWhereInput
    data: XOR<LabelCampaignUpdateManyMutationInput, LabelCampaignUncheckedUpdateManyWithoutLabel_campaignInput>
  }

  export type StockLabelUpsertWithWhereUniqueWithoutLabelsInput = {
    where: StockLabelWhereUniqueInput
    update: XOR<StockLabelUpdateWithoutLabelsInput, StockLabelUncheckedUpdateWithoutLabelsInput>
    create: XOR<StockLabelCreateWithoutLabelsInput, StockLabelUncheckedCreateWithoutLabelsInput>
  }

  export type StockLabelUpdateWithWhereUniqueWithoutLabelsInput = {
    where: StockLabelWhereUniqueInput
    data: XOR<StockLabelUpdateWithoutLabelsInput, StockLabelUncheckedUpdateWithoutLabelsInput>
  }

  export type StockLabelUpdateManyWithWhereWithoutLabelsInput = {
    where: StockLabelScalarWhereInput
    data: XOR<StockLabelUpdateManyMutationInput, StockLabelUncheckedUpdateManyWithoutStockLabelInput>
  }

  export type StockHistoryUpsertWithWhereUniqueWithoutLabelsInput = {
    where: StockHistoryWhereUniqueInput
    update: XOR<StockHistoryUpdateWithoutLabelsInput, StockHistoryUncheckedUpdateWithoutLabelsInput>
    create: XOR<StockHistoryCreateWithoutLabelsInput, StockHistoryUncheckedCreateWithoutLabelsInput>
  }

  export type StockHistoryUpdateWithWhereUniqueWithoutLabelsInput = {
    where: StockHistoryWhereUniqueInput
    data: XOR<StockHistoryUpdateWithoutLabelsInput, StockHistoryUncheckedUpdateWithoutLabelsInput>
  }

  export type StockHistoryUpdateManyWithWhereWithoutLabelsInput = {
    where: StockHistoryScalarWhereInput
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyWithoutStockHistoryInput>
  }

  export type StockHistoryScalarWhereInput = {
    AND?: Enumerable<StockHistoryScalarWhereInput>
    OR?: Enumerable<StockHistoryScalarWhereInput>
    NOT?: Enumerable<StockHistoryScalarWhereInput>
    id?: StringFilter | string
    label_id?: StringFilter | string
    reason?: StringFilter | string
    quantity?: IntFilter | number
    date?: DateTimeFilter | Date | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type LabelCreateWithoutLabel_campaignInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutLabel_campaignInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutLabel_campaignInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutLabel_campaignInput, LabelUncheckedCreateWithoutLabel_campaignInput>
  }

  export type CampaignCreateWithoutLabel_campaignInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    account: AccountCreateNestedOneWithoutCampaignInput
    account_user: AccountUserCreateNestedOneWithoutCampaignsInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignUncheckedCreateWithoutLabel_campaignInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    type_id: string
    account_id: string
    account_user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignCreateOrConnectWithoutLabel_campaignInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLabel_campaignInput, CampaignUncheckedCreateWithoutLabel_campaignInput>
  }

  export type LabelUpsertWithoutLabel_campaignInput = {
    update: XOR<LabelUpdateWithoutLabel_campaignInput, LabelUncheckedUpdateWithoutLabel_campaignInput>
    create: XOR<LabelCreateWithoutLabel_campaignInput, LabelUncheckedCreateWithoutLabel_campaignInput>
  }

  export type LabelUpdateWithoutLabel_campaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutLabel_campaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type CampaignUpsertWithoutLabel_campaignInput = {
    update: XOR<CampaignUpdateWithoutLabel_campaignInput, CampaignUncheckedUpdateWithoutLabel_campaignInput>
    create: XOR<CampaignCreateWithoutLabel_campaignInput, CampaignUncheckedCreateWithoutLabel_campaignInput>
  }

  export type CampaignUpdateWithoutLabel_campaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    account_user?: AccountUserUpdateOneRequiredWithoutCampaignsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateWithoutLabel_campaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    account_user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateWithoutLabel_grapeInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutLabel_grapeInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutLabel_grapeInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutLabel_grapeInput, LabelUncheckedCreateWithoutLabel_grapeInput>
  }

  export type GrapeCreateWithoutLabelGrapeInput = {
    id?: string
    name: string
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUncheckedCreateWithoutLabelGrapeInput = {
    id?: string
    name: string
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeCreateOrConnectWithoutLabelGrapeInput = {
    where: GrapeWhereUniqueInput
    create: XOR<GrapeCreateWithoutLabelGrapeInput, GrapeUncheckedCreateWithoutLabelGrapeInput>
  }

  export type LabelUpsertWithoutLabel_grapeInput = {
    update: XOR<LabelUpdateWithoutLabel_grapeInput, LabelUncheckedUpdateWithoutLabel_grapeInput>
    create: XOR<LabelCreateWithoutLabel_grapeInput, LabelUncheckedCreateWithoutLabel_grapeInput>
  }

  export type LabelUpdateWithoutLabel_grapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutLabel_grapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type GrapeUpsertWithoutLabelGrapeInput = {
    update: XOR<GrapeUpdateWithoutLabelGrapeInput, GrapeUncheckedUpdateWithoutLabelGrapeInput>
    create: XOR<GrapeCreateWithoutLabelGrapeInput, GrapeUncheckedCreateWithoutLabelGrapeInput>
  }

  export type GrapeUpdateWithoutLabelGrapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeUncheckedUpdateWithoutLabelGrapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeCreateWithoutGrapeInput = {
    label: LabelCreateNestedOneWithoutLabel_grapeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeUncheckedCreateWithoutGrapeInput = {
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeCreateOrConnectWithoutGrapeInput = {
    where: LabelGrapeWhereUniqueInput
    create: XOR<LabelGrapeCreateWithoutGrapeInput, LabelGrapeUncheckedCreateWithoutGrapeInput>
  }

  export type LabelGrapeCreateManyGrapeInputEnvelope = {
    data: Enumerable<LabelGrapeCreateManyGrapeInput>
    skipDuplicates?: boolean
  }

  export type LabelGrapeUpsertWithWhereUniqueWithoutGrapeInput = {
    where: LabelGrapeWhereUniqueInput
    update: XOR<LabelGrapeUpdateWithoutGrapeInput, LabelGrapeUncheckedUpdateWithoutGrapeInput>
    create: XOR<LabelGrapeCreateWithoutGrapeInput, LabelGrapeUncheckedCreateWithoutGrapeInput>
  }

  export type LabelGrapeUpdateWithWhereUniqueWithoutGrapeInput = {
    where: LabelGrapeWhereUniqueInput
    data: XOR<LabelGrapeUpdateWithoutGrapeInput, LabelGrapeUncheckedUpdateWithoutGrapeInput>
  }

  export type LabelGrapeUpdateManyWithWhereWithoutGrapeInput = {
    where: LabelGrapeScalarWhereInput
    data: XOR<LabelGrapeUpdateManyMutationInput, LabelGrapeUncheckedUpdateManyWithoutLabelGrapeInput>
  }

  export type LabelCreateWithoutLabelTypeInput = {
    id?: string
    name: string
    description?: string | null
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutLabelTypeInput = {
    id?: string
    name: string
    description?: string | null
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutLabelTypeInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutLabelTypeInput, LabelUncheckedCreateWithoutLabelTypeInput>
  }

  export type LabelCreateManyLabelTypeInputEnvelope = {
    data: Enumerable<LabelCreateManyLabelTypeInput>
    skipDuplicates?: boolean
  }

  export type LabelUpsertWithWhereUniqueWithoutLabelTypeInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutLabelTypeInput, LabelUncheckedUpdateWithoutLabelTypeInput>
    create: XOR<LabelCreateWithoutLabelTypeInput, LabelUncheckedCreateWithoutLabelTypeInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutLabelTypeInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutLabelTypeInput, LabelUncheckedUpdateWithoutLabelTypeInput>
  }

  export type LabelUpdateManyWithWhereWithoutLabelTypeInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutLabelsInput>
  }

  export type LabelScalarWhereInput = {
    AND?: Enumerable<LabelScalarWhereInput>
    OR?: Enumerable<LabelScalarWhereInput>
    NOT?: Enumerable<LabelScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    type_id?: StringFilter | string
    country_id?: StringFilter | string
    region_id?: StringFilter | string
    harvest?: StringNullableFilter | string | null
    wine_type_id?: StringFilter | string
    alcohol_percentage?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    price?: FloatFilter | number
    promotional_price?: FloatNullableFilter | number | null
    is_active?: BoolFilter | boolean
    stock?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StateCreateWithoutCountryInput = {
    id?: string
    name: string
    slug: string
    regions?: RegionCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    slug: string
    regions?: RegionUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateCreateOrConnectWithoutCountryInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateCreateManyCountryInputEnvelope = {
    data: Enumerable<StateCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type LabelCreateWithoutCountryInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutCountryInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutCountryInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput>
  }

  export type LabelCreateManyCountryInputEnvelope = {
    data: Enumerable<LabelCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    update: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateUpdateWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    data: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
  }

  export type StateUpdateManyWithWhereWithoutCountryInput = {
    where: StateScalarWhereInput
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyWithoutStatesInput>
  }

  export type StateScalarWhereInput = {
    AND?: Enumerable<StateScalarWhereInput>
    OR?: Enumerable<StateScalarWhereInput>
    NOT?: Enumerable<StateScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    country_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type LabelUpsertWithWhereUniqueWithoutCountryInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutCountryInput, LabelUncheckedUpdateWithoutCountryInput>
    create: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutCountryInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutCountryInput, LabelUncheckedUpdateWithoutCountryInput>
  }

  export type LabelUpdateManyWithWhereWithoutCountryInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutLabelsInput>
  }

  export type CountryCreateWithoutStatesInput = {
    id?: string
    name: string
    slug: string
    value: string
    labels?: LabelCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUncheckedCreateWithoutStatesInput = {
    id?: string
    name: string
    slug: string
    value: string
    labels?: LabelUncheckedCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryCreateOrConnectWithoutStatesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type RegionCreateWithoutStateInput = {
    id?: string
    name: string
    slug: string
    subregion?: SubRegionCreateNestedManyWithoutRegionInput
    labels?: LabelCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    slug: string
    subregion?: SubRegionUncheckedCreateNestedManyWithoutRegionInput
    labels?: LabelUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionCreateOrConnectWithoutStateInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutStateInput, RegionUncheckedCreateWithoutStateInput>
  }

  export type RegionCreateManyStateInputEnvelope = {
    data: Enumerable<RegionCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutStateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityCreateOrConnectWithoutStateInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityCreateManyStateInputEnvelope = {
    data: Enumerable<CityCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutStatesInput = {
    update: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type CountryUpdateWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    labels?: LabelUncheckedUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpsertWithWhereUniqueWithoutStateInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutStateInput, RegionUncheckedUpdateWithoutStateInput>
    create: XOR<RegionCreateWithoutStateInput, RegionUncheckedCreateWithoutStateInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutStateInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutStateInput, RegionUncheckedUpdateWithoutStateInput>
  }

  export type RegionUpdateManyWithWhereWithoutStateInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutRegionsInput>
  }

  export type RegionScalarWhereInput = {
    AND?: Enumerable<RegionScalarWhereInput>
    OR?: Enumerable<RegionScalarWhereInput>
    NOT?: Enumerable<RegionScalarWhereInput>
    id?: StringFilter | string
    state_id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CityUpsertWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityUpdateWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithWhereWithoutStateInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    state_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StateCreateWithoutCitiesInput = {
    id?: string
    name: string
    slug: string
    country: CountryCreateNestedOneWithoutStatesInput
    regions?: RegionCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    slug: string
    country_id: string
    regions?: RegionUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateCreateOrConnectWithoutCitiesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type StateUpsertWithoutCitiesInput = {
    update: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type StateUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    regions?: RegionUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    regions?: RegionUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateWithoutRegionsInput = {
    id?: string
    name: string
    slug: string
    country: CountryCreateNestedOneWithoutStatesInput
    cities?: CityCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateWithoutRegionsInput = {
    id?: string
    name: string
    slug: string
    country_id: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateCreateOrConnectWithoutRegionsInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
  }

  export type SubRegionCreateWithoutRegionInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUncheckedCreateWithoutRegionInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionCreateOrConnectWithoutRegionInput = {
    where: SubRegionWhereUniqueInput
    create: XOR<SubRegionCreateWithoutRegionInput, SubRegionUncheckedCreateWithoutRegionInput>
  }

  export type SubRegionCreateManyRegionInputEnvelope = {
    data: Enumerable<SubRegionCreateManyRegionInput>
    skipDuplicates?: boolean
  }

  export type LabelCreateWithoutRegionInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutRegionInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutRegionInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutRegionInput, LabelUncheckedCreateWithoutRegionInput>
  }

  export type LabelCreateManyRegionInputEnvelope = {
    data: Enumerable<LabelCreateManyRegionInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithoutRegionsInput = {
    update: XOR<StateUpdateWithoutRegionsInput, StateUncheckedUpdateWithoutRegionsInput>
    create: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
  }

  export type StateUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUpsertWithWhereUniqueWithoutRegionInput = {
    where: SubRegionWhereUniqueInput
    update: XOR<SubRegionUpdateWithoutRegionInput, SubRegionUncheckedUpdateWithoutRegionInput>
    create: XOR<SubRegionCreateWithoutRegionInput, SubRegionUncheckedCreateWithoutRegionInput>
  }

  export type SubRegionUpdateWithWhereUniqueWithoutRegionInput = {
    where: SubRegionWhereUniqueInput
    data: XOR<SubRegionUpdateWithoutRegionInput, SubRegionUncheckedUpdateWithoutRegionInput>
  }

  export type SubRegionUpdateManyWithWhereWithoutRegionInput = {
    where: SubRegionScalarWhereInput
    data: XOR<SubRegionUpdateManyMutationInput, SubRegionUncheckedUpdateManyWithoutSubregionInput>
  }

  export type SubRegionScalarWhereInput = {
    AND?: Enumerable<SubRegionScalarWhereInput>
    OR?: Enumerable<SubRegionScalarWhereInput>
    NOT?: Enumerable<SubRegionScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    region_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type LabelUpsertWithWhereUniqueWithoutRegionInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutRegionInput, LabelUncheckedUpdateWithoutRegionInput>
    create: XOR<LabelCreateWithoutRegionInput, LabelUncheckedCreateWithoutRegionInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutRegionInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutRegionInput, LabelUncheckedUpdateWithoutRegionInput>
  }

  export type LabelUpdateManyWithWhereWithoutRegionInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutLabelsInput>
  }

  export type RegionCreateWithoutSubregionInput = {
    id?: string
    state: StateCreateNestedOneWithoutRegionsInput
    name: string
    slug: string
    labels?: LabelCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateWithoutSubregionInput = {
    id?: string
    state_id: string
    name: string
    slug: string
    labels?: LabelUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionCreateOrConnectWithoutSubregionInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
  }

  export type RegionUpsertWithoutSubregionInput = {
    update: XOR<RegionUpdateWithoutSubregionInput, RegionUncheckedUpdateWithoutSubregionInput>
    create: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
  }

  export type RegionUpdateWithoutSubregionInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutRegionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutSubregionInput = {
    id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    labels?: LabelUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateWithoutWine_typeInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutWine_typeInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutWine_typeInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutWine_typeInput, LabelUncheckedCreateWithoutWine_typeInput>
  }

  export type LabelCreateManyWine_typeInputEnvelope = {
    data: Enumerable<LabelCreateManyWine_typeInput>
    skipDuplicates?: boolean
  }

  export type LabelUpsertWithWhereUniqueWithoutWine_typeInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutWine_typeInput, LabelUncheckedUpdateWithoutWine_typeInput>
    create: XOR<LabelCreateWithoutWine_typeInput, LabelUncheckedCreateWithoutWine_typeInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutWine_typeInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutWine_typeInput, LabelUncheckedUpdateWithoutWine_typeInput>
  }

  export type LabelUpdateManyWithWhereWithoutWine_typeInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutLabelsInput>
  }

  export type AccountCreateWithoutOrderInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutOrderInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutOrderInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
  }

  export type OrderLabelCreateWithoutOrderInput = {
    label: LabelCreateNestedOneWithoutOrder_labelInput
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type OrderLabelUncheckedCreateWithoutOrderInput = {
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type OrderLabelCreateOrConnectWithoutOrderInput = {
    where: OrderLabelWhereUniqueInput
    create: XOR<OrderLabelCreateWithoutOrderInput, OrderLabelUncheckedCreateWithoutOrderInput>
  }

  export type OrderLabelCreateManyOrderInputEnvelope = {
    data: Enumerable<OrderLabelCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceCreateManyOrderInputEnvelope = {
    data: Enumerable<InvoiceCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutOrderInput = {
    update: XOR<AccountUpdateWithoutOrderInput, AccountUncheckedUpdateWithoutOrderInput>
    create: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
  }

  export type AccountUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderLabelUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderLabelWhereUniqueInput
    update: XOR<OrderLabelUpdateWithoutOrderInput, OrderLabelUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderLabelCreateWithoutOrderInput, OrderLabelUncheckedCreateWithoutOrderInput>
  }

  export type OrderLabelUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderLabelWhereUniqueInput
    data: XOR<OrderLabelUpdateWithoutOrderInput, OrderLabelUncheckedUpdateWithoutOrderInput>
  }

  export type OrderLabelUpdateManyWithWhereWithoutOrderInput = {
    where: OrderLabelScalarWhereInput
    data: XOR<OrderLabelUpdateManyMutationInput, OrderLabelUncheckedUpdateManyWithoutOrder_labelInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: Enumerable<InvoiceScalarWhereInput>
    OR?: Enumerable<InvoiceScalarWhereInput>
    NOT?: Enumerable<InvoiceScalarWhereInput>
    id?: StringFilter | string
    order_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type OrderCreateWithoutOrder_labelInput = {
    id?: string
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrder_labelInput = {
    id?: string
    code: string
    account_id: string
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrder_labelInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrder_labelInput, OrderUncheckedCreateWithoutOrder_labelInput>
  }

  export type LabelCreateWithoutOrder_labelInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutOrder_labelInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutOrder_labelInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutOrder_labelInput, LabelUncheckedCreateWithoutOrder_labelInput>
  }

  export type OrderUpsertWithoutOrder_labelInput = {
    update: XOR<OrderUpdateWithoutOrder_labelInput, OrderUncheckedUpdateWithoutOrder_labelInput>
    create: XOR<OrderCreateWithoutOrder_labelInput, OrderUncheckedCreateWithoutOrder_labelInput>
  }

  export type OrderUpdateWithoutOrder_labelInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrder_labelInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabelUpsertWithoutOrder_labelInput = {
    update: XOR<LabelUpdateWithoutOrder_labelInput, LabelUncheckedUpdateWithoutOrder_labelInput>
    create: XOR<LabelCreateWithoutOrder_labelInput, LabelUncheckedCreateWithoutOrder_labelInput>
  }

  export type LabelUpdateWithoutOrder_labelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutOrder_labelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type OrderCreateWithoutInvoiceInput = {
    id?: string
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    code: string
    account_id: string
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type OrderUpsertWithoutInvoiceInput = {
    update: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type OrderUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DeviceUserCreateWithoutDeviceInput = {
    user: UserCreateNestedOneWithoutDevice_userInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUncheckedCreateWithoutDeviceInput = {
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserCreateOrConnectWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserCreateManyDeviceInputEnvelope = {
    data: Enumerable<DeviceUserCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type PushNotificationCreateWithoutDeviceInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutPush_notificationInput
    title: string
    subject: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUncheckedCreateWithoutDeviceInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateOrConnectWithoutDeviceInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutDeviceInput, PushNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type PushNotificationCreateManyDeviceInputEnvelope = {
    data: Enumerable<PushNotificationCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type SmsNotificationCreateWithoutDeviceInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutSms_notificationInput
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUncheckedCreateWithoutDeviceInput = {
    id?: string
    notification_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationCreateOrConnectWithoutDeviceInput = {
    where: SmsNotificationWhereUniqueInput
    create: XOR<SmsNotificationCreateWithoutDeviceInput, SmsNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type SmsNotificationCreateManyDeviceInputEnvelope = {
    data: Enumerable<SmsNotificationCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type DeviceNotificationCreateWithoutDeviceInput = {
    notification: NotificationsCreateNestedOneWithoutDevice_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUncheckedCreateWithoutDeviceInput = {
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateOrConnectWithoutDeviceInput = {
    where: DeviceNotificationWhereUniqueInput
    create: XOR<DeviceNotificationCreateWithoutDeviceInput, DeviceNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceNotificationCreateManyDeviceInputEnvelope = {
    data: Enumerable<DeviceNotificationCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type DeviceUserUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    update: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    data: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceUserUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceUserScalarWhereInput
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyWithoutDevice_userInput>
  }

  export type PushNotificationUpsertWithWhereUniqueWithoutDeviceInput = {
    where: PushNotificationWhereUniqueInput
    update: XOR<PushNotificationUpdateWithoutDeviceInput, PushNotificationUncheckedUpdateWithoutDeviceInput>
    create: XOR<PushNotificationCreateWithoutDeviceInput, PushNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type PushNotificationUpdateWithWhereUniqueWithoutDeviceInput = {
    where: PushNotificationWhereUniqueInput
    data: XOR<PushNotificationUpdateWithoutDeviceInput, PushNotificationUncheckedUpdateWithoutDeviceInput>
  }

  export type PushNotificationUpdateManyWithWhereWithoutDeviceInput = {
    where: PushNotificationScalarWhereInput
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyWithoutPush_notificationInput>
  }

  export type PushNotificationScalarWhereInput = {
    AND?: Enumerable<PushNotificationScalarWhereInput>
    OR?: Enumerable<PushNotificationScalarWhereInput>
    NOT?: Enumerable<PushNotificationScalarWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    title?: StringFilter | string
    subject?: StringFilter | string
    send?: StringNullableFilter | string | null
    device_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SmsNotificationUpsertWithWhereUniqueWithoutDeviceInput = {
    where: SmsNotificationWhereUniqueInput
    update: XOR<SmsNotificationUpdateWithoutDeviceInput, SmsNotificationUncheckedUpdateWithoutDeviceInput>
    create: XOR<SmsNotificationCreateWithoutDeviceInput, SmsNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type SmsNotificationUpdateWithWhereUniqueWithoutDeviceInput = {
    where: SmsNotificationWhereUniqueInput
    data: XOR<SmsNotificationUpdateWithoutDeviceInput, SmsNotificationUncheckedUpdateWithoutDeviceInput>
  }

  export type SmsNotificationUpdateManyWithWhereWithoutDeviceInput = {
    where: SmsNotificationScalarWhereInput
    data: XOR<SmsNotificationUpdateManyMutationInput, SmsNotificationUncheckedUpdateManyWithoutSms_notificationInput>
  }

  export type SmsNotificationScalarWhereInput = {
    AND?: Enumerable<SmsNotificationScalarWhereInput>
    OR?: Enumerable<SmsNotificationScalarWhereInput>
    NOT?: Enumerable<SmsNotificationScalarWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    device_id?: StringFilter | string
    to?: StringFilter | string
    subject?: StringFilter | string
    body?: StringFilter | string
    send?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceNotificationUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceNotificationWhereUniqueInput
    update: XOR<DeviceNotificationUpdateWithoutDeviceInput, DeviceNotificationUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceNotificationCreateWithoutDeviceInput, DeviceNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceNotificationUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceNotificationWhereUniqueInput
    data: XOR<DeviceNotificationUpdateWithoutDeviceInput, DeviceNotificationUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceNotificationUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceNotificationScalarWhereInput
    data: XOR<DeviceNotificationUpdateManyMutationInput, DeviceNotificationUncheckedUpdateManyWithoutDevice_notificationInput>
  }

  export type DeviceNotificationScalarWhereInput = {
    AND?: Enumerable<DeviceNotificationScalarWhereInput>
    OR?: Enumerable<DeviceNotificationScalarWhereInput>
    NOT?: Enumerable<DeviceNotificationScalarWhereInput>
    device_id?: StringFilter | string
    notification_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceCreateWithoutDevice_userInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDevice_userInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDevice_userInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
  }

  export type UserCreateWithoutDevice_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    city: string
    zipcode: string
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    account_user?: AccountUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevice_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    city: string
    zipcode: string
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    account_user?: AccountUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevice_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
  }

  export type DeviceUpsertWithoutDevice_userInput = {
    update: XOR<DeviceUpdateWithoutDevice_userInput, DeviceUncheckedUpdateWithoutDevice_userInput>
    create: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
  }

  export type DeviceUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserUpsertWithoutDevice_userInput = {
    update: XOR<UserUpdateWithoutDevice_userInput, UserUncheckedUpdateWithoutDevice_userInput>
    create: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
  }

  export type UserUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    account_user?: AccountUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    account_user?: AccountUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SmsNotificationCreateWithoutNotificationInput = {
    id?: string
    device: DeviceCreateNestedOneWithoutSms_notificationInput
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUncheckedCreateWithoutNotificationInput = {
    id?: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationCreateOrConnectWithoutNotificationInput = {
    where: SmsNotificationWhereUniqueInput
    create: XOR<SmsNotificationCreateWithoutNotificationInput, SmsNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type SmsNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<SmsNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type EmailNotificationCreateWithoutNotificationInput = {
    id?: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUncheckedCreateWithoutNotificationInput = {
    id?: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationCreateOrConnectWithoutNotificationInput = {
    where: EmailNotificationWhereUniqueInput
    create: XOR<EmailNotificationCreateWithoutNotificationInput, EmailNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type EmailNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<EmailNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type PushNotificationCreateWithoutNotificationInput = {
    id?: string
    title: string
    subject: string
    send?: string | null
    device: DeviceCreateNestedOneWithoutPush_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUncheckedCreateWithoutNotificationInput = {
    id?: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateOrConnectWithoutNotificationInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutNotificationInput, PushNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type PushNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<PushNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type DeviceNotificationCreateWithoutNotificationInput = {
    device: DeviceCreateNestedOneWithoutDevice_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUncheckedCreateWithoutNotificationInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateOrConnectWithoutNotificationInput = {
    where: DeviceNotificationWhereUniqueInput
    create: XOR<DeviceNotificationCreateWithoutNotificationInput, DeviceNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type DeviceNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<DeviceNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type SmsNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: SmsNotificationWhereUniqueInput
    update: XOR<SmsNotificationUpdateWithoutNotificationInput, SmsNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<SmsNotificationCreateWithoutNotificationInput, SmsNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type SmsNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: SmsNotificationWhereUniqueInput
    data: XOR<SmsNotificationUpdateWithoutNotificationInput, SmsNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type SmsNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: SmsNotificationScalarWhereInput
    data: XOR<SmsNotificationUpdateManyMutationInput, SmsNotificationUncheckedUpdateManyWithoutSms_notificationInput>
  }

  export type EmailNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: EmailNotificationWhereUniqueInput
    update: XOR<EmailNotificationUpdateWithoutNotificationInput, EmailNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<EmailNotificationCreateWithoutNotificationInput, EmailNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type EmailNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: EmailNotificationWhereUniqueInput
    data: XOR<EmailNotificationUpdateWithoutNotificationInput, EmailNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type EmailNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: EmailNotificationScalarWhereInput
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyWithoutEmail_notificationInput>
  }

  export type EmailNotificationScalarWhereInput = {
    AND?: Enumerable<EmailNotificationScalarWhereInput>
    OR?: Enumerable<EmailNotificationScalarWhereInput>
    NOT?: Enumerable<EmailNotificationScalarWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    to?: StringFilter | string
    from?: StringFilter | string
    from_name?: StringFilter | string
    cc?: StringNullableFilter | string | null
    bcc?: StringNullableFilter | string | null
    type?: EnumEmailTypeNotificationFilter | EmailTypeNotification
    subject?: StringFilter | string
    body?: StringFilter | string
    url_callback?: StringFilter | string
    opened?: StringNullableFilter | string | null
    clicked?: StringNullableFilter | string | null
    failed?: StringNullableFilter | string | null
    error_description?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PushNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: PushNotificationWhereUniqueInput
    update: XOR<PushNotificationUpdateWithoutNotificationInput, PushNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<PushNotificationCreateWithoutNotificationInput, PushNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type PushNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: PushNotificationWhereUniqueInput
    data: XOR<PushNotificationUpdateWithoutNotificationInput, PushNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type PushNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: PushNotificationScalarWhereInput
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyWithoutPush_notificationInput>
  }

  export type DeviceNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: DeviceNotificationWhereUniqueInput
    update: XOR<DeviceNotificationUpdateWithoutNotificationInput, DeviceNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<DeviceNotificationCreateWithoutNotificationInput, DeviceNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type DeviceNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: DeviceNotificationWhereUniqueInput
    data: XOR<DeviceNotificationUpdateWithoutNotificationInput, DeviceNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type DeviceNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: DeviceNotificationScalarWhereInput
    data: XOR<DeviceNotificationUpdateManyMutationInput, DeviceNotificationUncheckedUpdateManyWithoutDevice_notificationInput>
  }

  export type NotificationsCreateWithoutEmail_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutEmail_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutEmail_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
  }

  export type NotificationsUpsertWithoutEmail_notificationInput = {
    update: XOR<NotificationsUpdateWithoutEmail_notificationInput, NotificationsUncheckedUpdateWithoutEmail_notificationInput>
    create: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
  }

  export type NotificationsUpdateWithoutEmail_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutEmail_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsCreateWithoutSms_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutSms_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutSms_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
  }

  export type DeviceCreateWithoutSms_notificationInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSms_notificationInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSms_notificationInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
  }

  export type NotificationsUpsertWithoutSms_notificationInput = {
    update: XOR<NotificationsUpdateWithoutSms_notificationInput, NotificationsUncheckedUpdateWithoutSms_notificationInput>
    create: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
  }

  export type NotificationsUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type DeviceUpsertWithoutSms_notificationInput = {
    update: XOR<DeviceUpdateWithoutSms_notificationInput, DeviceUncheckedUpdateWithoutSms_notificationInput>
    create: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
  }

  export type DeviceUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type NotificationsCreateWithoutPush_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutPush_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutPush_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
  }

  export type DeviceCreateWithoutPush_notificationInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutPush_notificationInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutPush_notificationInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
  }

  export type NotificationsUpsertWithoutPush_notificationInput = {
    update: XOR<NotificationsUpdateWithoutPush_notificationInput, NotificationsUncheckedUpdateWithoutPush_notificationInput>
    create: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
  }

  export type NotificationsUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type DeviceUpsertWithoutPush_notificationInput = {
    update: XOR<DeviceUpdateWithoutPush_notificationInput, DeviceUncheckedUpdateWithoutPush_notificationInput>
    create: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
  }

  export type DeviceUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateWithoutDevice_notificationInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDevice_notificationInput = {
    id?: string
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDevice_notificationInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
  }

  export type NotificationsCreateWithoutDevice_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutDevice_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutDevice_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
  }

  export type DeviceUpsertWithoutDevice_notificationInput = {
    update: XOR<DeviceUpdateWithoutDevice_notificationInput, DeviceUncheckedUpdateWithoutDevice_notificationInput>
    create: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
  }

  export type DeviceUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type NotificationsUpsertWithoutDevice_notificationInput = {
    update: XOR<NotificationsUpdateWithoutDevice_notificationInput, NotificationsUncheckedUpdateWithoutDevice_notificationInput>
    create: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
  }

  export type NotificationsUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type PaymentCycleCreateWithoutPlansInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCycleUncheckedCreateWithoutPlansInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCycleCreateOrConnectWithoutPlansInput = {
    where: PaymentCycleWhereUniqueInput
    create: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
  }

  export type AccountCreateWithoutPlanInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutPlanInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutPlanInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPlanInput, AccountUncheckedCreateWithoutPlanInput>
  }

  export type AccountCreateManyPlanInputEnvelope = {
    data: Enumerable<AccountCreateManyPlanInput>
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    account: AccountCreateNestedOneWithoutSubscriptionInput
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyPlanInput>
    skipDuplicates?: boolean
  }

  export type PaymentCycleUpsertWithoutPlansInput = {
    update: XOR<PaymentCycleUpdateWithoutPlansInput, PaymentCycleUncheckedUpdateWithoutPlansInput>
    create: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
  }

  export type PaymentCycleUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCycleUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutPlanInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutPlanInput, AccountUncheckedUpdateWithoutPlanInput>
    create: XOR<AccountCreateWithoutPlanInput, AccountUncheckedCreateWithoutPlanInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutPlanInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutPlanInput, AccountUncheckedUpdateWithoutPlanInput>
  }

  export type AccountUpdateManyWithWhereWithoutPlanInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntFilter | number
    name?: StringFilter | string
    cpf_cnpj?: StringNullableFilter | string | null
    market_name?: StringFilter | string
    email?: StringFilter | string
    phone?: StringNullableFilter | string | null
    whatsapp?: StringNullableFilter | string | null
    logo?: StringNullableFilter | string | null
    person_type?: EnumPersonTypeFilter | PersonType
    site?: StringNullableFilter | string | null
    social_reason?: StringNullableFilter | string | null
    facebook_url?: StringNullableFilter | string | null
    instagram_url?: StringNullableFilter | string | null
    banner?: StringNullableFilter | string | null
    gender?: EnumGenderTypeFilter | GenderType
    street?: StringFilter | string
    number?: StringFilter | string
    district?: StringFilter | string
    country?: StringFilter | string
    state?: StringFilter | string
    complement?: StringNullableFilter | string | null
    zipcode?: StringFilter | string
    plan_id?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    domain?: StringFilter | string
    isActive?: BoolFilter | boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PlanCreateWithoutPayment_cycleInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    account?: AccountCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutPayment_cycleInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    account?: AccountUncheckedCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutPayment_cycleInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutPayment_cycleInput, PlanUncheckedCreateWithoutPayment_cycleInput>
  }

  export type PlanCreateManyPayment_cycleInputEnvelope = {
    data: Enumerable<PlanCreateManyPayment_cycleInput>
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithWhereUniqueWithoutPayment_cycleInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutPayment_cycleInput, PlanUncheckedUpdateWithoutPayment_cycleInput>
    create: XOR<PlanCreateWithoutPayment_cycleInput, PlanUncheckedCreateWithoutPayment_cycleInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutPayment_cycleInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutPayment_cycleInput, PlanUncheckedUpdateWithoutPayment_cycleInput>
  }

  export type PlanUpdateManyWithWhereWithoutPayment_cycleInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutPlansInput>
  }

  export type PlanScalarWhereInput = {
    AND?: Enumerable<PlanScalarWhereInput>
    OR?: Enumerable<PlanScalarWhereInput>
    NOT?: Enumerable<PlanScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    slug?: StringFilter | string
    price?: FloatFilter | number
    max_users?: IntFilter | number
    max_labels?: IntFilter | number
    payment_cycle_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PlanCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle: PaymentCycleCreateNestedOneWithoutPlansInput
    account?: AccountCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    account?: AccountUncheckedCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanCreateOrConnectWithoutSubscriptionInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
  }

  export type AccountCreateWithoutSubscriptionInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutSubscriptionInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type PlanUpsertWithoutSubscriptionInput = {
    update: XOR<PlanUpdateWithoutSubscriptionInput, PlanUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
  }

  export type PlanUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle?: PaymentCycleUpdateOneRequiredWithoutPlansNestedInput
    account?: AccountUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    account?: AccountUncheckedUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithoutSubscriptionInput = {
    update: XOR<AccountUpdateWithoutSubscriptionInput, AccountUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type AccountUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabelCreateWithoutStockLabelInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockHistory?: StockHistoryCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutStockLabelInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockHistory?: StockHistoryUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutStockLabelInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutStockLabelInput, LabelUncheckedCreateWithoutStockLabelInput>
  }

  export type AccountCreateWithoutStockLabelInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutStockLabelInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutStockLabelInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutStockLabelInput, AccountUncheckedCreateWithoutStockLabelInput>
  }

  export type LabelUpsertWithoutStockLabelInput = {
    update: XOR<LabelUpdateWithoutStockLabelInput, LabelUncheckedUpdateWithoutStockLabelInput>
    create: XOR<LabelCreateWithoutStockLabelInput, LabelUncheckedCreateWithoutStockLabelInput>
  }

  export type LabelUpdateWithoutStockLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutStockLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type AccountUpsertWithoutStockLabelInput = {
    update: XOR<AccountUpdateWithoutStockLabelInput, AccountUncheckedUpdateWithoutStockLabelInput>
    create: XOR<AccountCreateWithoutStockLabelInput, AccountUncheckedCreateWithoutStockLabelInput>
  }

  export type AccountUpdateWithoutStockLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutStockLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabelCreateWithoutStockHistoryInput = {
    id?: string
    name: string
    description?: string | null
    labelType: LabelTypeCreateNestedOneWithoutLabelsInput
    country: CountryCreateNestedOneWithoutLabelsInput
    region: RegionCreateNestedOneWithoutLabelsInput
    harvest?: string | null
    wine_type: WineTypeCreateNestedOneWithoutLabelsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateWithoutStockHistoryInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    label_grape?: LabelGrapeUncheckedCreateNestedManyWithoutLabelInput
    order_label?: OrderLabelUncheckedCreateNestedManyWithoutLabelInput
    label_campaign?: LabelCampaignUncheckedCreateNestedManyWithoutLabelInput
    StockLabel?: StockLabelUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelCreateOrConnectWithoutStockHistoryInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutStockHistoryInput, LabelUncheckedCreateWithoutStockHistoryInput>
  }

  export type LabelUpsertWithoutStockHistoryInput = {
    update: XOR<LabelUpdateWithoutStockHistoryInput, LabelUncheckedUpdateWithoutStockHistoryInput>
    create: XOR<LabelCreateWithoutStockHistoryInput, LabelUncheckedCreateWithoutStockHistoryInput>
  }

  export type LabelUpdateWithoutStockHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutStockHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type CampaignCreateManyAccountInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    type_id: string
    account_user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateManyAccountInput = {
    id?: string
    plan_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderCreateManyAccountInput = {
    id?: string
    code: string
    total: number
    coupon_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesCreateManyAccountInput = {
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountUserCreateManyAccountInput = {
    id?: string
    user_id: string
    role_id: string
  }

  export type StockLabelCreateManyAccountInput = {
    label_id: string
    min_quantity: number
    max_quantity: number
  }

  export type CampaignUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    account_user?: AccountUserUpdateOneRequiredWithoutCampaignsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    account_user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    account_user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_label?: OrderLabelUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUpdateWithoutAccountInput = {
    activities?: ActivitiesUpdateOneRequiredWithoutAccount_activitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateWithoutAccountInput = {
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateManyWithoutAccount_activitiesInput = {
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAccount_userNestedInput
    role?: RoleUpdateOneRequiredWithoutAccountUserNestedInput
    campaigns?: CampaignUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    campaigns?: CampaignUncheckedUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateManyWithoutAccount_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type StockLabelUpdateWithoutAccountInput = {
    labels?: LabelUpdateOneRequiredWithoutStockLabelNestedInput
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockLabelUncheckedUpdateWithoutAccountInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockLabelUncheckedUpdateManyWithoutStockLabelInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type AccountActivitiesCreateManyActivitiesInput = {
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUpdateWithoutActivitiesInput = {
    account?: AccountUpdateOneRequiredWithoutAccount_activitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateWithoutActivitiesInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateManyUserInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountUserCreateManyUserInput = {
    id?: string
    account_id: string
    role_id: string
  }

  export type DeviceUserUpdateWithoutUserInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_userNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateWithoutUserInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateManyWithoutDevice_userInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_usersNestedInput
    role?: RoleUpdateOneRequiredWithoutAccountUserNestedInput
    campaigns?: CampaignUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    campaigns?: CampaignUncheckedUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateManyWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateManyAccount_userInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    type_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignUpdateWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    role_id: string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRolePermissionInput = {
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyRoleInput = {
    permission_id: string
  }

  export type AccountUserCreateManyRoleInput = {
    id?: string
    account_id: string
    user_id: string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    permission?: PermisionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permission_id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_usersNestedInput
    user?: UserUpdateOneRequiredWithoutAccount_userNestedInput
    campaigns?: CampaignUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    campaigns?: CampaignUncheckedUpdateManyWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateManyWithoutAccountUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type LabelCampaignCreateManyCampaignInput = {
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCampaignUpdateWithoutCampaignInput = {
    label?: LabelUpdateOneRequiredWithoutLabel_campaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCampaignUncheckedUpdateWithoutCampaignInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCampaignUncheckedUpdateManyWithoutLabel_campaignInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyCampaign_typeInput = {
    id?: string
    name: string
    description?: string | null
    percentage_discount?: number | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    account_id: string
    account_user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignUpdateWithoutCampaign_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    account_user?: AccountUserUpdateOneRequiredWithoutCampaignsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaign_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage_discount?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    account_user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type LabelGrapeCreateManyLabelInput = {
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderLabelCreateManyLabelInput = {
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type LabelCampaignCreateManyLabelInput = {
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockLabelCreateManyLabelsInput = {
    account_id: string
    min_quantity: number
    max_quantity: number
  }

  export type StockHistoryCreateManyLabelsInput = {
    id?: string
    reason: string
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeUpdateWithoutLabelInput = {
    grape?: GrapeUpdateOneRequiredWithoutLabelGrapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeUncheckedUpdateWithoutLabelInput = {
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeUncheckedUpdateManyWithoutLabel_grapeInput = {
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderLabelUpdateWithoutLabelInput = {
    order?: OrderUpdateOneRequiredWithoutOrder_labelNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderLabelUncheckedUpdateWithoutLabelInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderLabelUncheckedUpdateManyWithoutOrder_labelInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type LabelCampaignUpdateWithoutLabelInput = {
    campaign?: CampaignUpdateOneRequiredWithoutLabel_campaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCampaignUncheckedUpdateWithoutLabelInput = {
    campaign_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLabelUpdateWithoutLabelsInput = {
    account?: AccountUpdateOneRequiredWithoutStockLabelNestedInput
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockLabelUncheckedUpdateWithoutLabelsInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockHistoryUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateManyWithoutStockHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeCreateManyGrapeInput = {
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelGrapeUpdateWithoutGrapeInput = {
    label?: LabelUpdateOneRequiredWithoutLabel_grapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeUncheckedUpdateWithoutGrapeInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelGrapeUncheckedUpdateManyWithoutLabelGrapeInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateManyLabelTypeInput = {
    id?: string
    name: string
    description?: string | null
    country_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelUpdateWithoutLabelTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutLabelTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateManyWithoutLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateManyCountryInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCreateManyCountryInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    region_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    regions?: RegionUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    regions?: RegionUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateManyWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type RegionCreateManyStateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityCreateManyStateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUpdateManyWithoutRegionNestedInput
    labels?: LabelUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUncheckedUpdateManyWithoutRegionNestedInput
    labels?: LabelUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionCreateManyRegionInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelCreateManyRegionInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    harvest?: string | null
    wine_type_id: string
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateManyWithoutSubregionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type?: WineTypeUpdateOneRequiredWithoutLabelsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    wine_type_id?: StringFieldUpdateOperationsInput | string
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type LabelCreateManyWine_typeInput = {
    id?: string
    name: string
    description?: string | null
    type_id: string
    country_id: string
    region_id: string
    harvest?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    is_active?: boolean
    stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LabelUpdateWithoutWine_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    labelType?: LabelTypeUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneRequiredWithoutLabelsNestedInput
    region?: RegionUpdateOneRequiredWithoutLabelsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUpdateManyWithoutLabelsNestedInput
  }

  export type LabelUncheckedUpdateWithoutWine_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_grape?: LabelGrapeUncheckedUpdateManyWithoutLabelNestedInput
    order_label?: OrderLabelUncheckedUpdateManyWithoutLabelNestedInput
    label_campaign?: LabelCampaignUncheckedUpdateManyWithoutLabelNestedInput
    StockLabel?: StockLabelUncheckedUpdateManyWithoutLabelsNestedInput
    StockHistory?: StockHistoryUncheckedUpdateManyWithoutLabelsNestedInput
  }

  export type OrderLabelCreateManyOrderInput = {
    label_id: string
    created_at?: Date | string
    updated_at?: Date | string
    quantity: number
  }

  export type InvoiceCreateManyOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderLabelUpdateWithoutOrderInput = {
    label?: LabelUpdateOneRequiredWithoutOrder_labelNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderLabelUncheckedUpdateWithoutOrderInput = {
    label_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateManyDeviceInput = {
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateManyDeviceInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationCreateManyDeviceInput = {
    id?: string
    notification_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateManyDeviceInput = {
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUpdateWithoutDeviceInput = {
    user?: UserUpdateOneRequiredWithoutDevice_userNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateWithoutDeviceInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutPush_notificationNestedInput
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateManyWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutSms_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateManyWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUpdateWithoutDeviceInput = {
    notification?: NotificationsUpdateOneRequiredWithoutDevice_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateWithoutDeviceInput = {
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateManyWithoutDevice_notificationInput = {
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationCreateManyNotificationInput = {
    id?: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationCreateManyNotificationInput = {
    id?: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateManyNotificationInput = {
    id?: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateManyNotificationInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneRequiredWithoutSms_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateManyWithoutEmail_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutPush_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUpdateWithoutNotificationInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateWithoutNotificationInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyPlanInput = {
    id?: string
    external_id: number
    name: string
    cpf_cnpj?: string | null
    market_name: string
    email: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    district: string
    country: string
    state: string
    complement?: string | null
    zipcode: string
    created_at?: Date | string
    updated_at?: Date | string
    domain: string
    isActive?: boolean
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    StockLabel?: StockLabelUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutSubscriptionNestedInput
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateManyPayment_cycleInput = {
    id?: string
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUpdateWithoutPayment_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    account?: AccountUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutPayment_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    account?: AccountUncheckedUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}