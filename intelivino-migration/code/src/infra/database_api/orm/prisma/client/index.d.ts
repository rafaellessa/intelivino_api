
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  external_id: number | null
  name: string
  email: string
  cpf_cnpj: string | null
  market_name: string
  phone: string | null
  whatsapp: string | null
  logo: string | null
  person_type: PersonType
  site: string | null
  social_reason: string | null
  facebook_url: string | null
  instagram_url: string | null
  banner: string | null
  gender: GenderType
  street: string
  number: string
  complement: string | null
  district: string
  city: string
  state: string
  zipcode: string
  plan_id: string | null
  created_at: Date
  updated_at: Date
  domain: string
  isActive: boolean
}

/**
 * Model AccountConfiguration
 * 
 */
export type AccountConfiguration = {
  id: string
  account_id: string
  banner_market_url: string | null
  header_color: string | null
}

/**
 * Model AccountActivities
 * 
 */
export type AccountActivities = {
  account_id: string
  activities_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Activities
 * 
 */
export type Activities = {
  id: string
  external_id: number | null
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Delivery
 * 
 */
export type Delivery = {
  id: string
  external_id: number | null
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model AccountDelivery
 * 
 */
export type AccountDelivery = {
  account_id: string
  delivery_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string
  email: string
  password: string
  whatsapp: string | null
  phone: string | null
  cpf_cnpj: string | null
  photo: string | null
  gender: GenderType
  birthdate: Date | null
  google_id: string | null
  apple_id: string | null
  facebook_id: string | null
  rd_station_id: string | null
  rd_station_sync: boolean | null
  created_at: Date
  updated_at: Date
  lastLogin: Date
}

/**
 * Model UserAddress
 * 
 */
export type UserAddress = {
  id: string
  user_id: string
  name: string | null
  street: string
  number: string
  district: string
  state: string
  complement: string | null
  additional_information: string | null
  city: string
  zip_code: string
  created_at: Date
  updated_at: Date
}

/**
 * Model AccountUser
 * 
 */
export type AccountUser = {
  id: string
  account_id: string
  user_id: string
  role_id: string
}

/**
 * Model Permision
 * 
 */
export type Permision = {
  id: string
  name: string
}

/**
 * Model RolePermission
 * 
 */
export type RolePermission = {
  role_id: string
  permission_id: string
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: string
  name: string
}

/**
 * Model Campaign
 * 
 */
export type Campaign = {
  id: string
  external_id: number | null
  name: string
  description: string | null
  discount_value: number | null
  discount_type: CampaignTypeDiscount | null
  start_date: Date | null
  expiration_date: Date | null
  campaign_type_id: string
  account_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model CampaignType
 * 
 */
export type CampaignType = {
  id: string
  external_id: number | null
  name: string
  slug: string
}

/**
 * Model Coupon
 * 
 */
export type Coupon = {
  id: string
  code: string
  account_id: string
  dicount_type: CouponDiscountType
  discount_value: number
  couponUse_type: CouponUseType
  inital_date: Date
  expiration_date: Date | null
  min_value: number | null
  max_value: number | null
  created_at: Date
  updated_at: Date
}

/**
 * Model Item
 * 
 */
export type Item = {
  id: string
  external_id: number | null
  name: string
  description: string | null
  type_id: string
  country_id: string | null
  region_id: string | null
  winery_id: string | null
  harvest: string | null
  no_harvest: boolean
  wine_type_id: string | null
  alcohol_percentage: Prisma.Decimal | null
  price: number
  promotional_price: number | null
  photo: string | null
  account_id: string
  is_active: boolean
  control_stock: boolean
  created_at: Date
  updated_at: Date
}

/**
 * Model ItemType
 * 
 */
export type ItemType = {
  id: string
  external_id: number | null
  name: string
  description: string | null
  created_at: Date
  updated_at: Date
}

/**
 * Model Tag
 * 
 */
export type Tag = {
  id: string
  name: string
  description: string | null
  created_at: Date
  updated_at: Date
}

/**
 * Model ItemTag
 * 
 */
export type ItemTag = {
  item_id: string
  tag_id: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model CampaignItem
 * 
 */
export type CampaignItem = {
  item_id: string
  campaign_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model ItemGrape
 * 
 */
export type ItemGrape = {
  item_id: string
  grape_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Grape
 * 
 */
export type Grape = {
  id: string
  external_id: number | null
  name: string
  created_at: Date
  updatedAt: Date
}

/**
 * Model Country
 * 
 */
export type Country = {
  id: string
  external_id: number | null
  name: string
  slug: string
  value: string
  created_at: Date
  updated_at: Date
}

/**
 * Model State
 * 
 */
export type State = {
  id: string
  external_id: number | null
  name: string
  slug: string
  country_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model City
 * 
 */
export type City = {
  id: string
  external_id: number | null
  name: string
  slug: string
  state_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Region
 * 
 */
export type Region = {
  id: string
  external_id: number | null
  state_id: string
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model SubRegion
 * 
 */
export type SubRegion = {
  id: string
  external_id: number | null
  name: string
  slug: string
  region_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model WineType
 * 
 */
export type WineType = {
  id: string
  external_id: number | null
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: string
  external_id: number | null
  code: string
  account_id: string
  total: number
  coupon_id: string | null
  user_id: string
  user_address_id: string
  is_read: boolean
  order_status_id: string
  campaign_id: string | null
  created_at: Date
  updated_at: Date
}

/**
 * Model OrderStatus
 * 
 */
export type OrderStatus = {
  id: string
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Customer
 * 
 */
export type Customer = {
  id: string
  account_id: string
  email: string
  mobile_phone: string
  phone: string
  is_active: boolean
  created_at: Date
  updated_at: Date
  origin_registration: CustomerOriginRegistration
  cpf_cnpj: string
  note: string
  converted: boolean
}

/**
 * Model OrderItem
 * 
 */
export type OrderItem = {
  order_id: string
  item_id: string
  created_at: Date
  updated_at: Date
  price: number
  quantity: number
}

/**
 * Model Invoice
 * 
 */
export type Invoice = {
  id: string
  order_id: string
  account_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Device
 * 
 */
export type Device = {
  id: string
  external_id: number | null
  device_physical_id: string
  platform: PlatformType
  version: string
  token_notification: string
  created_at: Date
  updated_at: Date
}

/**
 * Model DeviceUser
 * 
 */
export type DeviceUser = {
  device_id: string
  user_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Notifications
 * 
 */
export type Notifications = {
  id: string
  title: string
  message: string
  created_at: Date
  updated_at: Date
  type: TypeNotification
}

/**
 * Model EmailNotification
 * 
 */
export type EmailNotification = {
  id: string
  notification_id: string
  to: string
  from: string
  from_name: string
  cc: string | null
  bcc: string | null
  type: EmailTypeNotification
  subject: string
  body: string
  url_callback: string
  opened: string | null
  clicked: string | null
  failed: string | null
  error_description: string | null
  created_at: Date
  updated_at: Date
}

/**
 * Model SmsNotification
 * 
 */
export type SmsNotification = {
  id: string
  notification_id: string
  device_id: string
  to: string
  subject: string
  body: string
  send: string | null
  created_at: Date
  updated_at: Date
}

/**
 * Model PushNotification
 * 
 */
export type PushNotification = {
  id: string
  notification_id: string
  title: string
  subject: string
  send: string | null
  device_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model DeviceNotification
 * 
 */
export type DeviceNotification = {
  device_id: string
  notification_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Plan
 * 
 */
export type Plan = {
  id: string
  external_id: number | null
  name: string
  description: string
  slug: string
  price: number
  max_users: number
  max_labels: number
  payment_cycle_id: string
  created_at: Date
  updated_at: Date
}

/**
 * Model PaymentCycle
 * 
 */
export type PaymentCycle = {
  id: string
  name: string
  slug: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Subscription
 * 
 */
export type Subscription = {
  id: string
  plan_id: string
  account_id: string
  due: Date
  price: number
  created_at: Date
  updated_at: Date
}

/**
 * Model StockItem
 * 
 */
export type StockItem = {
  item_id: string
  account_id: string
  quantity: number
  min_quantity: number
  max_quantity: number
}

/**
 * Model StockHistory
 * 
 */
export type StockHistory = {
  id: string
  item_id: string
  reason: string | null
  operation: StockHistoryType
  quantity: number
  date: Date
  created_at: Date
  updated_at: Date
}

/**
 * Model Winery
 * 
 */
export type Winery = {
  id: string
  external_id: number | null
  name: string
  created_at: Date
  updated_at: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CampaignTypeDiscount: {
  PERCENTAGE: 'PERCENTAGE',
  VALUE: 'VALUE'
};

export type CampaignTypeDiscount = (typeof CampaignTypeDiscount)[keyof typeof CampaignTypeDiscount]


export const CouponDiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  VALUE: 'VALUE'
};

export type CouponDiscountType = (typeof CouponDiscountType)[keyof typeof CouponDiscountType]


export const CouponUseType: {
  UNLIMITED: 'UNLIMITED',
  UNIQUE_BY_USER: 'UNIQUE_BY_USER',
  UNIQUE: 'UNIQUE'
};

export type CouponUseType = (typeof CouponUseType)[keyof typeof CouponUseType]


export const CustomerOriginRegistration: {
  SINGLE_REGISTRATION: 'SINGLE_REGISTRATION',
  CAMPAIGN: 'CAMPAIGN',
  MAIN_CATALOG: 'MAIN_CATALOG'
};

export type CustomerOriginRegistration = (typeof CustomerOriginRegistration)[keyof typeof CustomerOriginRegistration]


export const EmailTypeNotification: {
  html: 'html',
  text: 'text'
};

export type EmailTypeNotification = (typeof EmailTypeNotification)[keyof typeof EmailTypeNotification]


export const GenderType: {
  F: 'F',
  M: 'M',
  ND: 'ND'
};

export type GenderType = (typeof GenderType)[keyof typeof GenderType]


export const PersonType: {
  F: 'F',
  J: 'J'
};

export type PersonType = (typeof PersonType)[keyof typeof PersonType]


export const PlatformType: {
  android: 'android',
  ios: 'ios'
};

export type PlatformType = (typeof PlatformType)[keyof typeof PlatformType]


export const StockHistoryType: {
  INPUT: 'INPUT',
  OUTPUT: 'OUTPUT'
};

export type StockHistoryType = (typeof StockHistoryType)[keyof typeof StockHistoryType]


export const TypeNotification: {
  email: 'email',
  sms: 'sms',
  push: 'push'
};

export type TypeNotification = (typeof TypeNotification)[keyof typeof TypeNotification]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.accountConfiguration`: Exposes CRUD operations for the **AccountConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountConfigurations
    * const accountConfigurations = await prisma.accountConfiguration.findMany()
    * ```
    */
  get accountConfiguration(): Prisma.AccountConfigurationDelegate<GlobalReject>;

  /**
   * `prisma.accountActivities`: Exposes CRUD operations for the **AccountActivities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountActivities
    * const accountActivities = await prisma.accountActivities.findMany()
    * ```
    */
  get accountActivities(): Prisma.AccountActivitiesDelegate<GlobalReject>;

  /**
   * `prisma.activities`: Exposes CRUD operations for the **Activities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activities.findMany()
    * ```
    */
  get activities(): Prisma.ActivitiesDelegate<GlobalReject>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<GlobalReject>;

  /**
   * `prisma.accountDelivery`: Exposes CRUD operations for the **AccountDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountDeliveries
    * const accountDeliveries = await prisma.accountDelivery.findMany()
    * ```
    */
  get accountDelivery(): Prisma.AccountDeliveryDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<GlobalReject>;

  /**
   * `prisma.accountUser`: Exposes CRUD operations for the **AccountUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountUsers
    * const accountUsers = await prisma.accountUser.findMany()
    * ```
    */
  get accountUser(): Prisma.AccountUserDelegate<GlobalReject>;

  /**
   * `prisma.permision`: Exposes CRUD operations for the **Permision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permisions
    * const permisions = await prisma.permision.findMany()
    * ```
    */
  get permision(): Prisma.PermisionDelegate<GlobalReject>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<GlobalReject>;

  /**
   * `prisma.campaignType`: Exposes CRUD operations for the **CampaignType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTypes
    * const campaignTypes = await prisma.campaignType.findMany()
    * ```
    */
  get campaignType(): Prisma.CampaignTypeDelegate<GlobalReject>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<GlobalReject>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<GlobalReject>;

  /**
   * `prisma.itemType`: Exposes CRUD operations for the **ItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTypes
    * const itemTypes = await prisma.itemType.findMany()
    * ```
    */
  get itemType(): Prisma.ItemTypeDelegate<GlobalReject>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<GlobalReject>;

  /**
   * `prisma.itemTag`: Exposes CRUD operations for the **ItemTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTags
    * const itemTags = await prisma.itemTag.findMany()
    * ```
    */
  get itemTag(): Prisma.ItemTagDelegate<GlobalReject>;

  /**
   * `prisma.campaignItem`: Exposes CRUD operations for the **CampaignItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignItems
    * const campaignItems = await prisma.campaignItem.findMany()
    * ```
    */
  get campaignItem(): Prisma.CampaignItemDelegate<GlobalReject>;

  /**
   * `prisma.itemGrape`: Exposes CRUD operations for the **ItemGrape** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemGrapes
    * const itemGrapes = await prisma.itemGrape.findMany()
    * ```
    */
  get itemGrape(): Prisma.ItemGrapeDelegate<GlobalReject>;

  /**
   * `prisma.grape`: Exposes CRUD operations for the **Grape** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grapes
    * const grapes = await prisma.grape.findMany()
    * ```
    */
  get grape(): Prisma.GrapeDelegate<GlobalReject>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<GlobalReject>;

  /**
   * `prisma.subRegion`: Exposes CRUD operations for the **SubRegion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubRegions
    * const subRegions = await prisma.subRegion.findMany()
    * ```
    */
  get subRegion(): Prisma.SubRegionDelegate<GlobalReject>;

  /**
   * `prisma.wineType`: Exposes CRUD operations for the **WineType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WineTypes
    * const wineTypes = await prisma.wineType.findMany()
    * ```
    */
  get wineType(): Prisma.WineTypeDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.orderStatus`: Exposes CRUD operations for the **OrderStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderStatuses
    * const orderStatuses = await prisma.orderStatus.findMany()
    * ```
    */
  get orderStatus(): Prisma.OrderStatusDelegate<GlobalReject>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<GlobalReject>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<GlobalReject>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<GlobalReject>;

  /**
   * `prisma.deviceUser`: Exposes CRUD operations for the **DeviceUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceUsers
    * const deviceUsers = await prisma.deviceUser.findMany()
    * ```
    */
  get deviceUser(): Prisma.DeviceUserDelegate<GlobalReject>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<GlobalReject>;

  /**
   * `prisma.emailNotification`: Exposes CRUD operations for the **EmailNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailNotifications
    * const emailNotifications = await prisma.emailNotification.findMany()
    * ```
    */
  get emailNotification(): Prisma.EmailNotificationDelegate<GlobalReject>;

  /**
   * `prisma.smsNotification`: Exposes CRUD operations for the **SmsNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmsNotifications
    * const smsNotifications = await prisma.smsNotification.findMany()
    * ```
    */
  get smsNotification(): Prisma.SmsNotificationDelegate<GlobalReject>;

  /**
   * `prisma.pushNotification`: Exposes CRUD operations for the **PushNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushNotifications
    * const pushNotifications = await prisma.pushNotification.findMany()
    * ```
    */
  get pushNotification(): Prisma.PushNotificationDelegate<GlobalReject>;

  /**
   * `prisma.deviceNotification`: Exposes CRUD operations for the **DeviceNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceNotifications
    * const deviceNotifications = await prisma.deviceNotification.findMany()
    * ```
    */
  get deviceNotification(): Prisma.DeviceNotificationDelegate<GlobalReject>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<GlobalReject>;

  /**
   * `prisma.paymentCycle`: Exposes CRUD operations for the **PaymentCycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentCycles
    * const paymentCycles = await prisma.paymentCycle.findMany()
    * ```
    */
  get paymentCycle(): Prisma.PaymentCycleDelegate<GlobalReject>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.stockItem`: Exposes CRUD operations for the **StockItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockItems
    * const stockItems = await prisma.stockItem.findMany()
    * ```
    */
  get stockItem(): Prisma.StockItemDelegate<GlobalReject>;

  /**
   * `prisma.stockHistory`: Exposes CRUD operations for the **StockHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockHistories
    * const stockHistories = await prisma.stockHistory.findMany()
    * ```
    */
  get stockHistory(): Prisma.StockHistoryDelegate<GlobalReject>;

  /**
   * `prisma.winery`: Exposes CRUD operations for the **Winery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wineries
    * const wineries = await prisma.winery.findMany()
    * ```
    */
  get winery(): Prisma.WineryDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export type Extension = runtime.Extension 

  /**
   * Prisma Client JS version: 4.5.0
   * Query Engine version: 0362da9eebca54d94c8ef5edd3b2e90af99ba452
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Account: 'Account',
    AccountConfiguration: 'AccountConfiguration',
    AccountActivities: 'AccountActivities',
    Activities: 'Activities',
    Delivery: 'Delivery',
    AccountDelivery: 'AccountDelivery',
    User: 'User',
    UserAddress: 'UserAddress',
    AccountUser: 'AccountUser',
    Permision: 'Permision',
    RolePermission: 'RolePermission',
    Role: 'Role',
    Campaign: 'Campaign',
    CampaignType: 'CampaignType',
    Coupon: 'Coupon',
    Item: 'Item',
    ItemType: 'ItemType',
    Tag: 'Tag',
    ItemTag: 'ItemTag',
    CampaignItem: 'CampaignItem',
    ItemGrape: 'ItemGrape',
    Grape: 'Grape',
    Country: 'Country',
    State: 'State',
    City: 'City',
    Region: 'Region',
    SubRegion: 'SubRegion',
    WineType: 'WineType',
    Order: 'Order',
    OrderStatus: 'OrderStatus',
    Customer: 'Customer',
    OrderItem: 'OrderItem',
    Invoice: 'Invoice',
    Device: 'Device',
    DeviceUser: 'DeviceUser',
    Notifications: 'Notifications',
    EmailNotification: 'EmailNotification',
    SmsNotification: 'SmsNotification',
    PushNotification: 'PushNotification',
    DeviceNotification: 'DeviceNotification',
    Plan: 'Plan',
    PaymentCycle: 'PaymentCycle',
    Subscription: 'Subscription',
    StockItem: 'StockItem',
    StockHistory: 'StockHistory',
    Winery: 'Winery'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */


  export type AccountCountOutputType = {
    campaign: number
    subscription: number
    order: number
    account_activities: number
    account_deliveries: number
    account_users: number
    invoices: number
    stock_items: number
    items: number
    coupons: number
    customers: number
  }

  export type AccountCountOutputTypeSelect = {
    campaign?: boolean
    subscription?: boolean
    order?: boolean
    account_activities?: boolean
    account_deliveries?: boolean
    account_users?: boolean
    invoices?: boolean
    stock_items?: boolean
    items?: boolean
    coupons?: boolean
    customers?: boolean
  }

  export type AccountCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AccountCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AccountCountOutputType
    : S extends undefined
    ? never
    : S extends AccountCountOutputTypeArgs
    ?'include' extends U
    ? AccountCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AccountCountOutputType ? AccountCountOutputType[P] : never
  } 
    : AccountCountOutputType
  : AccountCountOutputType




  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     * 
    **/
    select?: AccountCountOutputTypeSelect | null
  }



  /**
   * Count Type ActivitiesCountOutputType
   */


  export type ActivitiesCountOutputType = {
    account_activities: number
  }

  export type ActivitiesCountOutputTypeSelect = {
    account_activities?: boolean
  }

  export type ActivitiesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ActivitiesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ActivitiesCountOutputType
    : S extends undefined
    ? never
    : S extends ActivitiesCountOutputTypeArgs
    ?'include' extends U
    ? ActivitiesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ActivitiesCountOutputType ? ActivitiesCountOutputType[P] : never
  } 
    : ActivitiesCountOutputType
  : ActivitiesCountOutputType




  // Custom InputTypes

  /**
   * ActivitiesCountOutputType without action
   */
  export type ActivitiesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ActivitiesCountOutputType
     * 
    **/
    select?: ActivitiesCountOutputTypeSelect | null
  }



  /**
   * Count Type DeliveryCountOutputType
   */


  export type DeliveryCountOutputType = {
    account_deliveries: number
  }

  export type DeliveryCountOutputTypeSelect = {
    account_deliveries?: boolean
  }

  export type DeliveryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DeliveryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DeliveryCountOutputType
    : S extends undefined
    ? never
    : S extends DeliveryCountOutputTypeArgs
    ?'include' extends U
    ? DeliveryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DeliveryCountOutputType ? DeliveryCountOutputType[P] : never
  } 
    : DeliveryCountOutputType
  : DeliveryCountOutputType




  // Custom InputTypes

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeliveryCountOutputType
     * 
    **/
    select?: DeliveryCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    device_user: number
    account_user: number
    orders: number
    user_addresses: number
  }

  export type UserCountOutputTypeSelect = {
    device_user?: boolean
    account_user?: boolean
    orders?: boolean
    user_addresses?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type UserAddressCountOutputType
   */


  export type UserAddressCountOutputType = {
    orders: number
  }

  export type UserAddressCountOutputTypeSelect = {
    orders?: boolean
  }

  export type UserAddressCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserAddressCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserAddressCountOutputType
    : S extends undefined
    ? never
    : S extends UserAddressCountOutputTypeArgs
    ?'include' extends U
    ? UserAddressCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserAddressCountOutputType ? UserAddressCountOutputType[P] : never
  } 
    : UserAddressCountOutputType
  : UserAddressCountOutputType




  // Custom InputTypes

  /**
   * UserAddressCountOutputType without action
   */
  export type UserAddressCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserAddressCountOutputType
     * 
    **/
    select?: UserAddressCountOutputTypeSelect | null
  }



  /**
   * Count Type PermisionCountOutputType
   */


  export type PermisionCountOutputType = {
    RolePermission: number
  }

  export type PermisionCountOutputTypeSelect = {
    RolePermission?: boolean
  }

  export type PermisionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PermisionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PermisionCountOutputType
    : S extends undefined
    ? never
    : S extends PermisionCountOutputTypeArgs
    ?'include' extends U
    ? PermisionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PermisionCountOutputType ? PermisionCountOutputType[P] : never
  } 
    : PermisionCountOutputType
  : PermisionCountOutputType




  // Custom InputTypes

  /**
   * PermisionCountOutputType without action
   */
  export type PermisionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PermisionCountOutputType
     * 
    **/
    select?: PermisionCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    RolePermission: number
    AccountUser: number
  }

  export type RoleCountOutputTypeSelect = {
    RolePermission?: boolean
    AccountUser?: boolean
  }

  export type RoleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RoleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RoleCountOutputType
    : S extends undefined
    ? never
    : S extends RoleCountOutputTypeArgs
    ?'include' extends U
    ? RoleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
    : RoleCountOutputType
  : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     * 
    **/
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type CampaignCountOutputType
   */


  export type CampaignCountOutputType = {
    orders: number
    campaign_items: number
  }

  export type CampaignCountOutputTypeSelect = {
    orders?: boolean
    campaign_items?: boolean
  }

  export type CampaignCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CampaignCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignCountOutputType
    : S extends undefined
    ? never
    : S extends CampaignCountOutputTypeArgs
    ?'include' extends U
    ? CampaignCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CampaignCountOutputType ? CampaignCountOutputType[P] : never
  } 
    : CampaignCountOutputType
  : CampaignCountOutputType




  // Custom InputTypes

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     * 
    **/
    select?: CampaignCountOutputTypeSelect | null
  }



  /**
   * Count Type CampaignTypeCountOutputType
   */


  export type CampaignTypeCountOutputType = {
    Campaign: number
  }

  export type CampaignTypeCountOutputTypeSelect = {
    Campaign?: boolean
  }

  export type CampaignTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CampaignTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignTypeCountOutputType
    : S extends undefined
    ? never
    : S extends CampaignTypeCountOutputTypeArgs
    ?'include' extends U
    ? CampaignTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CampaignTypeCountOutputType ? CampaignTypeCountOutputType[P] : never
  } 
    : CampaignTypeCountOutputType
  : CampaignTypeCountOutputType




  // Custom InputTypes

  /**
   * CampaignTypeCountOutputType without action
   */
  export type CampaignTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignTypeCountOutputType
     * 
    **/
    select?: CampaignTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type CouponCountOutputType
   */


  export type CouponCountOutputType = {
    orders: number
  }

  export type CouponCountOutputTypeSelect = {
    orders?: boolean
  }

  export type CouponCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CouponCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CouponCountOutputType
    : S extends undefined
    ? never
    : S extends CouponCountOutputTypeArgs
    ?'include' extends U
    ? CouponCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CouponCountOutputType ? CouponCountOutputType[P] : never
  } 
    : CouponCountOutputType
  : CouponCountOutputType




  // Custom InputTypes

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     * 
    **/
    select?: CouponCountOutputTypeSelect | null
  }



  /**
   * Count Type ItemCountOutputType
   */


  export type ItemCountOutputType = {
    item_grape: number
    order_items: number
    campaign_items: number
    stock_items: number
    stock_history: number
    ItemTag: number
  }

  export type ItemCountOutputTypeSelect = {
    item_grape?: boolean
    order_items?: boolean
    campaign_items?: boolean
    stock_items?: boolean
    stock_history?: boolean
    ItemTag?: boolean
  }

  export type ItemCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ItemCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ItemCountOutputType
    : S extends undefined
    ? never
    : S extends ItemCountOutputTypeArgs
    ?'include' extends U
    ? ItemCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ItemCountOutputType ? ItemCountOutputType[P] : never
  } 
    : ItemCountOutputType
  : ItemCountOutputType




  // Custom InputTypes

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     * 
    **/
    select?: ItemCountOutputTypeSelect | null
  }



  /**
   * Count Type ItemTypeCountOutputType
   */


  export type ItemTypeCountOutputType = {
    items: number
  }

  export type ItemTypeCountOutputTypeSelect = {
    items?: boolean
  }

  export type ItemTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ItemTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ItemTypeCountOutputType
    : S extends undefined
    ? never
    : S extends ItemTypeCountOutputTypeArgs
    ?'include' extends U
    ? ItemTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ItemTypeCountOutputType ? ItemTypeCountOutputType[P] : never
  } 
    : ItemTypeCountOutputType
  : ItemTypeCountOutputType




  // Custom InputTypes

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ItemTypeCountOutputType
     * 
    **/
    select?: ItemTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type TagCountOutputType
   */


  export type TagCountOutputType = {
    ItemTag: number
  }

  export type TagCountOutputTypeSelect = {
    ItemTag?: boolean
  }

  export type TagCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TagCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TagCountOutputType
    : S extends undefined
    ? never
    : S extends TagCountOutputTypeArgs
    ?'include' extends U
    ? TagCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TagCountOutputType ? TagCountOutputType[P] : never
  } 
    : TagCountOutputType
  : TagCountOutputType




  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     * 
    **/
    select?: TagCountOutputTypeSelect | null
  }



  /**
   * Count Type GrapeCountOutputType
   */


  export type GrapeCountOutputType = {
    item_grape: number
  }

  export type GrapeCountOutputTypeSelect = {
    item_grape?: boolean
  }

  export type GrapeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | GrapeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? GrapeCountOutputType
    : S extends undefined
    ? never
    : S extends GrapeCountOutputTypeArgs
    ?'include' extends U
    ? GrapeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof GrapeCountOutputType ? GrapeCountOutputType[P] : never
  } 
    : GrapeCountOutputType
  : GrapeCountOutputType




  // Custom InputTypes

  /**
   * GrapeCountOutputType without action
   */
  export type GrapeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GrapeCountOutputType
     * 
    **/
    select?: GrapeCountOutputTypeSelect | null
  }



  /**
   * Count Type CountryCountOutputType
   */


  export type CountryCountOutputType = {
    states: number
    items: number
  }

  export type CountryCountOutputTypeSelect = {
    states?: boolean
    items?: boolean
  }

  export type CountryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CountryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CountryCountOutputType
    : S extends undefined
    ? never
    : S extends CountryCountOutputTypeArgs
    ?'include' extends U
    ? CountryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CountryCountOutputType ? CountryCountOutputType[P] : never
  } 
    : CountryCountOutputType
  : CountryCountOutputType




  // Custom InputTypes

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     * 
    **/
    select?: CountryCountOutputTypeSelect | null
  }



  /**
   * Count Type StateCountOutputType
   */


  export type StateCountOutputType = {
    regions: number
    cities: number
  }

  export type StateCountOutputTypeSelect = {
    regions?: boolean
    cities?: boolean
  }

  export type StateCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StateCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StateCountOutputType
    : S extends undefined
    ? never
    : S extends StateCountOutputTypeArgs
    ?'include' extends U
    ? StateCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StateCountOutputType ? StateCountOutputType[P] : never
  } 
    : StateCountOutputType
  : StateCountOutputType




  // Custom InputTypes

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     * 
    **/
    select?: StateCountOutputTypeSelect | null
  }



  /**
   * Count Type RegionCountOutputType
   */


  export type RegionCountOutputType = {
    subregion: number
    items: number
  }

  export type RegionCountOutputTypeSelect = {
    subregion?: boolean
    items?: boolean
  }

  export type RegionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RegionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RegionCountOutputType
    : S extends undefined
    ? never
    : S extends RegionCountOutputTypeArgs
    ?'include' extends U
    ? RegionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RegionCountOutputType ? RegionCountOutputType[P] : never
  } 
    : RegionCountOutputType
  : RegionCountOutputType




  // Custom InputTypes

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     * 
    **/
    select?: RegionCountOutputTypeSelect | null
  }



  /**
   * Count Type WineTypeCountOutputType
   */


  export type WineTypeCountOutputType = {
    items: number
  }

  export type WineTypeCountOutputTypeSelect = {
    items?: boolean
  }

  export type WineTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WineTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WineTypeCountOutputType
    : S extends undefined
    ? never
    : S extends WineTypeCountOutputTypeArgs
    ?'include' extends U
    ? WineTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WineTypeCountOutputType ? WineTypeCountOutputType[P] : never
  } 
    : WineTypeCountOutputType
  : WineTypeCountOutputType




  // Custom InputTypes

  /**
   * WineTypeCountOutputType without action
   */
  export type WineTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WineTypeCountOutputType
     * 
    **/
    select?: WineTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    order_items: number
    invoice: number
  }

  export type OrderCountOutputTypeSelect = {
    order_items?: boolean
    invoice?: boolean
  }

  export type OrderCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderCountOutputType
    : S extends undefined
    ? never
    : S extends OrderCountOutputTypeArgs
    ?'include' extends U
    ? OrderCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
    : OrderCountOutputType
  : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     * 
    **/
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderStatusCountOutputType
   */


  export type OrderStatusCountOutputType = {
    orders: number
  }

  export type OrderStatusCountOutputTypeSelect = {
    orders?: boolean
  }

  export type OrderStatusCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderStatusCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderStatusCountOutputType
    : S extends undefined
    ? never
    : S extends OrderStatusCountOutputTypeArgs
    ?'include' extends U
    ? OrderStatusCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderStatusCountOutputType ? OrderStatusCountOutputType[P] : never
  } 
    : OrderStatusCountOutputType
  : OrderStatusCountOutputType




  // Custom InputTypes

  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderStatusCountOutputType
     * 
    **/
    select?: OrderStatusCountOutputTypeSelect | null
  }



  /**
   * Count Type DeviceCountOutputType
   */


  export type DeviceCountOutputType = {
    device_user: number
    push_notification: number
    sms_notification: number
    device_notification: number
  }

  export type DeviceCountOutputTypeSelect = {
    device_user?: boolean
    push_notification?: boolean
    sms_notification?: boolean
    device_notification?: boolean
  }

  export type DeviceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DeviceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DeviceCountOutputType
    : S extends undefined
    ? never
    : S extends DeviceCountOutputTypeArgs
    ?'include' extends U
    ? DeviceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DeviceCountOutputType ? DeviceCountOutputType[P] : never
  } 
    : DeviceCountOutputType
  : DeviceCountOutputType




  // Custom InputTypes

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     * 
    **/
    select?: DeviceCountOutputTypeSelect | null
  }



  /**
   * Count Type NotificationsCountOutputType
   */


  export type NotificationsCountOutputType = {
    sms_notification: number
    email_notification: number
    push_notification: number
    device_notification: number
  }

  export type NotificationsCountOutputTypeSelect = {
    sms_notification?: boolean
    email_notification?: boolean
    push_notification?: boolean
    device_notification?: boolean
  }

  export type NotificationsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | NotificationsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? NotificationsCountOutputType
    : S extends undefined
    ? never
    : S extends NotificationsCountOutputTypeArgs
    ?'include' extends U
    ? NotificationsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof NotificationsCountOutputType ? NotificationsCountOutputType[P] : never
  } 
    : NotificationsCountOutputType
  : NotificationsCountOutputType




  // Custom InputTypes

  /**
   * NotificationsCountOutputType without action
   */
  export type NotificationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the NotificationsCountOutputType
     * 
    **/
    select?: NotificationsCountOutputTypeSelect | null
  }



  /**
   * Count Type PlanCountOutputType
   */


  export type PlanCountOutputType = {
    account: number
    subscription: number
  }

  export type PlanCountOutputTypeSelect = {
    account?: boolean
    subscription?: boolean
  }

  export type PlanCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PlanCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PlanCountOutputType
    : S extends undefined
    ? never
    : S extends PlanCountOutputTypeArgs
    ?'include' extends U
    ? PlanCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlanCountOutputType ? PlanCountOutputType[P] : never
  } 
    : PlanCountOutputType
  : PlanCountOutputType




  // Custom InputTypes

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     * 
    **/
    select?: PlanCountOutputTypeSelect | null
  }



  /**
   * Count Type PaymentCycleCountOutputType
   */


  export type PaymentCycleCountOutputType = {
    plans: number
  }

  export type PaymentCycleCountOutputTypeSelect = {
    plans?: boolean
  }

  export type PaymentCycleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PaymentCycleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PaymentCycleCountOutputType
    : S extends undefined
    ? never
    : S extends PaymentCycleCountOutputTypeArgs
    ?'include' extends U
    ? PaymentCycleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PaymentCycleCountOutputType ? PaymentCycleCountOutputType[P] : never
  } 
    : PaymentCycleCountOutputType
  : PaymentCycleCountOutputType




  // Custom InputTypes

  /**
   * PaymentCycleCountOutputType without action
   */
  export type PaymentCycleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycleCountOutputType
     * 
    **/
    select?: PaymentCycleCountOutputTypeSelect | null
  }



  /**
   * Count Type WineryCountOutputType
   */


  export type WineryCountOutputType = {
    items: number
  }

  export type WineryCountOutputTypeSelect = {
    items?: boolean
  }

  export type WineryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WineryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WineryCountOutputType
    : S extends undefined
    ? never
    : S extends WineryCountOutputTypeArgs
    ?'include' extends U
    ? WineryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WineryCountOutputType ? WineryCountOutputType[P] : never
  } 
    : WineryCountOutputType
  : WineryCountOutputType




  // Custom InputTypes

  /**
   * WineryCountOutputType without action
   */
  export type WineryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WineryCountOutputType
     * 
    **/
    select?: WineryCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    external_id: number | null
  }

  export type AccountSumAggregateOutputType = {
    external_id: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    email: string | null
    cpf_cnpj: string | null
    market_name: string | null
    phone: string | null
    whatsapp: string | null
    logo: string | null
    person_type: PersonType | null
    site: string | null
    social_reason: string | null
    facebook_url: string | null
    instagram_url: string | null
    banner: string | null
    gender: GenderType | null
    street: string | null
    number: string | null
    complement: string | null
    district: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    plan_id: string | null
    created_at: Date | null
    updated_at: Date | null
    domain: string | null
    isActive: boolean | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    email: string | null
    cpf_cnpj: string | null
    market_name: string | null
    phone: string | null
    whatsapp: string | null
    logo: string | null
    person_type: PersonType | null
    site: string | null
    social_reason: string | null
    facebook_url: string | null
    instagram_url: string | null
    banner: string | null
    gender: GenderType | null
    street: string | null
    number: string | null
    complement: string | null
    district: string | null
    city: string | null
    state: string | null
    zipcode: string | null
    plan_id: string | null
    created_at: Date | null
    updated_at: Date | null
    domain: string | null
    isActive: boolean | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    email: number
    cpf_cnpj: number
    market_name: number
    phone: number
    whatsapp: number
    logo: number
    person_type: number
    site: number
    social_reason: number
    facebook_url: number
    instagram_url: number
    banner: number
    gender: number
    street: number
    number: number
    complement: number
    district: number
    city: number
    state: number
    zipcode: number
    plan_id: number
    created_at: number
    updated_at: number
    domain: number
    isActive: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    external_id?: true
  }

  export type AccountSumAggregateInputType = {
    external_id?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    email?: true
    cpf_cnpj?: true
    market_name?: true
    phone?: true
    whatsapp?: true
    logo?: true
    person_type?: true
    site?: true
    social_reason?: true
    facebook_url?: true
    instagram_url?: true
    banner?: true
    gender?: true
    street?: true
    number?: true
    complement?: true
    district?: true
    city?: true
    state?: true
    zipcode?: true
    plan_id?: true
    created_at?: true
    updated_at?: true
    domain?: true
    isActive?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    email?: true
    cpf_cnpj?: true
    market_name?: true
    phone?: true
    whatsapp?: true
    logo?: true
    person_type?: true
    site?: true
    social_reason?: true
    facebook_url?: true
    instagram_url?: true
    banner?: true
    gender?: true
    street?: true
    number?: true
    complement?: true
    district?: true
    city?: true
    state?: true
    zipcode?: true
    plan_id?: true
    created_at?: true
    updated_at?: true
    domain?: true
    isActive?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    email?: true
    cpf_cnpj?: true
    market_name?: true
    phone?: true
    whatsapp?: true
    logo?: true
    person_type?: true
    site?: true
    social_reason?: true
    facebook_url?: true
    instagram_url?: true
    banner?: true
    gender?: true
    street?: true
    number?: true
    complement?: true
    district?: true
    city?: true
    state?: true
    zipcode?: true
    plan_id?: true
    created_at?: true
    updated_at?: true
    domain?: true
    isActive?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    email: string
    cpf_cnpj: string | null
    market_name: string
    phone: string | null
    whatsapp: string | null
    logo: string | null
    person_type: PersonType
    site: string | null
    social_reason: string | null
    facebook_url: string | null
    instagram_url: string | null
    banner: string | null
    gender: GenderType
    street: string
    number: string
    complement: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id: string | null
    created_at: Date
    updated_at: Date
    domain: string
    isActive: boolean
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    email?: boolean
    cpf_cnpj?: boolean
    market_name?: boolean
    phone?: boolean
    whatsapp?: boolean
    logo?: boolean
    person_type?: boolean
    site?: boolean
    social_reason?: boolean
    facebook_url?: boolean
    instagram_url?: boolean
    banner?: boolean
    gender?: boolean
    campaign?: boolean | CampaignFindManyArgs
    street?: boolean
    number?: boolean
    complement?: boolean
    district?: boolean
    city?: boolean
    state?: boolean
    zipcode?: boolean
    plan_id?: boolean
    plan?: boolean | PlanArgs
    subscription?: boolean | SubscriptionFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    order?: boolean | OrderFindManyArgs
    account_activities?: boolean | AccountActivitiesFindManyArgs
    account_deliveries?: boolean | AccountDeliveryFindManyArgs
    account_users?: boolean | AccountUserFindManyArgs
    invoices?: boolean | InvoiceFindManyArgs
    domain?: boolean
    stock_items?: boolean | StockItemFindManyArgs
    items?: boolean | ItemFindManyArgs
    coupons?: boolean | CouponFindManyArgs
    account_configuration?: boolean | AccountConfigurationArgs
    customers?: boolean | CustomerFindManyArgs
    isActive?: boolean
    _count?: boolean | AccountCountOutputTypeArgs
  }

  export type AccountInclude = {
    campaign?: boolean | CampaignFindManyArgs
    plan?: boolean | PlanArgs
    subscription?: boolean | SubscriptionFindManyArgs
    order?: boolean | OrderFindManyArgs
    account_activities?: boolean | AccountActivitiesFindManyArgs
    account_deliveries?: boolean | AccountDeliveryFindManyArgs
    account_users?: boolean | AccountUserFindManyArgs
    invoices?: boolean | InvoiceFindManyArgs
    stock_items?: boolean | StockItemFindManyArgs
    items?: boolean | ItemFindManyArgs
    coupons?: boolean | CouponFindManyArgs
    account_configuration?: boolean | AccountConfigurationArgs
    customers?: boolean | CustomerFindManyArgs
    _count?: boolean | AccountCountOutputTypeArgs
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account  & {
    [P in TrueKeys<S['include']>]:
        P extends 'campaign' ? Array < CampaignGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'plan' ? PlanGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'order' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_deliveries' ? Array < AccountDeliveryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_users' ? Array < AccountUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'invoices' ? Array < InvoiceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'stock_items' ? Array < StockItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'coupons' ? Array < CouponGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_configuration' ? AccountConfigurationGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'customers' ? Array < CustomerGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? AccountCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'campaign' ? Array < CampaignGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'plan' ? PlanGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'order' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_deliveries' ? Array < AccountDeliveryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_users' ? Array < AccountUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'invoices' ? Array < InvoiceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'stock_items' ? Array < StockItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'coupons' ? Array < CouponGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_configuration' ? AccountConfigurationGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'customers' ? Array < CustomerGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? AccountCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Account ? Account[P] : never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null, null>, Prisma__AccountClient<AccountGetPayload<T> | null, null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find one Account that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    campaign<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>| Null>, PrismaPromise<Array<CampaignGetPayload<T>>| Null>>;

    plan<T extends PlanArgs = {}>(args?: Subset<T, PlanArgs>): CheckSelect<T, Prisma__PlanClient<Plan | Null>, Prisma__PlanClient<PlanGetPayload<T> | Null>>;

    subscription<T extends SubscriptionFindManyArgs = {}>(args?: Subset<T, SubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscription>| Null>, PrismaPromise<Array<SubscriptionGetPayload<T>>| Null>>;

    order<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    account_activities<T extends AccountActivitiesFindManyArgs = {}>(args?: Subset<T, AccountActivitiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountActivities>| Null>, PrismaPromise<Array<AccountActivitiesGetPayload<T>>| Null>>;

    account_deliveries<T extends AccountDeliveryFindManyArgs = {}>(args?: Subset<T, AccountDeliveryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountDelivery>| Null>, PrismaPromise<Array<AccountDeliveryGetPayload<T>>| Null>>;

    account_users<T extends AccountUserFindManyArgs = {}>(args?: Subset<T, AccountUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountUser>| Null>, PrismaPromise<Array<AccountUserGetPayload<T>>| Null>>;

    invoices<T extends InvoiceFindManyArgs = {}>(args?: Subset<T, InvoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Invoice>| Null>, PrismaPromise<Array<InvoiceGetPayload<T>>| Null>>;

    stock_items<T extends StockItemFindManyArgs = {}>(args?: Subset<T, StockItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StockItem>| Null>, PrismaPromise<Array<StockItemGetPayload<T>>| Null>>;

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>| Null>, PrismaPromise<Array<ItemGetPayload<T>>| Null>>;

    coupons<T extends CouponFindManyArgs = {}>(args?: Subset<T, CouponFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Coupon>| Null>, PrismaPromise<Array<CouponGetPayload<T>>| Null>>;

    account_configuration<T extends AccountConfigurationArgs = {}>(args?: Subset<T, AccountConfigurationArgs>): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration | Null>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T> | Null>>;

    customers<T extends CustomerFindManyArgs = {}>(args?: Subset<T, CustomerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Customer>| Null>, PrismaPromise<Array<CustomerGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }

  /**
   * Account: findUnique
   */
  export interface AccountFindUniqueArgs extends AccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account: findFirst
   */
  export interface AccountFindFirstArgs extends AccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account: findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs = AccountFindUniqueArgsBase
      

  /**
   * Account: findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs = AccountFindFirstArgsBase
      

  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model AccountConfiguration
   */


  export type AggregateAccountConfiguration = {
    _count: AccountConfigurationCountAggregateOutputType | null
    _min: AccountConfigurationMinAggregateOutputType | null
    _max: AccountConfigurationMaxAggregateOutputType | null
  }

  export type AccountConfigurationMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    banner_market_url: string | null
    header_color: string | null
  }

  export type AccountConfigurationMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    banner_market_url: string | null
    header_color: string | null
  }

  export type AccountConfigurationCountAggregateOutputType = {
    id: number
    account_id: number
    banner_market_url: number
    header_color: number
    _all: number
  }


  export type AccountConfigurationMinAggregateInputType = {
    id?: true
    account_id?: true
    banner_market_url?: true
    header_color?: true
  }

  export type AccountConfigurationMaxAggregateInputType = {
    id?: true
    account_id?: true
    banner_market_url?: true
    header_color?: true
  }

  export type AccountConfigurationCountAggregateInputType = {
    id?: true
    account_id?: true
    banner_market_url?: true
    header_color?: true
    _all?: true
  }

  export type AccountConfigurationAggregateArgs = {
    /**
     * Filter which AccountConfiguration to aggregate.
     * 
    **/
    where?: AccountConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountConfigurations
    **/
    _count?: true | AccountConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountConfigurationMaxAggregateInputType
  }

  export type GetAccountConfigurationAggregateType<T extends AccountConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountConfiguration[P]>
      : GetScalarType<T[P], AggregateAccountConfiguration[P]>
  }




  export type AccountConfigurationGroupByArgs = {
    where?: AccountConfigurationWhereInput
    orderBy?: Enumerable<AccountConfigurationOrderByWithAggregationInput>
    by: Array<AccountConfigurationScalarFieldEnum>
    having?: AccountConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountConfigurationCountAggregateInputType | true
    _min?: AccountConfigurationMinAggregateInputType
    _max?: AccountConfigurationMaxAggregateInputType
  }


  export type AccountConfigurationGroupByOutputType = {
    id: string
    account_id: string
    banner_market_url: string | null
    header_color: string | null
    _count: AccountConfigurationCountAggregateOutputType | null
    _min: AccountConfigurationMinAggregateOutputType | null
    _max: AccountConfigurationMaxAggregateOutputType | null
  }

  type GetAccountConfigurationGroupByPayload<T extends AccountConfigurationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], AccountConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type AccountConfigurationSelect = {
    id?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    banner_market_url?: boolean
    header_color?: boolean
  }

  export type AccountConfigurationInclude = {
    account?: boolean | AccountArgs
  }

  export type AccountConfigurationGetPayload<
    S extends boolean | null | undefined | AccountConfigurationArgs,
    U = keyof S
      > = S extends true
        ? AccountConfiguration
    : S extends undefined
    ? never
    : S extends AccountConfigurationArgs | AccountConfigurationFindManyArgs
    ?'include' extends U
    ? AccountConfiguration  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AccountConfiguration ? AccountConfiguration[P] : never
  } 
    : AccountConfiguration
  : AccountConfiguration


  type AccountConfigurationCountArgs = Merge<
    Omit<AccountConfigurationFindManyArgs, 'select' | 'include'> & {
      select?: AccountConfigurationCountAggregateInputType | true
    }
  >

  export interface AccountConfigurationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AccountConfiguration that matches the filter.
     * @param {AccountConfigurationFindUniqueArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountConfigurationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountConfigurationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountConfiguration'> extends True ? CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration | null, null>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T> | null, null>>

    /**
     * Find the first AccountConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationFindFirstArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountConfigurationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountConfigurationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountConfiguration'> extends True ? CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration | null, null>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T> | null, null>>

    /**
     * Find zero or more AccountConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountConfigurations
     * const accountConfigurations = await prisma.accountConfiguration.findMany()
     * 
     * // Get first 10 AccountConfigurations
     * const accountConfigurations = await prisma.accountConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountConfigurationWithIdOnly = await prisma.accountConfiguration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountConfigurationFindManyArgs>(
      args?: SelectSubset<T, AccountConfigurationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountConfiguration>>, PrismaPromise<Array<AccountConfigurationGetPayload<T>>>>

    /**
     * Create a AccountConfiguration.
     * @param {AccountConfigurationCreateArgs} args - Arguments to create a AccountConfiguration.
     * @example
     * // Create one AccountConfiguration
     * const AccountConfiguration = await prisma.accountConfiguration.create({
     *   data: {
     *     // ... data to create a AccountConfiguration
     *   }
     * })
     * 
    **/
    create<T extends AccountConfigurationCreateArgs>(
      args: SelectSubset<T, AccountConfigurationCreateArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Create many AccountConfigurations.
     *     @param {AccountConfigurationCreateManyArgs} args - Arguments to create many AccountConfigurations.
     *     @example
     *     // Create many AccountConfigurations
     *     const accountConfiguration = await prisma.accountConfiguration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountConfigurationCreateManyArgs>(
      args?: SelectSubset<T, AccountConfigurationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccountConfiguration.
     * @param {AccountConfigurationDeleteArgs} args - Arguments to delete one AccountConfiguration.
     * @example
     * // Delete one AccountConfiguration
     * const AccountConfiguration = await prisma.accountConfiguration.delete({
     *   where: {
     *     // ... filter to delete one AccountConfiguration
     *   }
     * })
     * 
    **/
    delete<T extends AccountConfigurationDeleteArgs>(
      args: SelectSubset<T, AccountConfigurationDeleteArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Update one AccountConfiguration.
     * @param {AccountConfigurationUpdateArgs} args - Arguments to update one AccountConfiguration.
     * @example
     * // Update one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountConfigurationUpdateArgs>(
      args: SelectSubset<T, AccountConfigurationUpdateArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Delete zero or more AccountConfigurations.
     * @param {AccountConfigurationDeleteManyArgs} args - Arguments to filter AccountConfigurations to delete.
     * @example
     * // Delete a few AccountConfigurations
     * const { count } = await prisma.accountConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountConfigurationDeleteManyArgs>(
      args?: SelectSubset<T, AccountConfigurationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountConfigurations
     * const accountConfiguration = await prisma.accountConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountConfigurationUpdateManyArgs>(
      args: SelectSubset<T, AccountConfigurationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountConfiguration.
     * @param {AccountConfigurationUpsertArgs} args - Arguments to update or create a AccountConfiguration.
     * @example
     * // Update or create a AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.upsert({
     *   create: {
     *     // ... data to create a AccountConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountConfiguration we want to update
     *   }
     * })
    **/
    upsert<T extends AccountConfigurationUpsertArgs>(
      args: SelectSubset<T, AccountConfigurationUpsertArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Find one AccountConfiguration that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountConfigurationFindUniqueOrThrowArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountConfigurationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountConfigurationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Find the first AccountConfiguration that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationFindFirstOrThrowArgs} args - Arguments to find a AccountConfiguration
     * @example
     * // Get one AccountConfiguration
     * const accountConfiguration = await prisma.accountConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountConfigurationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountConfigurationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountConfigurationClient<AccountConfiguration>, Prisma__AccountConfigurationClient<AccountConfigurationGetPayload<T>>>

    /**
     * Count the number of AccountConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationCountArgs} args - Arguments to filter AccountConfigurations to count.
     * @example
     * // Count the number of AccountConfigurations
     * const count = await prisma.accountConfiguration.count({
     *   where: {
     *     // ... the filter for the AccountConfigurations we want to count
     *   }
     * })
    **/
    count<T extends AccountConfigurationCountArgs>(
      args?: Subset<T, AccountConfigurationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountConfigurationAggregateArgs>(args: Subset<T, AccountConfigurationAggregateArgs>): PrismaPromise<GetAccountConfigurationAggregateType<T>>

    /**
     * Group by AccountConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: AccountConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountConfigurationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountConfigurationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AccountConfiguration base type for findUnique actions
   */
  export type AccountConfigurationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter, which AccountConfiguration to fetch.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
  }

  /**
   * AccountConfiguration: findUnique
   */
  export interface AccountConfigurationFindUniqueArgs extends AccountConfigurationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountConfiguration base type for findFirst actions
   */
  export type AccountConfigurationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter, which AccountConfiguration to fetch.
     * 
    **/
    where?: AccountConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountConfigurations.
     * 
    **/
    cursor?: AccountConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountConfigurations.
     * 
    **/
    distinct?: Enumerable<AccountConfigurationScalarFieldEnum>
  }

  /**
   * AccountConfiguration: findFirst
   */
  export interface AccountConfigurationFindFirstArgs extends AccountConfigurationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountConfiguration findMany
   */
  export type AccountConfigurationFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter, which AccountConfigurations to fetch.
     * 
    **/
    where?: AccountConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountConfigurations.
     * 
    **/
    cursor?: AccountConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountConfigurations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountConfigurationScalarFieldEnum>
  }


  /**
   * AccountConfiguration create
   */
  export type AccountConfigurationCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * The data needed to create a AccountConfiguration.
     * 
    **/
    data: XOR<AccountConfigurationCreateInput, AccountConfigurationUncheckedCreateInput>
  }


  /**
   * AccountConfiguration createMany
   */
  export type AccountConfigurationCreateManyArgs = {
    /**
     * The data used to create many AccountConfigurations.
     * 
    **/
    data: Enumerable<AccountConfigurationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AccountConfiguration update
   */
  export type AccountConfigurationUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * The data needed to update a AccountConfiguration.
     * 
    **/
    data: XOR<AccountConfigurationUpdateInput, AccountConfigurationUncheckedUpdateInput>
    /**
     * Choose, which AccountConfiguration to update.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
  }


  /**
   * AccountConfiguration updateMany
   */
  export type AccountConfigurationUpdateManyArgs = {
    /**
     * The data used to update AccountConfigurations.
     * 
    **/
    data: XOR<AccountConfigurationUpdateManyMutationInput, AccountConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which AccountConfigurations to update
     * 
    **/
    where?: AccountConfigurationWhereInput
  }


  /**
   * AccountConfiguration upsert
   */
  export type AccountConfigurationUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * The filter to search for the AccountConfiguration to update in case it exists.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
    /**
     * In case the AccountConfiguration found by the `where` argument doesn't exist, create a new AccountConfiguration with this data.
     * 
    **/
    create: XOR<AccountConfigurationCreateInput, AccountConfigurationUncheckedCreateInput>
    /**
     * In case the AccountConfiguration was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountConfigurationUpdateInput, AccountConfigurationUncheckedUpdateInput>
  }


  /**
   * AccountConfiguration delete
   */
  export type AccountConfigurationDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
    /**
     * Filter which AccountConfiguration to delete.
     * 
    **/
    where: AccountConfigurationWhereUniqueInput
  }


  /**
   * AccountConfiguration deleteMany
   */
  export type AccountConfigurationDeleteManyArgs = {
    /**
     * Filter which AccountConfigurations to delete
     * 
    **/
    where?: AccountConfigurationWhereInput
  }


  /**
   * AccountConfiguration: findUniqueOrThrow
   */
  export type AccountConfigurationFindUniqueOrThrowArgs = AccountConfigurationFindUniqueArgsBase
      

  /**
   * AccountConfiguration: findFirstOrThrow
   */
  export type AccountConfigurationFindFirstOrThrowArgs = AccountConfigurationFindFirstArgsBase
      

  /**
   * AccountConfiguration without action
   */
  export type AccountConfigurationArgs = {
    /**
     * Select specific fields to fetch from the AccountConfiguration
     * 
    **/
    select?: AccountConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountConfigurationInclude | null
  }



  /**
   * Model AccountActivities
   */


  export type AggregateAccountActivities = {
    _count: AccountActivitiesCountAggregateOutputType | null
    _min: AccountActivitiesMinAggregateOutputType | null
    _max: AccountActivitiesMaxAggregateOutputType | null
  }

  export type AccountActivitiesMinAggregateOutputType = {
    account_id: string | null
    activities_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountActivitiesMaxAggregateOutputType = {
    account_id: string | null
    activities_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountActivitiesCountAggregateOutputType = {
    account_id: number
    activities_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AccountActivitiesMinAggregateInputType = {
    account_id?: true
    activities_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountActivitiesMaxAggregateInputType = {
    account_id?: true
    activities_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountActivitiesCountAggregateInputType = {
    account_id?: true
    activities_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AccountActivitiesAggregateArgs = {
    /**
     * Filter which AccountActivities to aggregate.
     * 
    **/
    where?: AccountActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountActivities
    **/
    _count?: true | AccountActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountActivitiesMaxAggregateInputType
  }

  export type GetAccountActivitiesAggregateType<T extends AccountActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountActivities[P]>
      : GetScalarType<T[P], AggregateAccountActivities[P]>
  }




  export type AccountActivitiesGroupByArgs = {
    where?: AccountActivitiesWhereInput
    orderBy?: Enumerable<AccountActivitiesOrderByWithAggregationInput>
    by: Array<AccountActivitiesScalarFieldEnum>
    having?: AccountActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountActivitiesCountAggregateInputType | true
    _min?: AccountActivitiesMinAggregateInputType
    _max?: AccountActivitiesMaxAggregateInputType
  }


  export type AccountActivitiesGroupByOutputType = {
    account_id: string
    activities_id: string
    created_at: Date
    updated_at: Date
    _count: AccountActivitiesCountAggregateOutputType | null
    _min: AccountActivitiesMinAggregateOutputType | null
    _max: AccountActivitiesMaxAggregateOutputType | null
  }

  type GetAccountActivitiesGroupByPayload<T extends AccountActivitiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AccountActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type AccountActivitiesSelect = {
    account_id?: boolean
    account?: boolean | AccountArgs
    activities_id?: boolean
    activities?: boolean | ActivitiesArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type AccountActivitiesInclude = {
    account?: boolean | AccountArgs
    activities?: boolean | ActivitiesArgs
  }

  export type AccountActivitiesGetPayload<
    S extends boolean | null | undefined | AccountActivitiesArgs,
    U = keyof S
      > = S extends true
        ? AccountActivities
    : S extends undefined
    ? never
    : S extends AccountActivitiesArgs | AccountActivitiesFindManyArgs
    ?'include' extends U
    ? AccountActivities  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'activities' ? ActivitiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'activities' ? ActivitiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AccountActivities ? AccountActivities[P] : never
  } 
    : AccountActivities
  : AccountActivities


  type AccountActivitiesCountArgs = Merge<
    Omit<AccountActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: AccountActivitiesCountAggregateInputType | true
    }
  >

  export interface AccountActivitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AccountActivities that matches the filter.
     * @param {AccountActivitiesFindUniqueArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountActivitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountActivitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountActivities'> extends True ? CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities | null, null>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T> | null, null>>

    /**
     * Find the first AccountActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesFindFirstArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountActivitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountActivitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountActivities'> extends True ? CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities | null, null>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T> | null, null>>

    /**
     * Find zero or more AccountActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountActivities
     * const accountActivities = await prisma.accountActivities.findMany()
     * 
     * // Get first 10 AccountActivities
     * const accountActivities = await prisma.accountActivities.findMany({ take: 10 })
     * 
     * // Only select the `account_id`
     * const accountActivitiesWithAccount_idOnly = await prisma.accountActivities.findMany({ select: { account_id: true } })
     * 
    **/
    findMany<T extends AccountActivitiesFindManyArgs>(
      args?: SelectSubset<T, AccountActivitiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountActivities>>, PrismaPromise<Array<AccountActivitiesGetPayload<T>>>>

    /**
     * Create a AccountActivities.
     * @param {AccountActivitiesCreateArgs} args - Arguments to create a AccountActivities.
     * @example
     * // Create one AccountActivities
     * const AccountActivities = await prisma.accountActivities.create({
     *   data: {
     *     // ... data to create a AccountActivities
     *   }
     * })
     * 
    **/
    create<T extends AccountActivitiesCreateArgs>(
      args: SelectSubset<T, AccountActivitiesCreateArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Create many AccountActivities.
     *     @param {AccountActivitiesCreateManyArgs} args - Arguments to create many AccountActivities.
     *     @example
     *     // Create many AccountActivities
     *     const accountActivities = await prisma.accountActivities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountActivitiesCreateManyArgs>(
      args?: SelectSubset<T, AccountActivitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccountActivities.
     * @param {AccountActivitiesDeleteArgs} args - Arguments to delete one AccountActivities.
     * @example
     * // Delete one AccountActivities
     * const AccountActivities = await prisma.accountActivities.delete({
     *   where: {
     *     // ... filter to delete one AccountActivities
     *   }
     * })
     * 
    **/
    delete<T extends AccountActivitiesDeleteArgs>(
      args: SelectSubset<T, AccountActivitiesDeleteArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Update one AccountActivities.
     * @param {AccountActivitiesUpdateArgs} args - Arguments to update one AccountActivities.
     * @example
     * // Update one AccountActivities
     * const accountActivities = await prisma.accountActivities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountActivitiesUpdateArgs>(
      args: SelectSubset<T, AccountActivitiesUpdateArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Delete zero or more AccountActivities.
     * @param {AccountActivitiesDeleteManyArgs} args - Arguments to filter AccountActivities to delete.
     * @example
     * // Delete a few AccountActivities
     * const { count } = await prisma.accountActivities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountActivitiesDeleteManyArgs>(
      args?: SelectSubset<T, AccountActivitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountActivities
     * const accountActivities = await prisma.accountActivities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountActivitiesUpdateManyArgs>(
      args: SelectSubset<T, AccountActivitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountActivities.
     * @param {AccountActivitiesUpsertArgs} args - Arguments to update or create a AccountActivities.
     * @example
     * // Update or create a AccountActivities
     * const accountActivities = await prisma.accountActivities.upsert({
     *   create: {
     *     // ... data to create a AccountActivities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountActivities we want to update
     *   }
     * })
    **/
    upsert<T extends AccountActivitiesUpsertArgs>(
      args: SelectSubset<T, AccountActivitiesUpsertArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Find one AccountActivities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountActivitiesFindUniqueOrThrowArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountActivitiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountActivitiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Find the first AccountActivities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesFindFirstOrThrowArgs} args - Arguments to find a AccountActivities
     * @example
     * // Get one AccountActivities
     * const accountActivities = await prisma.accountActivities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountActivitiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountActivitiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountActivitiesClient<AccountActivities>, Prisma__AccountActivitiesClient<AccountActivitiesGetPayload<T>>>

    /**
     * Count the number of AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesCountArgs} args - Arguments to filter AccountActivities to count.
     * @example
     * // Count the number of AccountActivities
     * const count = await prisma.accountActivities.count({
     *   where: {
     *     // ... the filter for the AccountActivities we want to count
     *   }
     * })
    **/
    count<T extends AccountActivitiesCountArgs>(
      args?: Subset<T, AccountActivitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountActivitiesAggregateArgs>(args: Subset<T, AccountActivitiesAggregateArgs>): PrismaPromise<GetAccountActivitiesAggregateType<T>>

    /**
     * Group by AccountActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: AccountActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountActivitiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountActivities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountActivitiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    activities<T extends ActivitiesArgs = {}>(args?: Subset<T, ActivitiesArgs>): CheckSelect<T, Prisma__ActivitiesClient<Activities | Null>, Prisma__ActivitiesClient<ActivitiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AccountActivities base type for findUnique actions
   */
  export type AccountActivitiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter, which AccountActivities to fetch.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
  }

  /**
   * AccountActivities: findUnique
   */
  export interface AccountActivitiesFindUniqueArgs extends AccountActivitiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountActivities base type for findFirst actions
   */
  export type AccountActivitiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter, which AccountActivities to fetch.
     * 
    **/
    where?: AccountActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountActivities.
     * 
    **/
    cursor?: AccountActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountActivities.
     * 
    **/
    distinct?: Enumerable<AccountActivitiesScalarFieldEnum>
  }

  /**
   * AccountActivities: findFirst
   */
  export interface AccountActivitiesFindFirstArgs extends AccountActivitiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountActivities findMany
   */
  export type AccountActivitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter, which AccountActivities to fetch.
     * 
    **/
    where?: AccountActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountActivities to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountActivities.
     * 
    **/
    cursor?: AccountActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountActivities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountActivities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountActivitiesScalarFieldEnum>
  }


  /**
   * AccountActivities create
   */
  export type AccountActivitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * The data needed to create a AccountActivities.
     * 
    **/
    data: XOR<AccountActivitiesCreateInput, AccountActivitiesUncheckedCreateInput>
  }


  /**
   * AccountActivities createMany
   */
  export type AccountActivitiesCreateManyArgs = {
    /**
     * The data used to create many AccountActivities.
     * 
    **/
    data: Enumerable<AccountActivitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AccountActivities update
   */
  export type AccountActivitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * The data needed to update a AccountActivities.
     * 
    **/
    data: XOR<AccountActivitiesUpdateInput, AccountActivitiesUncheckedUpdateInput>
    /**
     * Choose, which AccountActivities to update.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
  }


  /**
   * AccountActivities updateMany
   */
  export type AccountActivitiesUpdateManyArgs = {
    /**
     * The data used to update AccountActivities.
     * 
    **/
    data: XOR<AccountActivitiesUpdateManyMutationInput, AccountActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which AccountActivities to update
     * 
    **/
    where?: AccountActivitiesWhereInput
  }


  /**
   * AccountActivities upsert
   */
  export type AccountActivitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * The filter to search for the AccountActivities to update in case it exists.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
    /**
     * In case the AccountActivities found by the `where` argument doesn't exist, create a new AccountActivities with this data.
     * 
    **/
    create: XOR<AccountActivitiesCreateInput, AccountActivitiesUncheckedCreateInput>
    /**
     * In case the AccountActivities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountActivitiesUpdateInput, AccountActivitiesUncheckedUpdateInput>
  }


  /**
   * AccountActivities delete
   */
  export type AccountActivitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
    /**
     * Filter which AccountActivities to delete.
     * 
    **/
    where: AccountActivitiesWhereUniqueInput
  }


  /**
   * AccountActivities deleteMany
   */
  export type AccountActivitiesDeleteManyArgs = {
    /**
     * Filter which AccountActivities to delete
     * 
    **/
    where?: AccountActivitiesWhereInput
  }


  /**
   * AccountActivities: findUniqueOrThrow
   */
  export type AccountActivitiesFindUniqueOrThrowArgs = AccountActivitiesFindUniqueArgsBase
      

  /**
   * AccountActivities: findFirstOrThrow
   */
  export type AccountActivitiesFindFirstOrThrowArgs = AccountActivitiesFindFirstArgsBase
      

  /**
   * AccountActivities without action
   */
  export type AccountActivitiesArgs = {
    /**
     * Select specific fields to fetch from the AccountActivities
     * 
    **/
    select?: AccountActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountActivitiesInclude | null
  }



  /**
   * Model Activities
   */


  export type AggregateActivities = {
    _count: ActivitiesCountAggregateOutputType | null
    _avg: ActivitiesAvgAggregateOutputType | null
    _sum: ActivitiesSumAggregateOutputType | null
    _min: ActivitiesMinAggregateOutputType | null
    _max: ActivitiesMaxAggregateOutputType | null
  }

  export type ActivitiesAvgAggregateOutputType = {
    external_id: number | null
  }

  export type ActivitiesSumAggregateOutputType = {
    external_id: number | null
  }

  export type ActivitiesMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivitiesMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivitiesCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivitiesAvgAggregateInputType = {
    external_id?: true
  }

  export type ActivitiesSumAggregateInputType = {
    external_id?: true
  }

  export type ActivitiesMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivitiesMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivitiesCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivitiesAggregateArgs = {
    /**
     * Filter which Activities to aggregate.
     * 
    **/
    where?: ActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivitiesMaxAggregateInputType
  }

  export type GetActivitiesAggregateType<T extends ActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivities[P]>
      : GetScalarType<T[P], AggregateActivities[P]>
  }




  export type ActivitiesGroupByArgs = {
    where?: ActivitiesWhereInput
    orderBy?: Enumerable<ActivitiesOrderByWithAggregationInput>
    by: Array<ActivitiesScalarFieldEnum>
    having?: ActivitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivitiesCountAggregateInputType | true
    _avg?: ActivitiesAvgAggregateInputType
    _sum?: ActivitiesSumAggregateInputType
    _min?: ActivitiesMinAggregateInputType
    _max?: ActivitiesMaxAggregateInputType
  }


  export type ActivitiesGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: ActivitiesCountAggregateOutputType | null
    _avg: ActivitiesAvgAggregateOutputType | null
    _sum: ActivitiesSumAggregateOutputType | null
    _min: ActivitiesMinAggregateOutputType | null
    _max: ActivitiesMaxAggregateOutputType | null
  }

  type GetActivitiesGroupByPayload<T extends ActivitiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], ActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type ActivitiesSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_activities?: boolean | AccountActivitiesFindManyArgs
    _count?: boolean | ActivitiesCountOutputTypeArgs
  }

  export type ActivitiesInclude = {
    account_activities?: boolean | AccountActivitiesFindManyArgs
    _count?: boolean | ActivitiesCountOutputTypeArgs
  }

  export type ActivitiesGetPayload<
    S extends boolean | null | undefined | ActivitiesArgs,
    U = keyof S
      > = S extends true
        ? Activities
    : S extends undefined
    ? never
    : S extends ActivitiesArgs | ActivitiesFindManyArgs
    ?'include' extends U
    ? Activities  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ActivitiesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account_activities' ? Array < AccountActivitiesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ActivitiesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Activities ? Activities[P] : never
  } 
    : Activities
  : Activities


  type ActivitiesCountArgs = Merge<
    Omit<ActivitiesFindManyArgs, 'select' | 'include'> & {
      select?: ActivitiesCountAggregateInputType | true
    }
  >

  export interface ActivitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Activities that matches the filter.
     * @param {ActivitiesFindUniqueArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Activities'> extends True ? CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__ActivitiesClient<Activities | null, null>, Prisma__ActivitiesClient<ActivitiesGetPayload<T> | null, null>>

    /**
     * Find the first Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesFindFirstArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Activities'> extends True ? CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>> : CheckSelect<T, Prisma__ActivitiesClient<Activities | null, null>, Prisma__ActivitiesClient<ActivitiesGetPayload<T> | null, null>>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activities.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activitiesWithIdOnly = await prisma.activities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivitiesFindManyArgs>(
      args?: SelectSubset<T, ActivitiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Activities>>, PrismaPromise<Array<ActivitiesGetPayload<T>>>>

    /**
     * Create a Activities.
     * @param {ActivitiesCreateArgs} args - Arguments to create a Activities.
     * @example
     * // Create one Activities
     * const Activities = await prisma.activities.create({
     *   data: {
     *     // ... data to create a Activities
     *   }
     * })
     * 
    **/
    create<T extends ActivitiesCreateArgs>(
      args: SelectSubset<T, ActivitiesCreateArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Create many Activities.
     *     @param {ActivitiesCreateManyArgs} args - Arguments to create many Activities.
     *     @example
     *     // Create many Activities
     *     const activities = await prisma.activities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivitiesCreateManyArgs>(
      args?: SelectSubset<T, ActivitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Activities.
     * @param {ActivitiesDeleteArgs} args - Arguments to delete one Activities.
     * @example
     * // Delete one Activities
     * const Activities = await prisma.activities.delete({
     *   where: {
     *     // ... filter to delete one Activities
     *   }
     * })
     * 
    **/
    delete<T extends ActivitiesDeleteArgs>(
      args: SelectSubset<T, ActivitiesDeleteArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Update one Activities.
     * @param {ActivitiesUpdateArgs} args - Arguments to update one Activities.
     * @example
     * // Update one Activities
     * const activities = await prisma.activities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivitiesUpdateArgs>(
      args: SelectSubset<T, ActivitiesUpdateArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Delete zero or more Activities.
     * @param {ActivitiesDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivitiesDeleteManyArgs>(
      args?: SelectSubset<T, ActivitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activities = await prisma.activities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivitiesUpdateManyArgs>(
      args: SelectSubset<T, ActivitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Activities.
     * @param {ActivitiesUpsertArgs} args - Arguments to update or create a Activities.
     * @example
     * // Update or create a Activities
     * const activities = await prisma.activities.upsert({
     *   create: {
     *     // ... data to create a Activities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activities we want to update
     *   }
     * })
    **/
    upsert<T extends ActivitiesUpsertArgs>(
      args: SelectSubset<T, ActivitiesUpsertArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Find one Activities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ActivitiesFindUniqueOrThrowArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivitiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ActivitiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Find the first Activities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesFindFirstOrThrowArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivitiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActivitiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ActivitiesClient<Activities>, Prisma__ActivitiesClient<ActivitiesGetPayload<T>>>

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activities.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivitiesCountArgs>(
      args?: Subset<T, ActivitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivitiesAggregateArgs>(args: Subset<T, ActivitiesAggregateArgs>): PrismaPromise<GetActivitiesAggregateType<T>>

    /**
     * Group by Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivitiesGroupByArgs['orderBy'] }
        : { orderBy?: ActivitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivitiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Activities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivitiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account_activities<T extends AccountActivitiesFindManyArgs = {}>(args?: Subset<T, AccountActivitiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountActivities>| Null>, PrismaPromise<Array<AccountActivitiesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Activities base type for findUnique actions
   */
  export type ActivitiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where: ActivitiesWhereUniqueInput
  }

  /**
   * Activities: findUnique
   */
  export interface ActivitiesFindUniqueArgs extends ActivitiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activities base type for findFirst actions
   */
  export type ActivitiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where?: ActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     * 
    **/
    cursor?: ActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     * 
    **/
    distinct?: Enumerable<ActivitiesScalarFieldEnum>
  }

  /**
   * Activities: findFirst
   */
  export interface ActivitiesFindFirstArgs extends ActivitiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activities findMany
   */
  export type ActivitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where?: ActivitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     * 
    **/
    cursor?: ActivitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActivitiesScalarFieldEnum>
  }


  /**
   * Activities create
   */
  export type ActivitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * The data needed to create a Activities.
     * 
    **/
    data: XOR<ActivitiesCreateInput, ActivitiesUncheckedCreateInput>
  }


  /**
   * Activities createMany
   */
  export type ActivitiesCreateManyArgs = {
    /**
     * The data used to create many Activities.
     * 
    **/
    data: Enumerable<ActivitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Activities update
   */
  export type ActivitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * The data needed to update a Activities.
     * 
    **/
    data: XOR<ActivitiesUpdateInput, ActivitiesUncheckedUpdateInput>
    /**
     * Choose, which Activities to update.
     * 
    **/
    where: ActivitiesWhereUniqueInput
  }


  /**
   * Activities updateMany
   */
  export type ActivitiesUpdateManyArgs = {
    /**
     * The data used to update Activities.
     * 
    **/
    data: XOR<ActivitiesUpdateManyMutationInput, ActivitiesUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     * 
    **/
    where?: ActivitiesWhereInput
  }


  /**
   * Activities upsert
   */
  export type ActivitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * The filter to search for the Activities to update in case it exists.
     * 
    **/
    where: ActivitiesWhereUniqueInput
    /**
     * In case the Activities found by the `where` argument doesn't exist, create a new Activities with this data.
     * 
    **/
    create: XOR<ActivitiesCreateInput, ActivitiesUncheckedCreateInput>
    /**
     * In case the Activities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActivitiesUpdateInput, ActivitiesUncheckedUpdateInput>
  }


  /**
   * Activities delete
   */
  export type ActivitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
    /**
     * Filter which Activities to delete.
     * 
    **/
    where: ActivitiesWhereUniqueInput
  }


  /**
   * Activities deleteMany
   */
  export type ActivitiesDeleteManyArgs = {
    /**
     * Filter which Activities to delete
     * 
    **/
    where?: ActivitiesWhereInput
  }


  /**
   * Activities: findUniqueOrThrow
   */
  export type ActivitiesFindUniqueOrThrowArgs = ActivitiesFindUniqueArgsBase
      

  /**
   * Activities: findFirstOrThrow
   */
  export type ActivitiesFindFirstOrThrowArgs = ActivitiesFindFirstArgsBase
      

  /**
   * Activities without action
   */
  export type ActivitiesArgs = {
    /**
     * Select specific fields to fetch from the Activities
     * 
    **/
    select?: ActivitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivitiesInclude | null
  }



  /**
   * Model Delivery
   */


  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryAvgAggregateOutputType = {
    external_id: number | null
  }

  export type DeliverySumAggregateOutputType = {
    external_id: number | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeliveryAvgAggregateInputType = {
    external_id?: true
  }

  export type DeliverySumAggregateInputType = {
    external_id?: true
  }

  export type DeliveryMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeliveryAggregateArgs = {
    /**
     * Filter which Delivery to aggregate.
     * 
    **/
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs = {
    where?: DeliveryWhereInput
    orderBy?: Enumerable<DeliveryOrderByWithAggregationInput>
    by: Array<DeliveryScalarFieldEnum>
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _avg?: DeliveryAvgAggregateInputType
    _sum?: DeliverySumAggregateInputType
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }


  export type DeliveryGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_deliveries?: boolean | AccountDeliveryFindManyArgs
    _count?: boolean | DeliveryCountOutputTypeArgs
  }

  export type DeliveryInclude = {
    account_deliveries?: boolean | AccountDeliveryFindManyArgs
    _count?: boolean | DeliveryCountOutputTypeArgs
  }

  export type DeliveryGetPayload<
    S extends boolean | null | undefined | DeliveryArgs,
    U = keyof S
      > = S extends true
        ? Delivery
    : S extends undefined
    ? never
    : S extends DeliveryArgs | DeliveryFindManyArgs
    ?'include' extends U
    ? Delivery  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account_deliveries' ? Array < AccountDeliveryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? DeliveryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account_deliveries' ? Array < AccountDeliveryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? DeliveryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Delivery ? Delivery[P] : never
  } 
    : Delivery
  : Delivery


  type DeliveryCountArgs = Merge<
    Omit<DeliveryFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryCountAggregateInputType | true
    }
  >

  export interface DeliveryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeliveryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Delivery'> extends True ? CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>> : CheckSelect<T, Prisma__DeliveryClient<Delivery | null, null>, Prisma__DeliveryClient<DeliveryGetPayload<T> | null, null>>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeliveryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Delivery'> extends True ? CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>> : CheckSelect<T, Prisma__DeliveryClient<Delivery | null, null>, Prisma__DeliveryClient<DeliveryGetPayload<T> | null, null>>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeliveryFindManyArgs>(
      args?: SelectSubset<T, DeliveryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Delivery>>, PrismaPromise<Array<DeliveryGetPayload<T>>>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
    **/
    create<T extends DeliveryCreateArgs>(
      args: SelectSubset<T, DeliveryCreateArgs>
    ): CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>>

    /**
     * Create many Deliveries.
     *     @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     *     @example
     *     // Create many Deliveries
     *     const delivery = await prisma.delivery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryCreateManyArgs>(
      args?: SelectSubset<T, DeliveryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryDeleteArgs>(
      args: SelectSubset<T, DeliveryDeleteArgs>
    ): CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryUpdateArgs>(
      args: SelectSubset<T, DeliveryUpdateArgs>
    ): CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryDeleteManyArgs>(
      args?: SelectSubset<T, DeliveryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryUpdateManyArgs>(
      args: SelectSubset<T, DeliveryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryUpsertArgs>(
      args: SelectSubset<T, DeliveryUpsertArgs>
    ): CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>>

    /**
     * Find one Delivery that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeliveryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>>

    /**
     * Find the first Delivery that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeliveryClient<Delivery>, Prisma__DeliveryClient<DeliveryGetPayload<T>>>

    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeliveryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account_deliveries<T extends AccountDeliveryFindManyArgs = {}>(args?: Subset<T, AccountDeliveryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountDelivery>| Null>, PrismaPromise<Array<AccountDeliveryGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Delivery base type for findUnique actions
   */
  export type DeliveryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     * 
    **/
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery: findUnique
   */
  export interface DeliveryFindUniqueArgs extends DeliveryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Delivery base type for findFirst actions
   */
  export type DeliveryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     * 
    **/
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     * 
    **/
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     * 
    **/
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }

  /**
   * Delivery: findFirst
   */
  export interface DeliveryFindFirstArgs extends DeliveryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter, which Deliveries to fetch.
     * 
    **/
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     * 
    **/
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }


  /**
   * Delivery create
   */
  export type DeliveryCreateArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * The data needed to create a Delivery.
     * 
    **/
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }


  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs = {
    /**
     * The data used to create many Deliveries.
     * 
    **/
    data: Enumerable<DeliveryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * The data needed to update a Delivery.
     * 
    **/
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     * 
    **/
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs = {
    /**
     * The data used to update Deliveries.
     * 
    **/
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     * 
    **/
    where?: DeliveryWhereInput
  }


  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     * 
    **/
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     * 
    **/
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }


  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
    /**
     * Filter which Delivery to delete.
     * 
    **/
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs = {
    /**
     * Filter which Deliveries to delete
     * 
    **/
    where?: DeliveryWhereInput
  }


  /**
   * Delivery: findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs = DeliveryFindUniqueArgsBase
      

  /**
   * Delivery: findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs = DeliveryFindFirstArgsBase
      

  /**
   * Delivery without action
   */
  export type DeliveryArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     * 
    **/
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeliveryInclude | null
  }



  /**
   * Model AccountDelivery
   */


  export type AggregateAccountDelivery = {
    _count: AccountDeliveryCountAggregateOutputType | null
    _min: AccountDeliveryMinAggregateOutputType | null
    _max: AccountDeliveryMaxAggregateOutputType | null
  }

  export type AccountDeliveryMinAggregateOutputType = {
    account_id: string | null
    delivery_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountDeliveryMaxAggregateOutputType = {
    account_id: string | null
    delivery_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AccountDeliveryCountAggregateOutputType = {
    account_id: number
    delivery_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AccountDeliveryMinAggregateInputType = {
    account_id?: true
    delivery_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountDeliveryMaxAggregateInputType = {
    account_id?: true
    delivery_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AccountDeliveryCountAggregateInputType = {
    account_id?: true
    delivery_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AccountDeliveryAggregateArgs = {
    /**
     * Filter which AccountDelivery to aggregate.
     * 
    **/
    where?: AccountDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountDeliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountDeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountDeliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountDeliveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountDeliveries
    **/
    _count?: true | AccountDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountDeliveryMaxAggregateInputType
  }

  export type GetAccountDeliveryAggregateType<T extends AccountDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountDelivery[P]>
      : GetScalarType<T[P], AggregateAccountDelivery[P]>
  }




  export type AccountDeliveryGroupByArgs = {
    where?: AccountDeliveryWhereInput
    orderBy?: Enumerable<AccountDeliveryOrderByWithAggregationInput>
    by: Array<AccountDeliveryScalarFieldEnum>
    having?: AccountDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountDeliveryCountAggregateInputType | true
    _min?: AccountDeliveryMinAggregateInputType
    _max?: AccountDeliveryMaxAggregateInputType
  }


  export type AccountDeliveryGroupByOutputType = {
    account_id: string
    delivery_id: string
    created_at: Date
    updated_at: Date
    _count: AccountDeliveryCountAggregateOutputType | null
    _min: AccountDeliveryMinAggregateOutputType | null
    _max: AccountDeliveryMaxAggregateOutputType | null
  }

  type GetAccountDeliveryGroupByPayload<T extends AccountDeliveryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], AccountDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type AccountDeliverySelect = {
    account_id?: boolean
    account?: boolean | AccountArgs
    delivery_id?: boolean
    delivery?: boolean | DeliveryArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type AccountDeliveryInclude = {
    account?: boolean | AccountArgs
    delivery?: boolean | DeliveryArgs
  }

  export type AccountDeliveryGetPayload<
    S extends boolean | null | undefined | AccountDeliveryArgs,
    U = keyof S
      > = S extends true
        ? AccountDelivery
    : S extends undefined
    ? never
    : S extends AccountDeliveryArgs | AccountDeliveryFindManyArgs
    ?'include' extends U
    ? AccountDelivery  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'delivery' ? DeliveryGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'delivery' ? DeliveryGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AccountDelivery ? AccountDelivery[P] : never
  } 
    : AccountDelivery
  : AccountDelivery


  type AccountDeliveryCountArgs = Merge<
    Omit<AccountDeliveryFindManyArgs, 'select' | 'include'> & {
      select?: AccountDeliveryCountAggregateInputType | true
    }
  >

  export interface AccountDeliveryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AccountDelivery that matches the filter.
     * @param {AccountDeliveryFindUniqueArgs} args - Arguments to find a AccountDelivery
     * @example
     * // Get one AccountDelivery
     * const accountDelivery = await prisma.accountDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountDeliveryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountDeliveryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountDelivery'> extends True ? CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>> : CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery | null, null>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T> | null, null>>

    /**
     * Find the first AccountDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeliveryFindFirstArgs} args - Arguments to find a AccountDelivery
     * @example
     * // Get one AccountDelivery
     * const accountDelivery = await prisma.accountDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountDeliveryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountDeliveryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountDelivery'> extends True ? CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>> : CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery | null, null>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T> | null, null>>

    /**
     * Find zero or more AccountDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeliveryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountDeliveries
     * const accountDeliveries = await prisma.accountDelivery.findMany()
     * 
     * // Get first 10 AccountDeliveries
     * const accountDeliveries = await prisma.accountDelivery.findMany({ take: 10 })
     * 
     * // Only select the `account_id`
     * const accountDeliveryWithAccount_idOnly = await prisma.accountDelivery.findMany({ select: { account_id: true } })
     * 
    **/
    findMany<T extends AccountDeliveryFindManyArgs>(
      args?: SelectSubset<T, AccountDeliveryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountDelivery>>, PrismaPromise<Array<AccountDeliveryGetPayload<T>>>>

    /**
     * Create a AccountDelivery.
     * @param {AccountDeliveryCreateArgs} args - Arguments to create a AccountDelivery.
     * @example
     * // Create one AccountDelivery
     * const AccountDelivery = await prisma.accountDelivery.create({
     *   data: {
     *     // ... data to create a AccountDelivery
     *   }
     * })
     * 
    **/
    create<T extends AccountDeliveryCreateArgs>(
      args: SelectSubset<T, AccountDeliveryCreateArgs>
    ): CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>>

    /**
     * Create many AccountDeliveries.
     *     @param {AccountDeliveryCreateManyArgs} args - Arguments to create many AccountDeliveries.
     *     @example
     *     // Create many AccountDeliveries
     *     const accountDelivery = await prisma.accountDelivery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountDeliveryCreateManyArgs>(
      args?: SelectSubset<T, AccountDeliveryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccountDelivery.
     * @param {AccountDeliveryDeleteArgs} args - Arguments to delete one AccountDelivery.
     * @example
     * // Delete one AccountDelivery
     * const AccountDelivery = await prisma.accountDelivery.delete({
     *   where: {
     *     // ... filter to delete one AccountDelivery
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeliveryDeleteArgs>(
      args: SelectSubset<T, AccountDeliveryDeleteArgs>
    ): CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>>

    /**
     * Update one AccountDelivery.
     * @param {AccountDeliveryUpdateArgs} args - Arguments to update one AccountDelivery.
     * @example
     * // Update one AccountDelivery
     * const accountDelivery = await prisma.accountDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountDeliveryUpdateArgs>(
      args: SelectSubset<T, AccountDeliveryUpdateArgs>
    ): CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>>

    /**
     * Delete zero or more AccountDeliveries.
     * @param {AccountDeliveryDeleteManyArgs} args - Arguments to filter AccountDeliveries to delete.
     * @example
     * // Delete a few AccountDeliveries
     * const { count } = await prisma.accountDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeliveryDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeliveryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountDeliveries
     * const accountDelivery = await prisma.accountDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountDeliveryUpdateManyArgs>(
      args: SelectSubset<T, AccountDeliveryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountDelivery.
     * @param {AccountDeliveryUpsertArgs} args - Arguments to update or create a AccountDelivery.
     * @example
     * // Update or create a AccountDelivery
     * const accountDelivery = await prisma.accountDelivery.upsert({
     *   create: {
     *     // ... data to create a AccountDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountDelivery we want to update
     *   }
     * })
    **/
    upsert<T extends AccountDeliveryUpsertArgs>(
      args: SelectSubset<T, AccountDeliveryUpsertArgs>
    ): CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>>

    /**
     * Find one AccountDelivery that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountDeliveryFindUniqueOrThrowArgs} args - Arguments to find a AccountDelivery
     * @example
     * // Get one AccountDelivery
     * const accountDelivery = await prisma.accountDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountDeliveryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountDeliveryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>>

    /**
     * Find the first AccountDelivery that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeliveryFindFirstOrThrowArgs} args - Arguments to find a AccountDelivery
     * @example
     * // Get one AccountDelivery
     * const accountDelivery = await prisma.accountDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountDeliveryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountDeliveryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountDeliveryClient<AccountDelivery>, Prisma__AccountDeliveryClient<AccountDeliveryGetPayload<T>>>

    /**
     * Count the number of AccountDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeliveryCountArgs} args - Arguments to filter AccountDeliveries to count.
     * @example
     * // Count the number of AccountDeliveries
     * const count = await prisma.accountDelivery.count({
     *   where: {
     *     // ... the filter for the AccountDeliveries we want to count
     *   }
     * })
    **/
    count<T extends AccountDeliveryCountArgs>(
      args?: Subset<T, AccountDeliveryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountDeliveryAggregateArgs>(args: Subset<T, AccountDeliveryAggregateArgs>): PrismaPromise<GetAccountDeliveryAggregateType<T>>

    /**
     * Group by AccountDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: AccountDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountDeliveryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountDeliveryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    delivery<T extends DeliveryArgs = {}>(args?: Subset<T, DeliveryArgs>): CheckSelect<T, Prisma__DeliveryClient<Delivery | Null>, Prisma__DeliveryClient<DeliveryGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AccountDelivery base type for findUnique actions
   */
  export type AccountDeliveryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
    /**
     * Filter, which AccountDelivery to fetch.
     * 
    **/
    where: AccountDeliveryWhereUniqueInput
  }

  /**
   * AccountDelivery: findUnique
   */
  export interface AccountDeliveryFindUniqueArgs extends AccountDeliveryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountDelivery base type for findFirst actions
   */
  export type AccountDeliveryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
    /**
     * Filter, which AccountDelivery to fetch.
     * 
    **/
    where?: AccountDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountDeliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountDeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountDeliveries.
     * 
    **/
    cursor?: AccountDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountDeliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountDeliveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountDeliveries.
     * 
    **/
    distinct?: Enumerable<AccountDeliveryScalarFieldEnum>
  }

  /**
   * AccountDelivery: findFirst
   */
  export interface AccountDeliveryFindFirstArgs extends AccountDeliveryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountDelivery findMany
   */
  export type AccountDeliveryFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
    /**
     * Filter, which AccountDeliveries to fetch.
     * 
    **/
    where?: AccountDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountDeliveries to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountDeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountDeliveries.
     * 
    **/
    cursor?: AccountDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountDeliveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountDeliveries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountDeliveryScalarFieldEnum>
  }


  /**
   * AccountDelivery create
   */
  export type AccountDeliveryCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
    /**
     * The data needed to create a AccountDelivery.
     * 
    **/
    data: XOR<AccountDeliveryCreateInput, AccountDeliveryUncheckedCreateInput>
  }


  /**
   * AccountDelivery createMany
   */
  export type AccountDeliveryCreateManyArgs = {
    /**
     * The data used to create many AccountDeliveries.
     * 
    **/
    data: Enumerable<AccountDeliveryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AccountDelivery update
   */
  export type AccountDeliveryUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
    /**
     * The data needed to update a AccountDelivery.
     * 
    **/
    data: XOR<AccountDeliveryUpdateInput, AccountDeliveryUncheckedUpdateInput>
    /**
     * Choose, which AccountDelivery to update.
     * 
    **/
    where: AccountDeliveryWhereUniqueInput
  }


  /**
   * AccountDelivery updateMany
   */
  export type AccountDeliveryUpdateManyArgs = {
    /**
     * The data used to update AccountDeliveries.
     * 
    **/
    data: XOR<AccountDeliveryUpdateManyMutationInput, AccountDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which AccountDeliveries to update
     * 
    **/
    where?: AccountDeliveryWhereInput
  }


  /**
   * AccountDelivery upsert
   */
  export type AccountDeliveryUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
    /**
     * The filter to search for the AccountDelivery to update in case it exists.
     * 
    **/
    where: AccountDeliveryWhereUniqueInput
    /**
     * In case the AccountDelivery found by the `where` argument doesn't exist, create a new AccountDelivery with this data.
     * 
    **/
    create: XOR<AccountDeliveryCreateInput, AccountDeliveryUncheckedCreateInput>
    /**
     * In case the AccountDelivery was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountDeliveryUpdateInput, AccountDeliveryUncheckedUpdateInput>
  }


  /**
   * AccountDelivery delete
   */
  export type AccountDeliveryDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
    /**
     * Filter which AccountDelivery to delete.
     * 
    **/
    where: AccountDeliveryWhereUniqueInput
  }


  /**
   * AccountDelivery deleteMany
   */
  export type AccountDeliveryDeleteManyArgs = {
    /**
     * Filter which AccountDeliveries to delete
     * 
    **/
    where?: AccountDeliveryWhereInput
  }


  /**
   * AccountDelivery: findUniqueOrThrow
   */
  export type AccountDeliveryFindUniqueOrThrowArgs = AccountDeliveryFindUniqueArgsBase
      

  /**
   * AccountDelivery: findFirstOrThrow
   */
  export type AccountDeliveryFindFirstOrThrowArgs = AccountDeliveryFindFirstArgsBase
      

  /**
   * AccountDelivery without action
   */
  export type AccountDeliveryArgs = {
    /**
     * Select specific fields to fetch from the AccountDelivery
     * 
    **/
    select?: AccountDeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountDeliveryInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    whatsapp: string | null
    phone: string | null
    cpf_cnpj: string | null
    photo: string | null
    gender: GenderType | null
    birthdate: Date | null
    google_id: string | null
    apple_id: string | null
    facebook_id: string | null
    rd_station_id: string | null
    rd_station_sync: boolean | null
    created_at: Date | null
    updated_at: Date | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    whatsapp: string | null
    phone: string | null
    cpf_cnpj: string | null
    photo: string | null
    gender: GenderType | null
    birthdate: Date | null
    google_id: string | null
    apple_id: string | null
    facebook_id: string | null
    rd_station_id: string | null
    rd_station_sync: boolean | null
    created_at: Date | null
    updated_at: Date | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    whatsapp: number
    phone: number
    cpf_cnpj: number
    photo: number
    gender: number
    birthdate: number
    google_id: number
    apple_id: number
    facebook_id: number
    rd_station_id: number
    rd_station_sync: number
    created_at: number
    updated_at: number
    lastLogin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    whatsapp?: true
    phone?: true
    cpf_cnpj?: true
    photo?: true
    gender?: true
    birthdate?: true
    google_id?: true
    apple_id?: true
    facebook_id?: true
    rd_station_id?: true
    rd_station_sync?: true
    created_at?: true
    updated_at?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    whatsapp?: true
    phone?: true
    cpf_cnpj?: true
    photo?: true
    gender?: true
    birthdate?: true
    google_id?: true
    apple_id?: true
    facebook_id?: true
    rd_station_id?: true
    rd_station_sync?: true
    created_at?: true
    updated_at?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    whatsapp?: true
    phone?: true
    cpf_cnpj?: true
    photo?: true
    gender?: true
    birthdate?: true
    google_id?: true
    apple_id?: true
    facebook_id?: true
    rd_station_id?: true
    rd_station_sync?: true
    created_at?: true
    updated_at?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    whatsapp: string | null
    phone: string | null
    cpf_cnpj: string | null
    photo: string | null
    gender: GenderType
    birthdate: Date | null
    google_id: string | null
    apple_id: string | null
    facebook_id: string | null
    rd_station_id: string | null
    rd_station_sync: boolean | null
    created_at: Date
    updated_at: Date
    lastLogin: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    whatsapp?: boolean
    phone?: boolean
    cpf_cnpj?: boolean
    photo?: boolean
    gender?: boolean
    birthdate?: boolean
    google_id?: boolean
    apple_id?: boolean
    facebook_id?: boolean
    rd_station_id?: boolean
    rd_station_sync?: boolean
    created_at?: boolean
    updated_at?: boolean
    lastLogin?: boolean
    device_user?: boolean | DeviceUserFindManyArgs
    account_user?: boolean | AccountUserFindManyArgs
    orders?: boolean | OrderFindManyArgs
    user_addresses?: boolean | UserAddressFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    device_user?: boolean | DeviceUserFindManyArgs
    account_user?: boolean | AccountUserFindManyArgs
    orders?: boolean | OrderFindManyArgs
    user_addresses?: boolean | UserAddressFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'account_user' ? Array < AccountUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'user_addresses' ? Array < UserAddressGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'account_user' ? Array < AccountUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'user_addresses' ? Array < UserAddressGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device_user<T extends DeviceUserFindManyArgs = {}>(args?: Subset<T, DeviceUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceUser>| Null>, PrismaPromise<Array<DeviceUserGetPayload<T>>| Null>>;

    account_user<T extends AccountUserFindManyArgs = {}>(args?: Subset<T, AccountUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountUser>| Null>, PrismaPromise<Array<AccountUserGetPayload<T>>| Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    user_addresses<T extends UserAddressFindManyArgs = {}>(args?: Subset<T, UserAddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserAddress>| Null>, PrismaPromise<Array<UserAddressGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model UserAddress
   */


  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    street: string | null
    number: string | null
    district: string | null
    state: string | null
    complement: string | null
    additional_information: string | null
    city: string | null
    zip_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    street: string | null
    number: string | null
    district: string | null
    state: string | null
    complement: string | null
    additional_information: string | null
    city: string | null
    zip_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    street: number
    number: number
    district: number
    state: number
    complement: number
    additional_information: number
    city: number
    zip_code: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserAddressMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    street?: true
    number?: true
    district?: true
    state?: true
    complement?: true
    additional_information?: true
    city?: true
    zip_code?: true
    created_at?: true
    updated_at?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    street?: true
    number?: true
    district?: true
    state?: true
    complement?: true
    additional_information?: true
    city?: true
    zip_code?: true
    created_at?: true
    updated_at?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    street?: true
    number?: true
    district?: true
    state?: true
    complement?: true
    additional_information?: true
    city?: true
    zip_code?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAddressAggregateArgs = {
    /**
     * Filter which UserAddress to aggregate.
     * 
    **/
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs = {
    where?: UserAddressWhereInput
    orderBy?: Enumerable<UserAddressOrderByWithAggregationInput>
    by: Array<UserAddressScalarFieldEnum>
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }


  export type UserAddressGroupByOutputType = {
    id: string
    user_id: string
    name: string | null
    street: string
    number: string
    district: string
    state: string
    complement: string | null
    additional_information: string | null
    city: string
    zip_code: string
    created_at: Date
    updated_at: Date
    _count: UserAddressCountAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect = {
    id?: boolean
    user_id?: boolean
    user?: boolean | UserArgs
    name?: boolean
    street?: boolean
    number?: boolean
    district?: boolean
    state?: boolean
    complement?: boolean
    additional_information?: boolean
    city?: boolean
    zip_code?: boolean
    orders?: boolean | OrderFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | UserAddressCountOutputTypeArgs
  }

  export type UserAddressInclude = {
    user?: boolean | UserArgs
    orders?: boolean | OrderFindManyArgs
    _count?: boolean | UserAddressCountOutputTypeArgs
  }

  export type UserAddressGetPayload<
    S extends boolean | null | undefined | UserAddressArgs,
    U = keyof S
      > = S extends true
        ? UserAddress
    : S extends undefined
    ? never
    : S extends UserAddressArgs | UserAddressFindManyArgs
    ?'include' extends U
    ? UserAddress  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserAddressCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserAddressCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof UserAddress ? UserAddress[P] : never
  } 
    : UserAddress
  : UserAddress


  type UserAddressCountArgs = Merge<
    Omit<UserAddressFindManyArgs, 'select' | 'include'> & {
      select?: UserAddressCountAggregateInputType | true
    }
  >

  export interface UserAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserAddress'> extends True ? CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>> : CheckSelect<T, Prisma__UserAddressClient<UserAddress | null, null>, Prisma__UserAddressClient<UserAddressGetPayload<T> | null, null>>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserAddress'> extends True ? CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>> : CheckSelect<T, Prisma__UserAddressClient<UserAddress | null, null>, Prisma__UserAddressClient<UserAddressGetPayload<T> | null, null>>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAddressFindManyArgs>(
      args?: SelectSubset<T, UserAddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserAddress>>, PrismaPromise<Array<UserAddressGetPayload<T>>>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
    **/
    create<T extends UserAddressCreateArgs>(
      args: SelectSubset<T, UserAddressCreateArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Create many UserAddresses.
     *     @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     *     @example
     *     // Create many UserAddresses
     *     const userAddress = await prisma.userAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAddressCreateManyArgs>(
      args?: SelectSubset<T, UserAddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
    **/
    delete<T extends UserAddressDeleteArgs>(
      args: SelectSubset<T, UserAddressDeleteArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAddressUpdateArgs>(
      args: SelectSubset<T, UserAddressUpdateArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAddressDeleteManyArgs>(
      args?: SelectSubset<T, UserAddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAddressUpdateManyArgs>(
      args: SelectSubset<T, UserAddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
    **/
    upsert<T extends UserAddressUpsertArgs>(
      args: SelectSubset<T, UserAddressUpsertArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Find one UserAddress that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserAddressFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserAddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserAddress base type for findUnique actions
   */
  export type UserAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddress to fetch.
     * 
    **/
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress: findUnique
   */
  export interface UserAddressFindUniqueArgs extends UserAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAddress base type for findFirst actions
   */
  export type UserAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddress to fetch.
     * 
    **/
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     * 
    **/
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     * 
    **/
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }

  /**
   * UserAddress: findFirst
   */
  export interface UserAddressFindFirstArgs extends UserAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddresses to fetch.
     * 
    **/
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     * 
    **/
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
    /**
     * The data needed to create a UserAddress.
     * 
    **/
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }


  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs = {
    /**
     * The data used to create many UserAddresses.
     * 
    **/
    data: Enumerable<UserAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
    /**
     * The data needed to update a UserAddress.
     * 
    **/
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     * 
    **/
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs = {
    /**
     * The data used to update UserAddresses.
     * 
    **/
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     * 
    **/
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     * 
    **/
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     * 
    **/
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }


  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
    /**
     * Filter which UserAddress to delete.
     * 
    **/
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs = {
    /**
     * Filter which UserAddresses to delete
     * 
    **/
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress: findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs = UserAddressFindUniqueArgsBase
      

  /**
   * UserAddress: findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs = UserAddressFindFirstArgsBase
      

  /**
   * UserAddress without action
   */
  export type UserAddressArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     * 
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserAddressInclude | null
  }



  /**
   * Model AccountUser
   */


  export type AggregateAccountUser = {
    _count: AccountUserCountAggregateOutputType | null
    _min: AccountUserMinAggregateOutputType | null
    _max: AccountUserMaxAggregateOutputType | null
  }

  export type AccountUserMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    user_id: string | null
    role_id: string | null
  }

  export type AccountUserMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    user_id: string | null
    role_id: string | null
  }

  export type AccountUserCountAggregateOutputType = {
    id: number
    account_id: number
    user_id: number
    role_id: number
    _all: number
  }


  export type AccountUserMinAggregateInputType = {
    id?: true
    account_id?: true
    user_id?: true
    role_id?: true
  }

  export type AccountUserMaxAggregateInputType = {
    id?: true
    account_id?: true
    user_id?: true
    role_id?: true
  }

  export type AccountUserCountAggregateInputType = {
    id?: true
    account_id?: true
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type AccountUserAggregateArgs = {
    /**
     * Filter which AccountUser to aggregate.
     * 
    **/
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountUsers
    **/
    _count?: true | AccountUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountUserMaxAggregateInputType
  }

  export type GetAccountUserAggregateType<T extends AccountUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountUser[P]>
      : GetScalarType<T[P], AggregateAccountUser[P]>
  }




  export type AccountUserGroupByArgs = {
    where?: AccountUserWhereInput
    orderBy?: Enumerable<AccountUserOrderByWithAggregationInput>
    by: Array<AccountUserScalarFieldEnum>
    having?: AccountUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountUserCountAggregateInputType | true
    _min?: AccountUserMinAggregateInputType
    _max?: AccountUserMaxAggregateInputType
  }


  export type AccountUserGroupByOutputType = {
    id: string
    account_id: string
    user_id: string
    role_id: string
    _count: AccountUserCountAggregateOutputType | null
    _min: AccountUserMinAggregateOutputType | null
    _max: AccountUserMaxAggregateOutputType | null
  }

  type GetAccountUserGroupByPayload<T extends AccountUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountUserGroupByOutputType[P]>
            : GetScalarType<T[P], AccountUserGroupByOutputType[P]>
        }
      >
    >


  export type AccountUserSelect = {
    id?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    user_id?: boolean
    user?: boolean | UserArgs
    role_id?: boolean
    role?: boolean | RoleArgs
  }

  export type AccountUserInclude = {
    account?: boolean | AccountArgs
    user?: boolean | UserArgs
    role?: boolean | RoleArgs
  }

  export type AccountUserGetPayload<
    S extends boolean | null | undefined | AccountUserArgs,
    U = keyof S
      > = S extends true
        ? AccountUser
    : S extends undefined
    ? never
    : S extends AccountUserArgs | AccountUserFindManyArgs
    ?'include' extends U
    ? AccountUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'role' ? RoleGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'role' ? RoleGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof AccountUser ? AccountUser[P] : never
  } 
    : AccountUser
  : AccountUser


  type AccountUserCountArgs = Merge<
    Omit<AccountUserFindManyArgs, 'select' | 'include'> & {
      select?: AccountUserCountAggregateInputType | true
    }
  >

  export interface AccountUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AccountUser that matches the filter.
     * @param {AccountUserFindUniqueArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AccountUser'> extends True ? CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>> : CheckSelect<T, Prisma__AccountUserClient<AccountUser | null, null>, Prisma__AccountUserClient<AccountUserGetPayload<T> | null, null>>

    /**
     * Find the first AccountUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindFirstArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AccountUser'> extends True ? CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>> : CheckSelect<T, Prisma__AccountUserClient<AccountUser | null, null>, Prisma__AccountUserClient<AccountUserGetPayload<T> | null, null>>

    /**
     * Find zero or more AccountUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountUsers
     * const accountUsers = await prisma.accountUser.findMany()
     * 
     * // Get first 10 AccountUsers
     * const accountUsers = await prisma.accountUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountUserWithIdOnly = await prisma.accountUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountUserFindManyArgs>(
      args?: SelectSubset<T, AccountUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AccountUser>>, PrismaPromise<Array<AccountUserGetPayload<T>>>>

    /**
     * Create a AccountUser.
     * @param {AccountUserCreateArgs} args - Arguments to create a AccountUser.
     * @example
     * // Create one AccountUser
     * const AccountUser = await prisma.accountUser.create({
     *   data: {
     *     // ... data to create a AccountUser
     *   }
     * })
     * 
    **/
    create<T extends AccountUserCreateArgs>(
      args: SelectSubset<T, AccountUserCreateArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Create many AccountUsers.
     *     @param {AccountUserCreateManyArgs} args - Arguments to create many AccountUsers.
     *     @example
     *     // Create many AccountUsers
     *     const accountUser = await prisma.accountUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountUserCreateManyArgs>(
      args?: SelectSubset<T, AccountUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AccountUser.
     * @param {AccountUserDeleteArgs} args - Arguments to delete one AccountUser.
     * @example
     * // Delete one AccountUser
     * const AccountUser = await prisma.accountUser.delete({
     *   where: {
     *     // ... filter to delete one AccountUser
     *   }
     * })
     * 
    **/
    delete<T extends AccountUserDeleteArgs>(
      args: SelectSubset<T, AccountUserDeleteArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Update one AccountUser.
     * @param {AccountUserUpdateArgs} args - Arguments to update one AccountUser.
     * @example
     * // Update one AccountUser
     * const accountUser = await prisma.accountUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUserUpdateArgs>(
      args: SelectSubset<T, AccountUserUpdateArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Delete zero or more AccountUsers.
     * @param {AccountUserDeleteManyArgs} args - Arguments to filter AccountUsers to delete.
     * @example
     * // Delete a few AccountUsers
     * const { count } = await prisma.accountUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountUserDeleteManyArgs>(
      args?: SelectSubset<T, AccountUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountUsers
     * const accountUser = await prisma.accountUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUserUpdateManyArgs>(
      args: SelectSubset<T, AccountUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountUser.
     * @param {AccountUserUpsertArgs} args - Arguments to update or create a AccountUser.
     * @example
     * // Update or create a AccountUser
     * const accountUser = await prisma.accountUser.upsert({
     *   create: {
     *     // ... data to create a AccountUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountUser we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUserUpsertArgs>(
      args: SelectSubset<T, AccountUserUpsertArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Find one AccountUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountUserFindUniqueOrThrowArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Find the first AccountUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindFirstOrThrowArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountUserClient<AccountUser>, Prisma__AccountUserClient<AccountUserGetPayload<T>>>

    /**
     * Count the number of AccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserCountArgs} args - Arguments to filter AccountUsers to count.
     * @example
     * // Count the number of AccountUsers
     * const count = await prisma.accountUser.count({
     *   where: {
     *     // ... the filter for the AccountUsers we want to count
     *   }
     * })
    **/
    count<T extends AccountUserCountArgs>(
      args?: Subset<T, AccountUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountUserAggregateArgs>(args: Subset<T, AccountUserAggregateArgs>): PrismaPromise<GetAccountUserAggregateType<T>>

    /**
     * Group by AccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountUserGroupByArgs['orderBy'] }
        : { orderBy?: AccountUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountUserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | Null>, Prisma__RoleClient<RoleGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AccountUser base type for findUnique actions
   */
  export type AccountUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter, which AccountUser to fetch.
     * 
    **/
    where: AccountUserWhereUniqueInput
  }

  /**
   * AccountUser: findUnique
   */
  export interface AccountUserFindUniqueArgs extends AccountUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountUser base type for findFirst actions
   */
  export type AccountUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter, which AccountUser to fetch.
     * 
    **/
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountUsers.
     * 
    **/
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountUsers.
     * 
    **/
    distinct?: Enumerable<AccountUserScalarFieldEnum>
  }

  /**
   * AccountUser: findFirst
   */
  export interface AccountUserFindFirstArgs extends AccountUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AccountUser findMany
   */
  export type AccountUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter, which AccountUsers to fetch.
     * 
    **/
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountUsers.
     * 
    **/
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountUserScalarFieldEnum>
  }


  /**
   * AccountUser create
   */
  export type AccountUserCreateArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * The data needed to create a AccountUser.
     * 
    **/
    data: XOR<AccountUserCreateInput, AccountUserUncheckedCreateInput>
  }


  /**
   * AccountUser createMany
   */
  export type AccountUserCreateManyArgs = {
    /**
     * The data used to create many AccountUsers.
     * 
    **/
    data: Enumerable<AccountUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AccountUser update
   */
  export type AccountUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * The data needed to update a AccountUser.
     * 
    **/
    data: XOR<AccountUserUpdateInput, AccountUserUncheckedUpdateInput>
    /**
     * Choose, which AccountUser to update.
     * 
    **/
    where: AccountUserWhereUniqueInput
  }


  /**
   * AccountUser updateMany
   */
  export type AccountUserUpdateManyArgs = {
    /**
     * The data used to update AccountUsers.
     * 
    **/
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyInput>
    /**
     * Filter which AccountUsers to update
     * 
    **/
    where?: AccountUserWhereInput
  }


  /**
   * AccountUser upsert
   */
  export type AccountUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * The filter to search for the AccountUser to update in case it exists.
     * 
    **/
    where: AccountUserWhereUniqueInput
    /**
     * In case the AccountUser found by the `where` argument doesn't exist, create a new AccountUser with this data.
     * 
    **/
    create: XOR<AccountUserCreateInput, AccountUserUncheckedCreateInput>
    /**
     * In case the AccountUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUserUpdateInput, AccountUserUncheckedUpdateInput>
  }


  /**
   * AccountUser delete
   */
  export type AccountUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
    /**
     * Filter which AccountUser to delete.
     * 
    **/
    where: AccountUserWhereUniqueInput
  }


  /**
   * AccountUser deleteMany
   */
  export type AccountUserDeleteManyArgs = {
    /**
     * Filter which AccountUsers to delete
     * 
    **/
    where?: AccountUserWhereInput
  }


  /**
   * AccountUser: findUniqueOrThrow
   */
  export type AccountUserFindUniqueOrThrowArgs = AccountUserFindUniqueArgsBase
      

  /**
   * AccountUser: findFirstOrThrow
   */
  export type AccountUserFindFirstOrThrowArgs = AccountUserFindFirstArgsBase
      

  /**
   * AccountUser without action
   */
  export type AccountUserArgs = {
    /**
     * Select specific fields to fetch from the AccountUser
     * 
    **/
    select?: AccountUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountUserInclude | null
  }



  /**
   * Model Permision
   */


  export type AggregatePermision = {
    _count: PermisionCountAggregateOutputType | null
    _min: PermisionMinAggregateOutputType | null
    _max: PermisionMaxAggregateOutputType | null
  }

  export type PermisionMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type PermisionMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type PermisionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PermisionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PermisionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PermisionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PermisionAggregateArgs = {
    /**
     * Filter which Permision to aggregate.
     * 
    **/
    where?: PermisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PermisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permisions
    **/
    _count?: true | PermisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermisionMaxAggregateInputType
  }

  export type GetPermisionAggregateType<T extends PermisionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermision[P]>
      : GetScalarType<T[P], AggregatePermision[P]>
  }




  export type PermisionGroupByArgs = {
    where?: PermisionWhereInput
    orderBy?: Enumerable<PermisionOrderByWithAggregationInput>
    by: Array<PermisionScalarFieldEnum>
    having?: PermisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermisionCountAggregateInputType | true
    _min?: PermisionMinAggregateInputType
    _max?: PermisionMaxAggregateInputType
  }


  export type PermisionGroupByOutputType = {
    id: string
    name: string
    _count: PermisionCountAggregateOutputType | null
    _min: PermisionMinAggregateOutputType | null
    _max: PermisionMaxAggregateOutputType | null
  }

  type GetPermisionGroupByPayload<T extends PermisionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PermisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermisionGroupByOutputType[P]>
            : GetScalarType<T[P], PermisionGroupByOutputType[P]>
        }
      >
    >


  export type PermisionSelect = {
    id?: boolean
    name?: boolean
    RolePermission?: boolean | RolePermissionFindManyArgs
    _count?: boolean | PermisionCountOutputTypeArgs
  }

  export type PermisionInclude = {
    RolePermission?: boolean | RolePermissionFindManyArgs
    _count?: boolean | PermisionCountOutputTypeArgs
  }

  export type PermisionGetPayload<
    S extends boolean | null | undefined | PermisionArgs,
    U = keyof S
      > = S extends true
        ? Permision
    : S extends undefined
    ? never
    : S extends PermisionArgs | PermisionFindManyArgs
    ?'include' extends U
    ? Permision  & {
    [P in TrueKeys<S['include']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PermisionCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PermisionCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Permision ? Permision[P] : never
  } 
    : Permision
  : Permision


  type PermisionCountArgs = Merge<
    Omit<PermisionFindManyArgs, 'select' | 'include'> & {
      select?: PermisionCountAggregateInputType | true
    }
  >

  export interface PermisionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Permision that matches the filter.
     * @param {PermisionFindUniqueArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermisionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermisionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permision'> extends True ? CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>> : CheckSelect<T, Prisma__PermisionClient<Permision | null, null>, Prisma__PermisionClient<PermisionGetPayload<T> | null, null>>

    /**
     * Find the first Permision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionFindFirstArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermisionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermisionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permision'> extends True ? CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>> : CheckSelect<T, Prisma__PermisionClient<Permision | null, null>, Prisma__PermisionClient<PermisionGetPayload<T> | null, null>>

    /**
     * Find zero or more Permisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permisions
     * const permisions = await prisma.permision.findMany()
     * 
     * // Get first 10 Permisions
     * const permisions = await prisma.permision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permisionWithIdOnly = await prisma.permision.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermisionFindManyArgs>(
      args?: SelectSubset<T, PermisionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Permision>>, PrismaPromise<Array<PermisionGetPayload<T>>>>

    /**
     * Create a Permision.
     * @param {PermisionCreateArgs} args - Arguments to create a Permision.
     * @example
     * // Create one Permision
     * const Permision = await prisma.permision.create({
     *   data: {
     *     // ... data to create a Permision
     *   }
     * })
     * 
    **/
    create<T extends PermisionCreateArgs>(
      args: SelectSubset<T, PermisionCreateArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Create many Permisions.
     *     @param {PermisionCreateManyArgs} args - Arguments to create many Permisions.
     *     @example
     *     // Create many Permisions
     *     const permision = await prisma.permision.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermisionCreateManyArgs>(
      args?: SelectSubset<T, PermisionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Permision.
     * @param {PermisionDeleteArgs} args - Arguments to delete one Permision.
     * @example
     * // Delete one Permision
     * const Permision = await prisma.permision.delete({
     *   where: {
     *     // ... filter to delete one Permision
     *   }
     * })
     * 
    **/
    delete<T extends PermisionDeleteArgs>(
      args: SelectSubset<T, PermisionDeleteArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Update one Permision.
     * @param {PermisionUpdateArgs} args - Arguments to update one Permision.
     * @example
     * // Update one Permision
     * const permision = await prisma.permision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermisionUpdateArgs>(
      args: SelectSubset<T, PermisionUpdateArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Delete zero or more Permisions.
     * @param {PermisionDeleteManyArgs} args - Arguments to filter Permisions to delete.
     * @example
     * // Delete a few Permisions
     * const { count } = await prisma.permision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermisionDeleteManyArgs>(
      args?: SelectSubset<T, PermisionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permisions
     * const permision = await prisma.permision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermisionUpdateManyArgs>(
      args: SelectSubset<T, PermisionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Permision.
     * @param {PermisionUpsertArgs} args - Arguments to update or create a Permision.
     * @example
     * // Update or create a Permision
     * const permision = await prisma.permision.upsert({
     *   create: {
     *     // ... data to create a Permision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permision we want to update
     *   }
     * })
    **/
    upsert<T extends PermisionUpsertArgs>(
      args: SelectSubset<T, PermisionUpsertArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Find one Permision that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PermisionFindUniqueOrThrowArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermisionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PermisionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Find the first Permision that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionFindFirstOrThrowArgs} args - Arguments to find a Permision
     * @example
     * // Get one Permision
     * const permision = await prisma.permision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermisionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PermisionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PermisionClient<Permision>, Prisma__PermisionClient<PermisionGetPayload<T>>>

    /**
     * Count the number of Permisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionCountArgs} args - Arguments to filter Permisions to count.
     * @example
     * // Count the number of Permisions
     * const count = await prisma.permision.count({
     *   where: {
     *     // ... the filter for the Permisions we want to count
     *   }
     * })
    **/
    count<T extends PermisionCountArgs>(
      args?: Subset<T, PermisionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermisionAggregateArgs>(args: Subset<T, PermisionAggregateArgs>): PrismaPromise<GetPermisionAggregateType<T>>

    /**
     * Group by Permision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermisionGroupByArgs['orderBy'] }
        : { orderBy?: PermisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermisionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Permision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermisionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RolePermission<T extends RolePermissionFindManyArgs = {}>(args?: Subset<T, RolePermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RolePermission>| Null>, PrismaPromise<Array<RolePermissionGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Permision base type for findUnique actions
   */
  export type PermisionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter, which Permision to fetch.
     * 
    **/
    where: PermisionWhereUniqueInput
  }

  /**
   * Permision: findUnique
   */
  export interface PermisionFindUniqueArgs extends PermisionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permision base type for findFirst actions
   */
  export type PermisionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter, which Permision to fetch.
     * 
    **/
    where?: PermisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisions.
     * 
    **/
    cursor?: PermisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisions.
     * 
    **/
    distinct?: Enumerable<PermisionScalarFieldEnum>
  }

  /**
   * Permision: findFirst
   */
  export interface PermisionFindFirstArgs extends PermisionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permision findMany
   */
  export type PermisionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter, which Permisions to fetch.
     * 
    **/
    where?: PermisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermisionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permisions.
     * 
    **/
    cursor?: PermisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PermisionScalarFieldEnum>
  }


  /**
   * Permision create
   */
  export type PermisionCreateArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * The data needed to create a Permision.
     * 
    **/
    data: XOR<PermisionCreateInput, PermisionUncheckedCreateInput>
  }


  /**
   * Permision createMany
   */
  export type PermisionCreateManyArgs = {
    /**
     * The data used to create many Permisions.
     * 
    **/
    data: Enumerable<PermisionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Permision update
   */
  export type PermisionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * The data needed to update a Permision.
     * 
    **/
    data: XOR<PermisionUpdateInput, PermisionUncheckedUpdateInput>
    /**
     * Choose, which Permision to update.
     * 
    **/
    where: PermisionWhereUniqueInput
  }


  /**
   * Permision updateMany
   */
  export type PermisionUpdateManyArgs = {
    /**
     * The data used to update Permisions.
     * 
    **/
    data: XOR<PermisionUpdateManyMutationInput, PermisionUncheckedUpdateManyInput>
    /**
     * Filter which Permisions to update
     * 
    **/
    where?: PermisionWhereInput
  }


  /**
   * Permision upsert
   */
  export type PermisionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * The filter to search for the Permision to update in case it exists.
     * 
    **/
    where: PermisionWhereUniqueInput
    /**
     * In case the Permision found by the `where` argument doesn't exist, create a new Permision with this data.
     * 
    **/
    create: XOR<PermisionCreateInput, PermisionUncheckedCreateInput>
    /**
     * In case the Permision was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PermisionUpdateInput, PermisionUncheckedUpdateInput>
  }


  /**
   * Permision delete
   */
  export type PermisionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
    /**
     * Filter which Permision to delete.
     * 
    **/
    where: PermisionWhereUniqueInput
  }


  /**
   * Permision deleteMany
   */
  export type PermisionDeleteManyArgs = {
    /**
     * Filter which Permisions to delete
     * 
    **/
    where?: PermisionWhereInput
  }


  /**
   * Permision: findUniqueOrThrow
   */
  export type PermisionFindUniqueOrThrowArgs = PermisionFindUniqueArgsBase
      

  /**
   * Permision: findFirstOrThrow
   */
  export type PermisionFindFirstOrThrowArgs = PermisionFindFirstArgsBase
      

  /**
   * Permision without action
   */
  export type PermisionArgs = {
    /**
     * Select specific fields to fetch from the Permision
     * 
    **/
    select?: PermisionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermisionInclude | null
  }



  /**
   * Model RolePermission
   */


  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    role_id: string | null
    permission_id: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    role_id: string | null
    permission_id: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    role_id: number
    permission_id: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type RolePermissionCountAggregateInputType = {
    role_id?: true
    permission_id?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs = {
    /**
     * Filter which RolePermission to aggregate.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs = {
    where?: RolePermissionWhereInput
    orderBy?: Enumerable<RolePermissionOrderByWithAggregationInput>
    by: Array<RolePermissionScalarFieldEnum>
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }


  export type RolePermissionGroupByOutputType = {
    role_id: string
    permission_id: string
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect = {
    role_id?: boolean
    role?: boolean | RoleArgs
    permission_id?: boolean
    permission?: boolean | PermisionArgs
  }

  export type RolePermissionInclude = {
    role?: boolean | RoleArgs
    permission?: boolean | PermisionArgs
  }

  export type RolePermissionGetPayload<
    S extends boolean | null | undefined | RolePermissionArgs,
    U = keyof S
      > = S extends true
        ? RolePermission
    : S extends undefined
    ? never
    : S extends RolePermissionArgs | RolePermissionFindManyArgs
    ?'include' extends U
    ? RolePermission  & {
    [P in TrueKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'permission' ? PermisionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'role' ? RoleGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'permission' ? PermisionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof RolePermission ? RolePermission[P] : never
  } 
    : RolePermission
  : RolePermission


  type RolePermissionCountArgs = Merge<
    Omit<RolePermissionFindManyArgs, 'select' | 'include'> & {
      select?: RolePermissionCountAggregateInputType | true
    }
  >

  export interface RolePermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolePermissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolePermissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RolePermission'> extends True ? CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionClient<RolePermission | null, null>, Prisma__RolePermissionClient<RolePermissionGetPayload<T> | null, null>>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolePermissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolePermissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RolePermission'> extends True ? CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionClient<RolePermission | null, null>, Prisma__RolePermissionClient<RolePermissionGetPayload<T> | null, null>>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const rolePermissionWithRole_idOnly = await prisma.rolePermission.findMany({ select: { role_id: true } })
     * 
    **/
    findMany<T extends RolePermissionFindManyArgs>(
      args?: SelectSubset<T, RolePermissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RolePermission>>, PrismaPromise<Array<RolePermissionGetPayload<T>>>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
    **/
    create<T extends RolePermissionCreateArgs>(
      args: SelectSubset<T, RolePermissionCreateArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Create many RolePermissions.
     *     @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     *     @example
     *     // Create many RolePermissions
     *     const rolePermission = await prisma.rolePermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolePermissionCreateManyArgs>(
      args?: SelectSubset<T, RolePermissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
    **/
    delete<T extends RolePermissionDeleteArgs>(
      args: SelectSubset<T, RolePermissionDeleteArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolePermissionUpdateArgs>(
      args: SelectSubset<T, RolePermissionUpdateArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolePermissionDeleteManyArgs>(
      args?: SelectSubset<T, RolePermissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolePermissionUpdateManyArgs>(
      args: SelectSubset<T, RolePermissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
    **/
    upsert<T extends RolePermissionUpsertArgs>(
      args: SelectSubset<T, RolePermissionUpsertArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Find one RolePermission that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolePermissionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | Null>, Prisma__RoleClient<RoleGetPayload<T> | Null>>;

    permission<T extends PermisionArgs = {}>(args?: Subset<T, PermisionArgs>): CheckSelect<T, Prisma__PermisionClient<Permision | Null>, Prisma__PermisionClient<PermisionGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RolePermission base type for findUnique actions
   */
  export type RolePermissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter, which RolePermission to fetch.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission: findUnique
   */
  export interface RolePermissionFindUniqueArgs extends RolePermissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RolePermission base type for findFirst actions
   */
  export type RolePermissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter, which RolePermission to fetch.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     * 
    **/
    distinct?: Enumerable<RolePermissionScalarFieldEnum>
  }

  /**
   * RolePermission: findFirst
   */
  export interface RolePermissionFindFirstArgs extends RolePermissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter, which RolePermissions to fetch.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolePermissionScalarFieldEnum>
  }


  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The data needed to create a RolePermission.
     * 
    **/
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }


  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs = {
    /**
     * The data used to create many RolePermissions.
     * 
    **/
    data: Enumerable<RolePermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The data needed to update a RolePermission.
     * 
    **/
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs = {
    /**
     * The data used to update RolePermissions.
     * 
    **/
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     * 
    **/
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     * 
    **/
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     * 
    **/
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }


  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter which RolePermission to delete.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs = {
    /**
     * Filter which RolePermissions to delete
     * 
    **/
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission: findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs = RolePermissionFindUniqueArgsBase
      

  /**
   * RolePermission: findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs = RolePermissionFindFirstArgsBase
      

  /**
   * RolePermission without action
   */
  export type RolePermissionArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: Array<RoleScalarFieldEnum>
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: string
    name: string
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    name?: boolean
    RolePermission?: boolean | RolePermissionFindManyArgs
    AccountUser?: boolean | AccountUserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleInclude = {
    RolePermission?: boolean | RolePermissionFindManyArgs
    AccountUser?: boolean | AccountUserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role  & {
    [P in TrueKeys<S['include']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'AccountUser' ? Array < AccountUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'AccountUser' ? Array < AccountUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Role ? Role[P] : never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null, null>, Prisma__RoleClient<RoleGetPayload<T> | null, null>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null, null>, Prisma__RoleClient<RoleGetPayload<T> | null, null>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Find one Role that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RolePermission<T extends RolePermissionFindManyArgs = {}>(args?: Subset<T, RolePermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RolePermission>| Null>, PrismaPromise<Array<RolePermissionGetPayload<T>>| Null>>;

    AccountUser<T extends AccountUserFindManyArgs = {}>(args?: Subset<T, AccountUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AccountUser>| Null>, PrismaPromise<Array<AccountUserGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where: RoleWhereUniqueInput
  }

  /**
   * Role: findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role: findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     * 
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     * 
    **/
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     * 
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     * 
    **/
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     * 
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     * 
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role: findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = RoleFindUniqueArgsBase
      

  /**
   * Role: findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = RoleFindFirstArgsBase
      

  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
  }



  /**
   * Model Campaign
   */


  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    external_id: number | null
    discount_value: number | null
  }

  export type CampaignSumAggregateOutputType = {
    external_id: number | null
    discount_value: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    discount_value: number | null
    discount_type: CampaignTypeDiscount | null
    start_date: Date | null
    expiration_date: Date | null
    campaign_type_id: string | null
    account_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    discount_value: number | null
    discount_type: CampaignTypeDiscount | null
    start_date: Date | null
    expiration_date: Date | null
    campaign_type_id: string | null
    account_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    description: number
    discount_value: number
    discount_type: number
    start_date: number
    expiration_date: number
    campaign_type_id: number
    account_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    external_id?: true
    discount_value?: true
  }

  export type CampaignSumAggregateInputType = {
    external_id?: true
    discount_value?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    discount_value?: true
    discount_type?: true
    start_date?: true
    expiration_date?: true
    campaign_type_id?: true
    account_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    discount_value?: true
    discount_type?: true
    start_date?: true
    expiration_date?: true
    campaign_type_id?: true
    account_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    discount_value?: true
    discount_type?: true
    start_date?: true
    expiration_date?: true
    campaign_type_id?: true
    account_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CampaignAggregateArgs = {
    /**
     * Filter which Campaign to aggregate.
     * 
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs = {
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithAggregationInput>
    by: Array<CampaignScalarFieldEnum>
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }


  export type CampaignGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    description: string | null
    discount_value: number | null
    discount_type: CampaignTypeDiscount | null
    start_date: Date | null
    expiration_date: Date | null
    campaign_type_id: string
    account_id: string
    created_at: Date
    updated_at: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    description?: boolean
    discount_value?: boolean
    discount_type?: boolean
    start_date?: boolean
    expiration_date?: boolean
    campaign_type_id?: boolean
    campaign_type?: boolean | CampaignTypeArgs
    account?: boolean | AccountArgs
    account_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    orders?: boolean | OrderFindManyArgs
    campaign_items?: boolean | CampaignItemFindManyArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }

  export type CampaignInclude = {
    campaign_type?: boolean | CampaignTypeArgs
    account?: boolean | AccountArgs
    orders?: boolean | OrderFindManyArgs
    campaign_items?: boolean | CampaignItemFindManyArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }

  export type CampaignGetPayload<
    S extends boolean | null | undefined | CampaignArgs,
    U = keyof S
      > = S extends true
        ? Campaign
    : S extends undefined
    ? never
    : S extends CampaignArgs | CampaignFindManyArgs
    ?'include' extends U
    ? Campaign  & {
    [P in TrueKeys<S['include']>]:
        P extends 'campaign_type' ? CampaignTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'campaign_items' ? Array < CampaignItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'campaign_type' ? CampaignTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'campaign_items' ? Array < CampaignItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Campaign ? Campaign[P] : never
  } 
    : Campaign
  : Campaign


  type CampaignCountArgs = Merge<
    Omit<CampaignFindManyArgs, 'select' | 'include'> & {
      select?: CampaignCountAggregateInputType | true
    }
  >

  export interface CampaignDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Campaign'> extends True ? CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>> : CheckSelect<T, Prisma__CampaignClient<Campaign | null, null>, Prisma__CampaignClient<CampaignGetPayload<T> | null, null>>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Campaign'> extends True ? CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>> : CheckSelect<T, Prisma__CampaignClient<Campaign | null, null>, Prisma__CampaignClient<CampaignGetPayload<T> | null, null>>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignFindManyArgs>(
      args?: SelectSubset<T, CampaignFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Campaign>>, PrismaPromise<Array<CampaignGetPayload<T>>>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
    **/
    create<T extends CampaignCreateArgs>(
      args: SelectSubset<T, CampaignCreateArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Create many Campaigns.
     *     @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     *     @example
     *     // Create many Campaigns
     *     const campaign = await prisma.campaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignCreateManyArgs>(
      args?: SelectSubset<T, CampaignCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
    **/
    delete<T extends CampaignDeleteArgs>(
      args: SelectSubset<T, CampaignDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignUpdateArgs>(
      args: SelectSubset<T, CampaignUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignDeleteManyArgs>(
      args?: SelectSubset<T, CampaignDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignUpdateManyArgs>(
      args: SelectSubset<T, CampaignUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignUpsertArgs>(
      args: SelectSubset<T, CampaignUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Find one Campaign that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Find the first Campaign that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    campaign_type<T extends CampaignTypeArgs = {}>(args?: Subset<T, CampaignTypeArgs>): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | Null>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    campaign_items<T extends CampaignItemFindManyArgs = {}>(args?: Subset<T, CampaignItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CampaignItem>| Null>, PrismaPromise<Array<CampaignItemGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Campaign base type for findUnique actions
   */
  export type CampaignFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     * 
    **/
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign: findUnique
   */
  export interface CampaignFindUniqueArgs extends CampaignFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign base type for findFirst actions
   */
  export type CampaignFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     * 
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     * 
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     * 
    **/
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }

  /**
   * Campaign: findFirst
   */
  export interface CampaignFindFirstArgs extends CampaignFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter, which Campaigns to fetch.
     * 
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     * 
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign create
   */
  export type CampaignCreateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * The data needed to create a Campaign.
     * 
    **/
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }


  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs = {
    /**
     * The data used to create many Campaigns.
     * 
    **/
    data: Enumerable<CampaignCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Campaign update
   */
  export type CampaignUpdateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * The data needed to update a Campaign.
     * 
    **/
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     * 
    **/
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs = {
    /**
     * The data used to update Campaigns.
     * 
    **/
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     * 
    **/
    where?: CampaignWhereInput
  }


  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     * 
    **/
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     * 
    **/
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }


  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
    /**
     * Filter which Campaign to delete.
     * 
    **/
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs = {
    /**
     * Filter which Campaigns to delete
     * 
    **/
    where?: CampaignWhereInput
  }


  /**
   * Campaign: findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs = CampaignFindUniqueArgsBase
      

  /**
   * Campaign: findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs = CampaignFindFirstArgsBase
      

  /**
   * Campaign without action
   */
  export type CampaignArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     * 
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignInclude | null
  }



  /**
   * Model CampaignType
   */


  export type AggregateCampaignType = {
    _count: CampaignTypeCountAggregateOutputType | null
    _avg: CampaignTypeAvgAggregateOutputType | null
    _sum: CampaignTypeSumAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  export type CampaignTypeAvgAggregateOutputType = {
    external_id: number | null
  }

  export type CampaignTypeSumAggregateOutputType = {
    external_id: number | null
  }

  export type CampaignTypeMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
  }

  export type CampaignTypeMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
  }

  export type CampaignTypeCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    _all: number
  }


  export type CampaignTypeAvgAggregateInputType = {
    external_id?: true
  }

  export type CampaignTypeSumAggregateInputType = {
    external_id?: true
  }

  export type CampaignTypeMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
  }

  export type CampaignTypeMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
  }

  export type CampaignTypeCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type CampaignTypeAggregateArgs = {
    /**
     * Filter which CampaignType to aggregate.
     * 
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignTypes
    **/
    _count?: true | CampaignTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTypeMaxAggregateInputType
  }

  export type GetCampaignTypeAggregateType<T extends CampaignTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignType[P]>
      : GetScalarType<T[P], AggregateCampaignType[P]>
  }




  export type CampaignTypeGroupByArgs = {
    where?: CampaignTypeWhereInput
    orderBy?: Enumerable<CampaignTypeOrderByWithAggregationInput>
    by: Array<CampaignTypeScalarFieldEnum>
    having?: CampaignTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTypeCountAggregateInputType | true
    _avg?: CampaignTypeAvgAggregateInputType
    _sum?: CampaignTypeSumAggregateInputType
    _min?: CampaignTypeMinAggregateInputType
    _max?: CampaignTypeMaxAggregateInputType
  }


  export type CampaignTypeGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    _count: CampaignTypeCountAggregateOutputType | null
    _avg: CampaignTypeAvgAggregateOutputType | null
    _sum: CampaignTypeSumAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  type GetCampaignTypeGroupByPayload<T extends CampaignTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CampaignTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
        }
      >
    >


  export type CampaignTypeSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    Campaign?: boolean | CampaignFindManyArgs
    _count?: boolean | CampaignTypeCountOutputTypeArgs
  }

  export type CampaignTypeInclude = {
    Campaign?: boolean | CampaignFindManyArgs
    _count?: boolean | CampaignTypeCountOutputTypeArgs
  }

  export type CampaignTypeGetPayload<
    S extends boolean | null | undefined | CampaignTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignType
    : S extends undefined
    ? never
    : S extends CampaignTypeArgs | CampaignTypeFindManyArgs
    ?'include' extends U
    ? CampaignType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Campaign' ? Array < CampaignGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignTypeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Campaign' ? Array < CampaignGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CampaignTypeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof CampaignType ? CampaignType[P] : never
  } 
    : CampaignType
  : CampaignType


  type CampaignTypeCountArgs = Merge<
    Omit<CampaignTypeFindManyArgs, 'select' | 'include'> & {
      select?: CampaignTypeCountAggregateInputType | true
    }
  >

  export interface CampaignTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CampaignType that matches the filter.
     * @param {CampaignTypeFindUniqueArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignType'> extends True ? CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>> : CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null, null>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null, null>>

    /**
     * Find the first CampaignType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindFirstArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignType'> extends True ? CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>> : CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null, null>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null, null>>

    /**
     * Find zero or more CampaignTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany()
     * 
     * // Get first 10 CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignTypeWithIdOnly = await prisma.campaignType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignTypeFindManyArgs>(
      args?: SelectSubset<T, CampaignTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CampaignType>>, PrismaPromise<Array<CampaignTypeGetPayload<T>>>>

    /**
     * Create a CampaignType.
     * @param {CampaignTypeCreateArgs} args - Arguments to create a CampaignType.
     * @example
     * // Create one CampaignType
     * const CampaignType = await prisma.campaignType.create({
     *   data: {
     *     // ... data to create a CampaignType
     *   }
     * })
     * 
    **/
    create<T extends CampaignTypeCreateArgs>(
      args: SelectSubset<T, CampaignTypeCreateArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Create many CampaignTypes.
     *     @param {CampaignTypeCreateManyArgs} args - Arguments to create many CampaignTypes.
     *     @example
     *     // Create many CampaignTypes
     *     const campaignType = await prisma.campaignType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignTypeCreateManyArgs>(
      args?: SelectSubset<T, CampaignTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignType.
     * @param {CampaignTypeDeleteArgs} args - Arguments to delete one CampaignType.
     * @example
     * // Delete one CampaignType
     * const CampaignType = await prisma.campaignType.delete({
     *   where: {
     *     // ... filter to delete one CampaignType
     *   }
     * })
     * 
    **/
    delete<T extends CampaignTypeDeleteArgs>(
      args: SelectSubset<T, CampaignTypeDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Update one CampaignType.
     * @param {CampaignTypeUpdateArgs} args - Arguments to update one CampaignType.
     * @example
     * // Update one CampaignType
     * const campaignType = await prisma.campaignType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignTypeUpdateArgs>(
      args: SelectSubset<T, CampaignTypeUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Delete zero or more CampaignTypes.
     * @param {CampaignTypeDeleteManyArgs} args - Arguments to filter CampaignTypes to delete.
     * @example
     * // Delete a few CampaignTypes
     * const { count } = await prisma.campaignType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignTypeDeleteManyArgs>(
      args?: SelectSubset<T, CampaignTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTypes
     * const campaignType = await prisma.campaignType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignTypeUpdateManyArgs>(
      args: SelectSubset<T, CampaignTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignType.
     * @param {CampaignTypeUpsertArgs} args - Arguments to update or create a CampaignType.
     * @example
     * // Update or create a CampaignType
     * const campaignType = await prisma.campaignType.upsert({
     *   create: {
     *     // ... data to create a CampaignType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignType we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignTypeUpsertArgs>(
      args: SelectSubset<T, CampaignTypeUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Find one CampaignType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CampaignTypeFindUniqueOrThrowArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Find the first CampaignType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindFirstOrThrowArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Count the number of CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeCountArgs} args - Arguments to filter CampaignTypes to count.
     * @example
     * // Count the number of CampaignTypes
     * const count = await prisma.campaignType.count({
     *   where: {
     *     // ... the filter for the CampaignTypes we want to count
     *   }
     * })
    **/
    count<T extends CampaignTypeCountArgs>(
      args?: Subset<T, CampaignTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTypeAggregateArgs>(args: Subset<T, CampaignTypeAggregateArgs>): PrismaPromise<GetCampaignTypeAggregateType<T>>

    /**
     * Group by CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignTypeGroupByArgs['orderBy'] }
        : { orderBy?: CampaignTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTypeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignTypeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Campaign<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>| Null>, PrismaPromise<Array<CampaignGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CampaignType base type for findUnique actions
   */
  export type CampaignTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter, which CampaignType to fetch.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
  }

  /**
   * CampaignType: findUnique
   */
  export interface CampaignTypeFindUniqueArgs extends CampaignTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignType base type for findFirst actions
   */
  export type CampaignTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter, which CampaignType to fetch.
     * 
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTypes.
     * 
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTypes.
     * 
    **/
    distinct?: Enumerable<CampaignTypeScalarFieldEnum>
  }

  /**
   * CampaignType: findFirst
   */
  export interface CampaignTypeFindFirstArgs extends CampaignTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignType findMany
   */
  export type CampaignTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter, which CampaignTypes to fetch.
     * 
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignTypes.
     * 
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CampaignTypeScalarFieldEnum>
  }


  /**
   * CampaignType create
   */
  export type CampaignTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * The data needed to create a CampaignType.
     * 
    **/
    data: XOR<CampaignTypeCreateInput, CampaignTypeUncheckedCreateInput>
  }


  /**
   * CampaignType createMany
   */
  export type CampaignTypeCreateManyArgs = {
    /**
     * The data used to create many CampaignTypes.
     * 
    **/
    data: Enumerable<CampaignTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignType update
   */
  export type CampaignTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * The data needed to update a CampaignType.
     * 
    **/
    data: XOR<CampaignTypeUpdateInput, CampaignTypeUncheckedUpdateInput>
    /**
     * Choose, which CampaignType to update.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
  }


  /**
   * CampaignType updateMany
   */
  export type CampaignTypeUpdateManyArgs = {
    /**
     * The data used to update CampaignTypes.
     * 
    **/
    data: XOR<CampaignTypeUpdateManyMutationInput, CampaignTypeUncheckedUpdateManyInput>
    /**
     * Filter which CampaignTypes to update
     * 
    **/
    where?: CampaignTypeWhereInput
  }


  /**
   * CampaignType upsert
   */
  export type CampaignTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * The filter to search for the CampaignType to update in case it exists.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
    /**
     * In case the CampaignType found by the `where` argument doesn't exist, create a new CampaignType with this data.
     * 
    **/
    create: XOR<CampaignTypeCreateInput, CampaignTypeUncheckedCreateInput>
    /**
     * In case the CampaignType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CampaignTypeUpdateInput, CampaignTypeUncheckedUpdateInput>
  }


  /**
   * CampaignType delete
   */
  export type CampaignTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter which CampaignType to delete.
     * 
    **/
    where: CampaignTypeWhereUniqueInput
  }


  /**
   * CampaignType deleteMany
   */
  export type CampaignTypeDeleteManyArgs = {
    /**
     * Filter which CampaignTypes to delete
     * 
    **/
    where?: CampaignTypeWhereInput
  }


  /**
   * CampaignType: findUniqueOrThrow
   */
  export type CampaignTypeFindUniqueOrThrowArgs = CampaignTypeFindUniqueArgsBase
      

  /**
   * CampaignType: findFirstOrThrow
   */
  export type CampaignTypeFindFirstOrThrowArgs = CampaignTypeFindFirstArgsBase
      

  /**
   * CampaignType without action
   */
  export type CampaignTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     * 
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignTypeInclude | null
  }



  /**
   * Model Coupon
   */


  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    discount_value: number | null
    min_value: number | null
    max_value: number | null
  }

  export type CouponSumAggregateOutputType = {
    discount_value: number | null
    min_value: number | null
    max_value: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    account_id: string | null
    dicount_type: CouponDiscountType | null
    discount_value: number | null
    couponUse_type: CouponUseType | null
    inital_date: Date | null
    expiration_date: Date | null
    min_value: number | null
    max_value: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    account_id: string | null
    dicount_type: CouponDiscountType | null
    discount_value: number | null
    couponUse_type: CouponUseType | null
    inital_date: Date | null
    expiration_date: Date | null
    min_value: number | null
    max_value: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    account_id: number
    dicount_type: number
    discount_value: number
    couponUse_type: number
    inital_date: number
    expiration_date: number
    min_value: number
    max_value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    discount_value?: true
    min_value?: true
    max_value?: true
  }

  export type CouponSumAggregateInputType = {
    discount_value?: true
    min_value?: true
    max_value?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    account_id?: true
    dicount_type?: true
    discount_value?: true
    couponUse_type?: true
    inital_date?: true
    expiration_date?: true
    min_value?: true
    max_value?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    account_id?: true
    dicount_type?: true
    discount_value?: true
    couponUse_type?: true
    inital_date?: true
    expiration_date?: true
    min_value?: true
    max_value?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    account_id?: true
    dicount_type?: true
    discount_value?: true
    couponUse_type?: true
    inital_date?: true
    expiration_date?: true
    min_value?: true
    max_value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CouponAggregateArgs = {
    /**
     * Filter which Coupon to aggregate.
     * 
    **/
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs = {
    where?: CouponWhereInput
    orderBy?: Enumerable<CouponOrderByWithAggregationInput>
    by: Array<CouponScalarFieldEnum>
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }


  export type CouponGroupByOutputType = {
    id: string
    code: string
    account_id: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date: Date
    expiration_date: Date | null
    min_value: number | null
    max_value: number | null
    created_at: Date
    updated_at: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect = {
    id?: boolean
    code?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    dicount_type?: boolean
    discount_value?: boolean
    couponUse_type?: boolean
    inital_date?: boolean
    expiration_date?: boolean
    min_value?: boolean
    max_value?: boolean
    created_at?: boolean
    updated_at?: boolean
    orders?: boolean | OrderFindManyArgs
    _count?: boolean | CouponCountOutputTypeArgs
  }

  export type CouponInclude = {
    account?: boolean | AccountArgs
    orders?: boolean | OrderFindManyArgs
    _count?: boolean | CouponCountOutputTypeArgs
  }

  export type CouponGetPayload<
    S extends boolean | null | undefined | CouponArgs,
    U = keyof S
      > = S extends true
        ? Coupon
    : S extends undefined
    ? never
    : S extends CouponArgs | CouponFindManyArgs
    ?'include' extends U
    ? Coupon  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CouponCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CouponCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Coupon ? Coupon[P] : never
  } 
    : Coupon
  : Coupon


  type CouponCountArgs = Merge<
    Omit<CouponFindManyArgs, 'select' | 'include'> & {
      select?: CouponCountAggregateInputType | true
    }
  >

  export interface CouponDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CouponFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CouponFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Coupon'> extends True ? CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>> : CheckSelect<T, Prisma__CouponClient<Coupon | null, null>, Prisma__CouponClient<CouponGetPayload<T> | null, null>>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CouponFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CouponFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Coupon'> extends True ? CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>> : CheckSelect<T, Prisma__CouponClient<Coupon | null, null>, Prisma__CouponClient<CouponGetPayload<T> | null, null>>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CouponFindManyArgs>(
      args?: SelectSubset<T, CouponFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Coupon>>, PrismaPromise<Array<CouponGetPayload<T>>>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
    **/
    create<T extends CouponCreateArgs>(
      args: SelectSubset<T, CouponCreateArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Create many Coupons.
     *     @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     *     @example
     *     // Create many Coupons
     *     const coupon = await prisma.coupon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CouponCreateManyArgs>(
      args?: SelectSubset<T, CouponCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
    **/
    delete<T extends CouponDeleteArgs>(
      args: SelectSubset<T, CouponDeleteArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CouponUpdateArgs>(
      args: SelectSubset<T, CouponUpdateArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CouponDeleteManyArgs>(
      args?: SelectSubset<T, CouponDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CouponUpdateManyArgs>(
      args: SelectSubset<T, CouponUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
    **/
    upsert<T extends CouponUpsertArgs>(
      args: SelectSubset<T, CouponUpsertArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Find one Coupon that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CouponFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Find the first Coupon that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CouponFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CouponClient<Coupon>, Prisma__CouponClient<CouponGetPayload<T>>>

    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CouponClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Coupon base type for findUnique actions
   */
  export type CouponFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
    /**
     * Filter, which Coupon to fetch.
     * 
    **/
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon: findUnique
   */
  export interface CouponFindUniqueArgs extends CouponFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coupon base type for findFirst actions
   */
  export type CouponFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
    /**
     * Filter, which Coupon to fetch.
     * 
    **/
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     * 
    **/
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     * 
    **/
    distinct?: Enumerable<CouponScalarFieldEnum>
  }

  /**
   * Coupon: findFirst
   */
  export interface CouponFindFirstArgs extends CouponFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
    /**
     * Filter, which Coupons to fetch.
     * 
    **/
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<CouponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     * 
    **/
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CouponScalarFieldEnum>
  }


  /**
   * Coupon create
   */
  export type CouponCreateArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
    /**
     * The data needed to create a Coupon.
     * 
    **/
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }


  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs = {
    /**
     * The data used to create many Coupons.
     * 
    **/
    data: Enumerable<CouponCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Coupon update
   */
  export type CouponUpdateArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
    /**
     * The data needed to update a Coupon.
     * 
    **/
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     * 
    **/
    where: CouponWhereUniqueInput
  }


  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs = {
    /**
     * The data used to update Coupons.
     * 
    **/
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     * 
    **/
    where?: CouponWhereInput
  }


  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     * 
    **/
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     * 
    **/
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }


  /**
   * Coupon delete
   */
  export type CouponDeleteArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
    /**
     * Filter which Coupon to delete.
     * 
    **/
    where: CouponWhereUniqueInput
  }


  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs = {
    /**
     * Filter which Coupons to delete
     * 
    **/
    where?: CouponWhereInput
  }


  /**
   * Coupon: findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs = CouponFindUniqueArgsBase
      

  /**
   * Coupon: findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs = CouponFindFirstArgsBase
      

  /**
   * Coupon without action
   */
  export type CouponArgs = {
    /**
     * Select specific fields to fetch from the Coupon
     * 
    **/
    select?: CouponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CouponInclude | null
  }



  /**
   * Model Item
   */


  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    external_id: number | null
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
  }

  export type ItemSumAggregateOutputType = {
    external_id: number | null
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    type_id: string | null
    country_id: string | null
    region_id: string | null
    winery_id: string | null
    harvest: string | null
    no_harvest: boolean | null
    wine_type_id: string | null
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
    photo: string | null
    account_id: string | null
    is_active: boolean | null
    control_stock: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    type_id: string | null
    country_id: string | null
    region_id: string | null
    winery_id: string | null
    harvest: string | null
    no_harvest: boolean | null
    wine_type_id: string | null
    alcohol_percentage: Decimal | null
    price: number | null
    promotional_price: number | null
    photo: string | null
    account_id: string | null
    is_active: boolean | null
    control_stock: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    description: number
    type_id: number
    country_id: number
    region_id: number
    winery_id: number
    harvest: number
    no_harvest: number
    wine_type_id: number
    alcohol_percentage: number
    price: number
    promotional_price: number
    photo: number
    account_id: number
    is_active: number
    control_stock: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    external_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
  }

  export type ItemSumAggregateInputType = {
    external_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    type_id?: true
    country_id?: true
    region_id?: true
    winery_id?: true
    harvest?: true
    no_harvest?: true
    wine_type_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
    photo?: true
    account_id?: true
    is_active?: true
    control_stock?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    type_id?: true
    country_id?: true
    region_id?: true
    winery_id?: true
    harvest?: true
    no_harvest?: true
    wine_type_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
    photo?: true
    account_id?: true
    is_active?: true
    control_stock?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    type_id?: true
    country_id?: true
    region_id?: true
    winery_id?: true
    harvest?: true
    no_harvest?: true
    wine_type_id?: true
    alcohol_percentage?: true
    price?: true
    promotional_price?: true
    photo?: true
    account_id?: true
    is_active?: true
    control_stock?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ItemAggregateArgs = {
    /**
     * Filter which Item to aggregate.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs = {
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithAggregationInput>
    by: Array<ItemScalarFieldEnum>
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }


  export type ItemGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    description: string | null
    type_id: string
    country_id: string | null
    region_id: string | null
    winery_id: string | null
    harvest: string | null
    no_harvest: boolean
    wine_type_id: string | null
    alcohol_percentage: Decimal | null
    price: number
    promotional_price: number | null
    photo: string | null
    account_id: string
    is_active: boolean
    control_stock: boolean
    created_at: Date
    updated_at: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    item_type?: boolean | ItemTypeArgs
    country_id?: boolean
    country?: boolean | CountryArgs
    region_id?: boolean
    region?: boolean | RegionArgs
    winery_id?: boolean
    winery?: boolean | WineryArgs
    harvest?: boolean
    no_harvest?: boolean
    wine_type_id?: boolean
    wine_type?: boolean | WineTypeArgs
    alcohol_percentage?: boolean
    price?: boolean
    promotional_price?: boolean
    photo?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    is_active?: boolean
    control_stock?: boolean
    created_at?: boolean
    updated_at?: boolean
    item_grape?: boolean | ItemGrapeFindManyArgs
    order_items?: boolean | OrderItemFindManyArgs
    campaign_items?: boolean | CampaignItemFindManyArgs
    stock_items?: boolean | StockItemFindManyArgs
    stock_history?: boolean | StockHistoryFindManyArgs
    ItemTag?: boolean | ItemTagFindManyArgs
    _count?: boolean | ItemCountOutputTypeArgs
  }

  export type ItemInclude = {
    item_type?: boolean | ItemTypeArgs
    country?: boolean | CountryArgs
    region?: boolean | RegionArgs
    winery?: boolean | WineryArgs
    wine_type?: boolean | WineTypeArgs
    account?: boolean | AccountArgs
    item_grape?: boolean | ItemGrapeFindManyArgs
    order_items?: boolean | OrderItemFindManyArgs
    campaign_items?: boolean | CampaignItemFindManyArgs
    stock_items?: boolean | StockItemFindManyArgs
    stock_history?: boolean | StockHistoryFindManyArgs
    ItemTag?: boolean | ItemTagFindManyArgs
    _count?: boolean | ItemCountOutputTypeArgs
  }

  export type ItemGetPayload<
    S extends boolean | null | undefined | ItemArgs,
    U = keyof S
      > = S extends true
        ? Item
    : S extends undefined
    ? never
    : S extends ItemArgs | ItemFindManyArgs
    ?'include' extends U
    ? Item  & {
    [P in TrueKeys<S['include']>]:
        P extends 'item_type' ? ItemTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'country' ? CountryGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'region' ? RegionGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'winery' ? WineryGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'wine_type' ? WineTypeGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'item_grape' ? Array < ItemGrapeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'order_items' ? Array < OrderItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'campaign_items' ? Array < CampaignItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'stock_items' ? Array < StockItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'stock_history' ? Array < StockHistoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ItemTag' ? Array < ItemTagGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ItemCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'item_type' ? ItemTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'country' ? CountryGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'region' ? RegionGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'winery' ? WineryGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'wine_type' ? WineTypeGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'item_grape' ? Array < ItemGrapeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'order_items' ? Array < OrderItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'campaign_items' ? Array < CampaignItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'stock_items' ? Array < StockItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'stock_history' ? Array < StockHistoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ItemTag' ? Array < ItemTagGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ItemCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Item ? Item[P] : never
  } 
    : Item
  : Item


  type ItemCountArgs = Merge<
    Omit<ItemFindManyArgs, 'select' | 'include'> & {
      select?: ItemCountAggregateInputType | true
    }
  >

  export interface ItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Item'> extends True ? CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>> : CheckSelect<T, Prisma__ItemClient<Item | null, null>, Prisma__ItemClient<ItemGetPayload<T> | null, null>>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Item'> extends True ? CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>> : CheckSelect<T, Prisma__ItemClient<Item | null, null>, Prisma__ItemClient<ItemGetPayload<T> | null, null>>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs>(
      args?: SelectSubset<T, ItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs>(
      args: SelectSubset<T, ItemCreateArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs>(
      args?: SelectSubset<T, ItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs>(
      args: SelectSubset<T, ItemDeleteArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs>(
      args: SelectSubset<T, ItemUpdateArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs>(
      args?: SelectSubset<T, ItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs>(
      args: SelectSubset<T, ItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs>(
      args: SelectSubset<T, ItemUpsertArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Find one Item that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ItemFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Find the first Item that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    item_type<T extends ItemTypeArgs = {}>(args?: Subset<T, ItemTypeArgs>): CheckSelect<T, Prisma__ItemTypeClient<ItemType | Null>, Prisma__ItemTypeClient<ItemTypeGetPayload<T> | Null>>;

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | Null>, Prisma__CountryClient<CountryGetPayload<T> | Null>>;

    region<T extends RegionArgs = {}>(args?: Subset<T, RegionArgs>): CheckSelect<T, Prisma__RegionClient<Region | Null>, Prisma__RegionClient<RegionGetPayload<T> | Null>>;

    winery<T extends WineryArgs = {}>(args?: Subset<T, WineryArgs>): CheckSelect<T, Prisma__WineryClient<Winery | Null>, Prisma__WineryClient<WineryGetPayload<T> | Null>>;

    wine_type<T extends WineTypeArgs = {}>(args?: Subset<T, WineTypeArgs>): CheckSelect<T, Prisma__WineTypeClient<WineType | Null>, Prisma__WineTypeClient<WineTypeGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    item_grape<T extends ItemGrapeFindManyArgs = {}>(args?: Subset<T, ItemGrapeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ItemGrape>| Null>, PrismaPromise<Array<ItemGrapeGetPayload<T>>| Null>>;

    order_items<T extends OrderItemFindManyArgs = {}>(args?: Subset<T, OrderItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderItem>| Null>, PrismaPromise<Array<OrderItemGetPayload<T>>| Null>>;

    campaign_items<T extends CampaignItemFindManyArgs = {}>(args?: Subset<T, CampaignItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CampaignItem>| Null>, PrismaPromise<Array<CampaignItemGetPayload<T>>| Null>>;

    stock_items<T extends StockItemFindManyArgs = {}>(args?: Subset<T, StockItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StockItem>| Null>, PrismaPromise<Array<StockItemGetPayload<T>>| Null>>;

    stock_history<T extends StockHistoryFindManyArgs = {}>(args?: Subset<T, StockHistoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StockHistory>| Null>, PrismaPromise<Array<StockHistoryGetPayload<T>>| Null>>;

    ItemTag<T extends ItemTagFindManyArgs = {}>(args?: Subset<T, ItemTagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ItemTag>| Null>, PrismaPromise<Array<ItemTagGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Item base type for findUnique actions
   */
  export type ItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter, which Item to fetch.
     * 
    **/
    where: ItemWhereUniqueInput
  }

  /**
   * Item: findUnique
   */
  export interface ItemFindUniqueArgs extends ItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Item base type for findFirst actions
   */
  export type ItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter, which Item to fetch.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     * 
    **/
    distinct?: Enumerable<ItemScalarFieldEnum>
  }

  /**
   * Item: findFirst
   */
  export interface ItemFindFirstArgs extends ItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Item findMany
   */
  export type ItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter, which Items to fetch.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item create
   */
  export type ItemCreateArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The data needed to create a Item.
     * 
    **/
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs = {
    /**
     * The data used to create many Items.
     * 
    **/
    data: Enumerable<ItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The data needed to update a Item.
     * 
    **/
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs = {
    /**
     * The data used to update Items.
     * 
    **/
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     * 
    **/
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The filter to search for the Item to update in case it exists.
     * 
    **/
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     * 
    **/
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter which Item to delete.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs = {
    /**
     * Filter which Items to delete
     * 
    **/
    where?: ItemWhereInput
  }


  /**
   * Item: findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs = ItemFindUniqueArgsBase
      

  /**
   * Item: findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs = ItemFindFirstArgsBase
      

  /**
   * Item without action
   */
  export type ItemArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
  }



  /**
   * Model ItemType
   */


  export type AggregateItemType = {
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  export type ItemTypeAvgAggregateOutputType = {
    external_id: number | null
  }

  export type ItemTypeSumAggregateOutputType = {
    external_id: number | null
  }

  export type ItemTypeMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemTypeMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemTypeCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ItemTypeAvgAggregateInputType = {
    external_id?: true
  }

  export type ItemTypeSumAggregateInputType = {
    external_id?: true
  }

  export type ItemTypeMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemTypeMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemTypeCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ItemTypeAggregateArgs = {
    /**
     * Filter which ItemType to aggregate.
     * 
    **/
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTypes
    **/
    _count?: true | ItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTypeMaxAggregateInputType
  }

  export type GetItemTypeAggregateType<T extends ItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemType[P]>
      : GetScalarType<T[P], AggregateItemType[P]>
  }




  export type ItemTypeGroupByArgs = {
    where?: ItemTypeWhereInput
    orderBy?: Enumerable<ItemTypeOrderByWithAggregationInput>
    by: Array<ItemTypeScalarFieldEnum>
    having?: ItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTypeCountAggregateInputType | true
    _avg?: ItemTypeAvgAggregateInputType
    _sum?: ItemTypeSumAggregateInputType
    _min?: ItemTypeMinAggregateInputType
    _max?: ItemTypeMaxAggregateInputType
  }


  export type ItemTypeGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  type GetItemTypeGroupByPayload<T extends ItemTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type ItemTypeSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    items?: boolean | ItemFindManyArgs
    _count?: boolean | ItemTypeCountOutputTypeArgs
  }

  export type ItemTypeInclude = {
    items?: boolean | ItemFindManyArgs
    _count?: boolean | ItemTypeCountOutputTypeArgs
  }

  export type ItemTypeGetPayload<
    S extends boolean | null | undefined | ItemTypeArgs,
    U = keyof S
      > = S extends true
        ? ItemType
    : S extends undefined
    ? never
    : S extends ItemTypeArgs | ItemTypeFindManyArgs
    ?'include' extends U
    ? ItemType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ItemTypeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ItemTypeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ItemType ? ItemType[P] : never
  } 
    : ItemType
  : ItemType


  type ItemTypeCountArgs = Merge<
    Omit<ItemTypeFindManyArgs, 'select' | 'include'> & {
      select?: ItemTypeCountAggregateInputType | true
    }
  >

  export interface ItemTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ItemType that matches the filter.
     * @param {ItemTypeFindUniqueArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ItemType'> extends True ? CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>> : CheckSelect<T, Prisma__ItemTypeClient<ItemType | null, null>, Prisma__ItemTypeClient<ItemTypeGetPayload<T> | null, null>>

    /**
     * Find the first ItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ItemType'> extends True ? CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>> : CheckSelect<T, Prisma__ItemTypeClient<ItemType | null, null>, Prisma__ItemTypeClient<ItemTypeGetPayload<T> | null, null>>

    /**
     * Find zero or more ItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTypes
     * const itemTypes = await prisma.itemType.findMany()
     * 
     * // Get first 10 ItemTypes
     * const itemTypes = await prisma.itemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemTypeFindManyArgs>(
      args?: SelectSubset<T, ItemTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ItemType>>, PrismaPromise<Array<ItemTypeGetPayload<T>>>>

    /**
     * Create a ItemType.
     * @param {ItemTypeCreateArgs} args - Arguments to create a ItemType.
     * @example
     * // Create one ItemType
     * const ItemType = await prisma.itemType.create({
     *   data: {
     *     // ... data to create a ItemType
     *   }
     * })
     * 
    **/
    create<T extends ItemTypeCreateArgs>(
      args: SelectSubset<T, ItemTypeCreateArgs>
    ): CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>>

    /**
     * Create many ItemTypes.
     *     @param {ItemTypeCreateManyArgs} args - Arguments to create many ItemTypes.
     *     @example
     *     // Create many ItemTypes
     *     const itemType = await prisma.itemType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemTypeCreateManyArgs>(
      args?: SelectSubset<T, ItemTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ItemType.
     * @param {ItemTypeDeleteArgs} args - Arguments to delete one ItemType.
     * @example
     * // Delete one ItemType
     * const ItemType = await prisma.itemType.delete({
     *   where: {
     *     // ... filter to delete one ItemType
     *   }
     * })
     * 
    **/
    delete<T extends ItemTypeDeleteArgs>(
      args: SelectSubset<T, ItemTypeDeleteArgs>
    ): CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>>

    /**
     * Update one ItemType.
     * @param {ItemTypeUpdateArgs} args - Arguments to update one ItemType.
     * @example
     * // Update one ItemType
     * const itemType = await prisma.itemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemTypeUpdateArgs>(
      args: SelectSubset<T, ItemTypeUpdateArgs>
    ): CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>>

    /**
     * Delete zero or more ItemTypes.
     * @param {ItemTypeDeleteManyArgs} args - Arguments to filter ItemTypes to delete.
     * @example
     * // Delete a few ItemTypes
     * const { count } = await prisma.itemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemTypeDeleteManyArgs>(
      args?: SelectSubset<T, ItemTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemTypeUpdateManyArgs>(
      args: SelectSubset<T, ItemTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemType.
     * @param {ItemTypeUpsertArgs} args - Arguments to update or create a ItemType.
     * @example
     * // Update or create a ItemType
     * const itemType = await prisma.itemType.upsert({
     *   create: {
     *     // ... data to create a ItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemType we want to update
     *   }
     * })
    **/
    upsert<T extends ItemTypeUpsertArgs>(
      args: SelectSubset<T, ItemTypeUpsertArgs>
    ): CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>>

    /**
     * Find one ItemType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ItemTypeFindUniqueOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ItemTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>>

    /**
     * Find the first ItemType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemTypeClient<ItemType>, Prisma__ItemTypeClient<ItemTypeGetPayload<T>>>

    /**
     * Count the number of ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeCountArgs} args - Arguments to filter ItemTypes to count.
     * @example
     * // Count the number of ItemTypes
     * const count = await prisma.itemType.count({
     *   where: {
     *     // ... the filter for the ItemTypes we want to count
     *   }
     * })
    **/
    count<T extends ItemTypeCountArgs>(
      args?: Subset<T, ItemTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTypeAggregateArgs>(args: Subset<T, ItemTypeAggregateArgs>): PrismaPromise<GetItemTypeAggregateType<T>>

    /**
     * Group by ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: ItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTypeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemTypeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>| Null>, PrismaPromise<Array<ItemGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ItemType base type for findUnique actions
   */
  export type ItemTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
    /**
     * Filter, which ItemType to fetch.
     * 
    **/
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType: findUnique
   */
  export interface ItemTypeFindUniqueArgs extends ItemTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemType base type for findFirst actions
   */
  export type ItemTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
    /**
     * Filter, which ItemType to fetch.
     * 
    **/
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     * 
    **/
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     * 
    **/
    distinct?: Enumerable<ItemTypeScalarFieldEnum>
  }

  /**
   * ItemType: findFirst
   */
  export interface ItemTypeFindFirstArgs extends ItemTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemType findMany
   */
  export type ItemTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
    /**
     * Filter, which ItemTypes to fetch.
     * 
    **/
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTypes.
     * 
    **/
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ItemTypeScalarFieldEnum>
  }


  /**
   * ItemType create
   */
  export type ItemTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
    /**
     * The data needed to create a ItemType.
     * 
    **/
    data: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
  }


  /**
   * ItemType createMany
   */
  export type ItemTypeCreateManyArgs = {
    /**
     * The data used to create many ItemTypes.
     * 
    **/
    data: Enumerable<ItemTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ItemType update
   */
  export type ItemTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
    /**
     * The data needed to update a ItemType.
     * 
    **/
    data: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
    /**
     * Choose, which ItemType to update.
     * 
    **/
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType updateMany
   */
  export type ItemTypeUpdateManyArgs = {
    /**
     * The data used to update ItemTypes.
     * 
    **/
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     * 
    **/
    where?: ItemTypeWhereInput
  }


  /**
   * ItemType upsert
   */
  export type ItemTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
    /**
     * The filter to search for the ItemType to update in case it exists.
     * 
    **/
    where: ItemTypeWhereUniqueInput
    /**
     * In case the ItemType found by the `where` argument doesn't exist, create a new ItemType with this data.
     * 
    **/
    create: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
    /**
     * In case the ItemType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
  }


  /**
   * ItemType delete
   */
  export type ItemTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
    /**
     * Filter which ItemType to delete.
     * 
    **/
    where: ItemTypeWhereUniqueInput
  }


  /**
   * ItemType deleteMany
   */
  export type ItemTypeDeleteManyArgs = {
    /**
     * Filter which ItemTypes to delete
     * 
    **/
    where?: ItemTypeWhereInput
  }


  /**
   * ItemType: findUniqueOrThrow
   */
  export type ItemTypeFindUniqueOrThrowArgs = ItemTypeFindUniqueArgsBase
      

  /**
   * ItemType: findFirstOrThrow
   */
  export type ItemTypeFindFirstOrThrowArgs = ItemTypeFindFirstArgsBase
      

  /**
   * ItemType without action
   */
  export type ItemTypeArgs = {
    /**
     * Select specific fields to fetch from the ItemType
     * 
    **/
    select?: ItemTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTypeInclude | null
  }



  /**
   * Model Tag
   */


  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TagAggregateArgs = {
    /**
     * Filter which Tag to aggregate.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs = {
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithAggregationInput>
    by: Array<TagScalarFieldEnum>
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }


  export type TagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    ItemTag?: boolean | ItemTagFindManyArgs
    _count?: boolean | TagCountOutputTypeArgs
  }

  export type TagInclude = {
    ItemTag?: boolean | ItemTagFindManyArgs
    _count?: boolean | TagCountOutputTypeArgs
  }

  export type TagGetPayload<
    S extends boolean | null | undefined | TagArgs,
    U = keyof S
      > = S extends true
        ? Tag
    : S extends undefined
    ? never
    : S extends TagArgs | TagFindManyArgs
    ?'include' extends U
    ? Tag  & {
    [P in TrueKeys<S['include']>]:
        P extends 'ItemTag' ? Array < ItemTagGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TagCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'ItemTag' ? Array < ItemTagGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TagCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Tag ? Tag[P] : never
  } 
    : Tag
  : Tag


  type TagCountArgs = Merge<
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }
  >

  export interface TagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null, null>, Prisma__TagClient<TagGetPayload<T> | null, null>>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null, null>, Prisma__TagClient<TagGetPayload<T> | null, null>>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tag>>, PrismaPromise<Array<TagGetPayload<T>>>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Find one Tag that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Find the first Tag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ItemTag<T extends ItemTagFindManyArgs = {}>(args?: Subset<T, ItemTagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ItemTag>| Null>, PrismaPromise<Array<ItemTagGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tag base type for findUnique actions
   */
  export type TagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where: TagWhereUniqueInput
  }

  /**
   * Tag: findUnique
   */
  export interface TagFindUniqueArgs extends TagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag base type for findFirst actions
   */
  export type TagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     * 
    **/
    distinct?: Enumerable<TagScalarFieldEnum>
  }

  /**
   * Tag: findFirst
   */
  export interface TagFindFirstArgs extends TagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tag findMany
   */
  export type TagFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag create
   */
  export type TagCreateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The data needed to create a Tag.
     * 
    **/
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs = {
    /**
     * The data used to create many Tags.
     * 
    **/
    data: Enumerable<TagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The data needed to update a Tag.
     * 
    **/
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs = {
    /**
     * The data used to update Tags.
     * 
    **/
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     * 
    **/
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The filter to search for the Tag to update in case it exists.
     * 
    **/
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     * 
    **/
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter which Tag to delete.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs = {
    /**
     * Filter which Tags to delete
     * 
    **/
    where?: TagWhereInput
  }


  /**
   * Tag: findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs = TagFindUniqueArgsBase
      

  /**
   * Tag: findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs = TagFindFirstArgsBase
      

  /**
   * Tag without action
   */
  export type TagArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
  }



  /**
   * Model ItemTag
   */


  export type AggregateItemTag = {
    _count: ItemTagCountAggregateOutputType | null
    _min: ItemTagMinAggregateOutputType | null
    _max: ItemTagMaxAggregateOutputType | null
  }

  export type ItemTagMinAggregateOutputType = {
    item_id: string | null
    tag_id: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemTagMaxAggregateOutputType = {
    item_id: string | null
    tag_id: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemTagCountAggregateOutputType = {
    item_id: number
    tag_id: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ItemTagMinAggregateInputType = {
    item_id?: true
    tag_id?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemTagMaxAggregateInputType = {
    item_id?: true
    tag_id?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemTagCountAggregateInputType = {
    item_id?: true
    tag_id?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ItemTagAggregateArgs = {
    /**
     * Filter which ItemTag to aggregate.
     * 
    **/
    where?: ItemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTags to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ItemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTags
    **/
    _count?: true | ItemTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTagMaxAggregateInputType
  }

  export type GetItemTagAggregateType<T extends ItemTagAggregateArgs> = {
        [P in keyof T & keyof AggregateItemTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemTag[P]>
      : GetScalarType<T[P], AggregateItemTag[P]>
  }




  export type ItemTagGroupByArgs = {
    where?: ItemTagWhereInput
    orderBy?: Enumerable<ItemTagOrderByWithAggregationInput>
    by: Array<ItemTagScalarFieldEnum>
    having?: ItemTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTagCountAggregateInputType | true
    _min?: ItemTagMinAggregateInputType
    _max?: ItemTagMaxAggregateInputType
  }


  export type ItemTagGroupByOutputType = {
    item_id: string
    tag_id: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: ItemTagCountAggregateOutputType | null
    _min: ItemTagMinAggregateOutputType | null
    _max: ItemTagMaxAggregateOutputType | null
  }

  type GetItemTagGroupByPayload<T extends ItemTagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ItemTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTagGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTagGroupByOutputType[P]>
        }
      >
    >


  export type ItemTagSelect = {
    item_id?: boolean
    item?: boolean | ItemArgs
    tag_id?: boolean
    tag?: boolean | TagArgs
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ItemTagInclude = {
    item?: boolean | ItemArgs
    tag?: boolean | TagArgs
  }

  export type ItemTagGetPayload<
    S extends boolean | null | undefined | ItemTagArgs,
    U = keyof S
      > = S extends true
        ? ItemTag
    : S extends undefined
    ? never
    : S extends ItemTagArgs | ItemTagFindManyArgs
    ?'include' extends U
    ? ItemTag  & {
    [P in TrueKeys<S['include']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'tag' ? TagGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'tag' ? TagGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ItemTag ? ItemTag[P] : never
  } 
    : ItemTag
  : ItemTag


  type ItemTagCountArgs = Merge<
    Omit<ItemTagFindManyArgs, 'select' | 'include'> & {
      select?: ItemTagCountAggregateInputType | true
    }
  >

  export interface ItemTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ItemTag that matches the filter.
     * @param {ItemTagFindUniqueArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ItemTag'> extends True ? CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>> : CheckSelect<T, Prisma__ItemTagClient<ItemTag | null, null>, Prisma__ItemTagClient<ItemTagGetPayload<T> | null, null>>

    /**
     * Find the first ItemTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagFindFirstArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ItemTag'> extends True ? CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>> : CheckSelect<T, Prisma__ItemTagClient<ItemTag | null, null>, Prisma__ItemTagClient<ItemTagGetPayload<T> | null, null>>

    /**
     * Find zero or more ItemTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTags
     * const itemTags = await prisma.itemTag.findMany()
     * 
     * // Get first 10 ItemTags
     * const itemTags = await prisma.itemTag.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const itemTagWithItem_idOnly = await prisma.itemTag.findMany({ select: { item_id: true } })
     * 
    **/
    findMany<T extends ItemTagFindManyArgs>(
      args?: SelectSubset<T, ItemTagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ItemTag>>, PrismaPromise<Array<ItemTagGetPayload<T>>>>

    /**
     * Create a ItemTag.
     * @param {ItemTagCreateArgs} args - Arguments to create a ItemTag.
     * @example
     * // Create one ItemTag
     * const ItemTag = await prisma.itemTag.create({
     *   data: {
     *     // ... data to create a ItemTag
     *   }
     * })
     * 
    **/
    create<T extends ItemTagCreateArgs>(
      args: SelectSubset<T, ItemTagCreateArgs>
    ): CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>>

    /**
     * Create many ItemTags.
     *     @param {ItemTagCreateManyArgs} args - Arguments to create many ItemTags.
     *     @example
     *     // Create many ItemTags
     *     const itemTag = await prisma.itemTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemTagCreateManyArgs>(
      args?: SelectSubset<T, ItemTagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ItemTag.
     * @param {ItemTagDeleteArgs} args - Arguments to delete one ItemTag.
     * @example
     * // Delete one ItemTag
     * const ItemTag = await prisma.itemTag.delete({
     *   where: {
     *     // ... filter to delete one ItemTag
     *   }
     * })
     * 
    **/
    delete<T extends ItemTagDeleteArgs>(
      args: SelectSubset<T, ItemTagDeleteArgs>
    ): CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>>

    /**
     * Update one ItemTag.
     * @param {ItemTagUpdateArgs} args - Arguments to update one ItemTag.
     * @example
     * // Update one ItemTag
     * const itemTag = await prisma.itemTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemTagUpdateArgs>(
      args: SelectSubset<T, ItemTagUpdateArgs>
    ): CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>>

    /**
     * Delete zero or more ItemTags.
     * @param {ItemTagDeleteManyArgs} args - Arguments to filter ItemTags to delete.
     * @example
     * // Delete a few ItemTags
     * const { count } = await prisma.itemTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemTagDeleteManyArgs>(
      args?: SelectSubset<T, ItemTagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTags
     * const itemTag = await prisma.itemTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemTagUpdateManyArgs>(
      args: SelectSubset<T, ItemTagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemTag.
     * @param {ItemTagUpsertArgs} args - Arguments to update or create a ItemTag.
     * @example
     * // Update or create a ItemTag
     * const itemTag = await prisma.itemTag.upsert({
     *   create: {
     *     // ... data to create a ItemTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemTag we want to update
     *   }
     * })
    **/
    upsert<T extends ItemTagUpsertArgs>(
      args: SelectSubset<T, ItemTagUpsertArgs>
    ): CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>>

    /**
     * Find one ItemTag that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ItemTagFindUniqueOrThrowArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ItemTagFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>>

    /**
     * Find the first ItemTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagFindFirstOrThrowArgs} args - Arguments to find a ItemTag
     * @example
     * // Get one ItemTag
     * const itemTag = await prisma.itemTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemTagFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemTagClient<ItemTag>, Prisma__ItemTagClient<ItemTagGetPayload<T>>>

    /**
     * Count the number of ItemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagCountArgs} args - Arguments to filter ItemTags to count.
     * @example
     * // Count the number of ItemTags
     * const count = await prisma.itemTag.count({
     *   where: {
     *     // ... the filter for the ItemTags we want to count
     *   }
     * })
    **/
    count<T extends ItemTagCountArgs>(
      args?: Subset<T, ItemTagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTagAggregateArgs>(args: Subset<T, ItemTagAggregateArgs>): PrismaPromise<GetItemTagAggregateType<T>>

    /**
     * Group by ItemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTagGroupByArgs['orderBy'] }
        : { orderBy?: ItemTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTagGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemTagClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    item<T extends ItemArgs = {}>(args?: Subset<T, ItemArgs>): CheckSelect<T, Prisma__ItemClient<Item | Null>, Prisma__ItemClient<ItemGetPayload<T> | Null>>;

    tag<T extends TagArgs = {}>(args?: Subset<T, TagArgs>): CheckSelect<T, Prisma__TagClient<Tag | Null>, Prisma__TagClient<TagGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ItemTag base type for findUnique actions
   */
  export type ItemTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
    /**
     * Filter, which ItemTag to fetch.
     * 
    **/
    where: ItemTagWhereUniqueInput
  }

  /**
   * ItemTag: findUnique
   */
  export interface ItemTagFindUniqueArgs extends ItemTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemTag base type for findFirst actions
   */
  export type ItemTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
    /**
     * Filter, which ItemTag to fetch.
     * 
    **/
    where?: ItemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTags to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTags.
     * 
    **/
    cursor?: ItemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTags.
     * 
    **/
    distinct?: Enumerable<ItemTagScalarFieldEnum>
  }

  /**
   * ItemTag: findFirst
   */
  export interface ItemTagFindFirstArgs extends ItemTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemTag findMany
   */
  export type ItemTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
    /**
     * Filter, which ItemTags to fetch.
     * 
    **/
    where?: ItemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTags to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTags.
     * 
    **/
    cursor?: ItemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ItemTagScalarFieldEnum>
  }


  /**
   * ItemTag create
   */
  export type ItemTagCreateArgs = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
    /**
     * The data needed to create a ItemTag.
     * 
    **/
    data: XOR<ItemTagCreateInput, ItemTagUncheckedCreateInput>
  }


  /**
   * ItemTag createMany
   */
  export type ItemTagCreateManyArgs = {
    /**
     * The data used to create many ItemTags.
     * 
    **/
    data: Enumerable<ItemTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ItemTag update
   */
  export type ItemTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
    /**
     * The data needed to update a ItemTag.
     * 
    **/
    data: XOR<ItemTagUpdateInput, ItemTagUncheckedUpdateInput>
    /**
     * Choose, which ItemTag to update.
     * 
    **/
    where: ItemTagWhereUniqueInput
  }


  /**
   * ItemTag updateMany
   */
  export type ItemTagUpdateManyArgs = {
    /**
     * The data used to update ItemTags.
     * 
    **/
    data: XOR<ItemTagUpdateManyMutationInput, ItemTagUncheckedUpdateManyInput>
    /**
     * Filter which ItemTags to update
     * 
    **/
    where?: ItemTagWhereInput
  }


  /**
   * ItemTag upsert
   */
  export type ItemTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
    /**
     * The filter to search for the ItemTag to update in case it exists.
     * 
    **/
    where: ItemTagWhereUniqueInput
    /**
     * In case the ItemTag found by the `where` argument doesn't exist, create a new ItemTag with this data.
     * 
    **/
    create: XOR<ItemTagCreateInput, ItemTagUncheckedCreateInput>
    /**
     * In case the ItemTag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ItemTagUpdateInput, ItemTagUncheckedUpdateInput>
  }


  /**
   * ItemTag delete
   */
  export type ItemTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
    /**
     * Filter which ItemTag to delete.
     * 
    **/
    where: ItemTagWhereUniqueInput
  }


  /**
   * ItemTag deleteMany
   */
  export type ItemTagDeleteManyArgs = {
    /**
     * Filter which ItemTags to delete
     * 
    **/
    where?: ItemTagWhereInput
  }


  /**
   * ItemTag: findUniqueOrThrow
   */
  export type ItemTagFindUniqueOrThrowArgs = ItemTagFindUniqueArgsBase
      

  /**
   * ItemTag: findFirstOrThrow
   */
  export type ItemTagFindFirstOrThrowArgs = ItemTagFindFirstArgsBase
      

  /**
   * ItemTag without action
   */
  export type ItemTagArgs = {
    /**
     * Select specific fields to fetch from the ItemTag
     * 
    **/
    select?: ItemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemTagInclude | null
  }



  /**
   * Model CampaignItem
   */


  export type AggregateCampaignItem = {
    _count: CampaignItemCountAggregateOutputType | null
    _min: CampaignItemMinAggregateOutputType | null
    _max: CampaignItemMaxAggregateOutputType | null
  }

  export type CampaignItemMinAggregateOutputType = {
    item_id: string | null
    campaign_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CampaignItemMaxAggregateOutputType = {
    item_id: string | null
    campaign_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CampaignItemCountAggregateOutputType = {
    item_id: number
    campaign_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CampaignItemMinAggregateInputType = {
    item_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CampaignItemMaxAggregateInputType = {
    item_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CampaignItemCountAggregateInputType = {
    item_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CampaignItemAggregateArgs = {
    /**
     * Filter which CampaignItem to aggregate.
     * 
    **/
    where?: CampaignItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CampaignItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignItems
    **/
    _count?: true | CampaignItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignItemMaxAggregateInputType
  }

  export type GetCampaignItemAggregateType<T extends CampaignItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignItem[P]>
      : GetScalarType<T[P], AggregateCampaignItem[P]>
  }




  export type CampaignItemGroupByArgs = {
    where?: CampaignItemWhereInput
    orderBy?: Enumerable<CampaignItemOrderByWithAggregationInput>
    by: Array<CampaignItemScalarFieldEnum>
    having?: CampaignItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignItemCountAggregateInputType | true
    _min?: CampaignItemMinAggregateInputType
    _max?: CampaignItemMaxAggregateInputType
  }


  export type CampaignItemGroupByOutputType = {
    item_id: string
    campaign_id: string
    created_at: Date
    updated_at: Date
    _count: CampaignItemCountAggregateOutputType | null
    _min: CampaignItemMinAggregateOutputType | null
    _max: CampaignItemMaxAggregateOutputType | null
  }

  type GetCampaignItemGroupByPayload<T extends CampaignItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CampaignItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignItemGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignItemGroupByOutputType[P]>
        }
      >
    >


  export type CampaignItemSelect = {
    item_id?: boolean
    item?: boolean | ItemArgs
    campaign_id?: boolean
    campaign?: boolean | CampaignArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type CampaignItemInclude = {
    item?: boolean | ItemArgs
    campaign?: boolean | CampaignArgs
  }

  export type CampaignItemGetPayload<
    S extends boolean | null | undefined | CampaignItemArgs,
    U = keyof S
      > = S extends true
        ? CampaignItem
    : S extends undefined
    ? never
    : S extends CampaignItemArgs | CampaignItemFindManyArgs
    ?'include' extends U
    ? CampaignItem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'campaign' ? CampaignGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'campaign' ? CampaignGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof CampaignItem ? CampaignItem[P] : never
  } 
    : CampaignItem
  : CampaignItem


  type CampaignItemCountArgs = Merge<
    Omit<CampaignItemFindManyArgs, 'select' | 'include'> & {
      select?: CampaignItemCountAggregateInputType | true
    }
  >

  export interface CampaignItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CampaignItem that matches the filter.
     * @param {CampaignItemFindUniqueArgs} args - Arguments to find a CampaignItem
     * @example
     * // Get one CampaignItem
     * const campaignItem = await prisma.campaignItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignItem'> extends True ? CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>> : CheckSelect<T, Prisma__CampaignItemClient<CampaignItem | null, null>, Prisma__CampaignItemClient<CampaignItemGetPayload<T> | null, null>>

    /**
     * Find the first CampaignItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignItemFindFirstArgs} args - Arguments to find a CampaignItem
     * @example
     * // Get one CampaignItem
     * const campaignItem = await prisma.campaignItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignItem'> extends True ? CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>> : CheckSelect<T, Prisma__CampaignItemClient<CampaignItem | null, null>, Prisma__CampaignItemClient<CampaignItemGetPayload<T> | null, null>>

    /**
     * Find zero or more CampaignItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignItems
     * const campaignItems = await prisma.campaignItem.findMany()
     * 
     * // Get first 10 CampaignItems
     * const campaignItems = await prisma.campaignItem.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const campaignItemWithItem_idOnly = await prisma.campaignItem.findMany({ select: { item_id: true } })
     * 
    **/
    findMany<T extends CampaignItemFindManyArgs>(
      args?: SelectSubset<T, CampaignItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CampaignItem>>, PrismaPromise<Array<CampaignItemGetPayload<T>>>>

    /**
     * Create a CampaignItem.
     * @param {CampaignItemCreateArgs} args - Arguments to create a CampaignItem.
     * @example
     * // Create one CampaignItem
     * const CampaignItem = await prisma.campaignItem.create({
     *   data: {
     *     // ... data to create a CampaignItem
     *   }
     * })
     * 
    **/
    create<T extends CampaignItemCreateArgs>(
      args: SelectSubset<T, CampaignItemCreateArgs>
    ): CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>>

    /**
     * Create many CampaignItems.
     *     @param {CampaignItemCreateManyArgs} args - Arguments to create many CampaignItems.
     *     @example
     *     // Create many CampaignItems
     *     const campaignItem = await prisma.campaignItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignItemCreateManyArgs>(
      args?: SelectSubset<T, CampaignItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignItem.
     * @param {CampaignItemDeleteArgs} args - Arguments to delete one CampaignItem.
     * @example
     * // Delete one CampaignItem
     * const CampaignItem = await prisma.campaignItem.delete({
     *   where: {
     *     // ... filter to delete one CampaignItem
     *   }
     * })
     * 
    **/
    delete<T extends CampaignItemDeleteArgs>(
      args: SelectSubset<T, CampaignItemDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>>

    /**
     * Update one CampaignItem.
     * @param {CampaignItemUpdateArgs} args - Arguments to update one CampaignItem.
     * @example
     * // Update one CampaignItem
     * const campaignItem = await prisma.campaignItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignItemUpdateArgs>(
      args: SelectSubset<T, CampaignItemUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>>

    /**
     * Delete zero or more CampaignItems.
     * @param {CampaignItemDeleteManyArgs} args - Arguments to filter CampaignItems to delete.
     * @example
     * // Delete a few CampaignItems
     * const { count } = await prisma.campaignItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignItemDeleteManyArgs>(
      args?: SelectSubset<T, CampaignItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignItems
     * const campaignItem = await prisma.campaignItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignItemUpdateManyArgs>(
      args: SelectSubset<T, CampaignItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignItem.
     * @param {CampaignItemUpsertArgs} args - Arguments to update or create a CampaignItem.
     * @example
     * // Update or create a CampaignItem
     * const campaignItem = await prisma.campaignItem.upsert({
     *   create: {
     *     // ... data to create a CampaignItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignItem we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignItemUpsertArgs>(
      args: SelectSubset<T, CampaignItemUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>>

    /**
     * Find one CampaignItem that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CampaignItemFindUniqueOrThrowArgs} args - Arguments to find a CampaignItem
     * @example
     * // Get one CampaignItem
     * const campaignItem = await prisma.campaignItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignItemFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>>

    /**
     * Find the first CampaignItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignItemFindFirstOrThrowArgs} args - Arguments to find a CampaignItem
     * @example
     * // Get one CampaignItem
     * const campaignItem = await prisma.campaignItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignItemFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CampaignItemClient<CampaignItem>, Prisma__CampaignItemClient<CampaignItemGetPayload<T>>>

    /**
     * Count the number of CampaignItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignItemCountArgs} args - Arguments to filter CampaignItems to count.
     * @example
     * // Count the number of CampaignItems
     * const count = await prisma.campaignItem.count({
     *   where: {
     *     // ... the filter for the CampaignItems we want to count
     *   }
     * })
    **/
    count<T extends CampaignItemCountArgs>(
      args?: Subset<T, CampaignItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignItemAggregateArgs>(args: Subset<T, CampaignItemAggregateArgs>): PrismaPromise<GetCampaignItemAggregateType<T>>

    /**
     * Group by CampaignItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignItemGroupByArgs['orderBy'] }
        : { orderBy?: CampaignItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignItemGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignItemClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    item<T extends ItemArgs = {}>(args?: Subset<T, ItemArgs>): CheckSelect<T, Prisma__ItemClient<Item | Null>, Prisma__ItemClient<ItemGetPayload<T> | Null>>;

    campaign<T extends CampaignArgs = {}>(args?: Subset<T, CampaignArgs>): CheckSelect<T, Prisma__CampaignClient<Campaign | Null>, Prisma__CampaignClient<CampaignGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CampaignItem base type for findUnique actions
   */
  export type CampaignItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
    /**
     * Filter, which CampaignItem to fetch.
     * 
    **/
    where: CampaignItemWhereUniqueInput
  }

  /**
   * CampaignItem: findUnique
   */
  export interface CampaignItemFindUniqueArgs extends CampaignItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignItem base type for findFirst actions
   */
  export type CampaignItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
    /**
     * Filter, which CampaignItem to fetch.
     * 
    **/
    where?: CampaignItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignItems.
     * 
    **/
    cursor?: CampaignItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignItems.
     * 
    **/
    distinct?: Enumerable<CampaignItemScalarFieldEnum>
  }

  /**
   * CampaignItem: findFirst
   */
  export interface CampaignItemFindFirstArgs extends CampaignItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignItem findMany
   */
  export type CampaignItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
    /**
     * Filter, which CampaignItems to fetch.
     * 
    **/
    where?: CampaignItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CampaignItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignItems.
     * 
    **/
    cursor?: CampaignItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CampaignItemScalarFieldEnum>
  }


  /**
   * CampaignItem create
   */
  export type CampaignItemCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
    /**
     * The data needed to create a CampaignItem.
     * 
    **/
    data: XOR<CampaignItemCreateInput, CampaignItemUncheckedCreateInput>
  }


  /**
   * CampaignItem createMany
   */
  export type CampaignItemCreateManyArgs = {
    /**
     * The data used to create many CampaignItems.
     * 
    **/
    data: Enumerable<CampaignItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignItem update
   */
  export type CampaignItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
    /**
     * The data needed to update a CampaignItem.
     * 
    **/
    data: XOR<CampaignItemUpdateInput, CampaignItemUncheckedUpdateInput>
    /**
     * Choose, which CampaignItem to update.
     * 
    **/
    where: CampaignItemWhereUniqueInput
  }


  /**
   * CampaignItem updateMany
   */
  export type CampaignItemUpdateManyArgs = {
    /**
     * The data used to update CampaignItems.
     * 
    **/
    data: XOR<CampaignItemUpdateManyMutationInput, CampaignItemUncheckedUpdateManyInput>
    /**
     * Filter which CampaignItems to update
     * 
    **/
    where?: CampaignItemWhereInput
  }


  /**
   * CampaignItem upsert
   */
  export type CampaignItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
    /**
     * The filter to search for the CampaignItem to update in case it exists.
     * 
    **/
    where: CampaignItemWhereUniqueInput
    /**
     * In case the CampaignItem found by the `where` argument doesn't exist, create a new CampaignItem with this data.
     * 
    **/
    create: XOR<CampaignItemCreateInput, CampaignItemUncheckedCreateInput>
    /**
     * In case the CampaignItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CampaignItemUpdateInput, CampaignItemUncheckedUpdateInput>
  }


  /**
   * CampaignItem delete
   */
  export type CampaignItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
    /**
     * Filter which CampaignItem to delete.
     * 
    **/
    where: CampaignItemWhereUniqueInput
  }


  /**
   * CampaignItem deleteMany
   */
  export type CampaignItemDeleteManyArgs = {
    /**
     * Filter which CampaignItems to delete
     * 
    **/
    where?: CampaignItemWhereInput
  }


  /**
   * CampaignItem: findUniqueOrThrow
   */
  export type CampaignItemFindUniqueOrThrowArgs = CampaignItemFindUniqueArgsBase
      

  /**
   * CampaignItem: findFirstOrThrow
   */
  export type CampaignItemFindFirstOrThrowArgs = CampaignItemFindFirstArgsBase
      

  /**
   * CampaignItem without action
   */
  export type CampaignItemArgs = {
    /**
     * Select specific fields to fetch from the CampaignItem
     * 
    **/
    select?: CampaignItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CampaignItemInclude | null
  }



  /**
   * Model ItemGrape
   */


  export type AggregateItemGrape = {
    _count: ItemGrapeCountAggregateOutputType | null
    _min: ItemGrapeMinAggregateOutputType | null
    _max: ItemGrapeMaxAggregateOutputType | null
  }

  export type ItemGrapeMinAggregateOutputType = {
    item_id: string | null
    grape_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemGrapeMaxAggregateOutputType = {
    item_id: string | null
    grape_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ItemGrapeCountAggregateOutputType = {
    item_id: number
    grape_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ItemGrapeMinAggregateInputType = {
    item_id?: true
    grape_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemGrapeMaxAggregateInputType = {
    item_id?: true
    grape_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ItemGrapeCountAggregateInputType = {
    item_id?: true
    grape_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ItemGrapeAggregateArgs = {
    /**
     * Filter which ItemGrape to aggregate.
     * 
    **/
    where?: ItemGrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGrapes to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemGrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ItemGrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGrapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGrapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemGrapes
    **/
    _count?: true | ItemGrapeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemGrapeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemGrapeMaxAggregateInputType
  }

  export type GetItemGrapeAggregateType<T extends ItemGrapeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemGrape]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemGrape[P]>
      : GetScalarType<T[P], AggregateItemGrape[P]>
  }




  export type ItemGrapeGroupByArgs = {
    where?: ItemGrapeWhereInput
    orderBy?: Enumerable<ItemGrapeOrderByWithAggregationInput>
    by: Array<ItemGrapeScalarFieldEnum>
    having?: ItemGrapeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemGrapeCountAggregateInputType | true
    _min?: ItemGrapeMinAggregateInputType
    _max?: ItemGrapeMaxAggregateInputType
  }


  export type ItemGrapeGroupByOutputType = {
    item_id: string
    grape_id: string
    created_at: Date
    updated_at: Date
    _count: ItemGrapeCountAggregateOutputType | null
    _min: ItemGrapeMinAggregateOutputType | null
    _max: ItemGrapeMaxAggregateOutputType | null
  }

  type GetItemGrapeGroupByPayload<T extends ItemGrapeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ItemGrapeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGrapeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGrapeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGrapeGroupByOutputType[P]>
        }
      >
    >


  export type ItemGrapeSelect = {
    item_id?: boolean
    item?: boolean | ItemArgs
    grape_id?: boolean
    grape?: boolean | GrapeArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type ItemGrapeInclude = {
    item?: boolean | ItemArgs
    grape?: boolean | GrapeArgs
  }

  export type ItemGrapeGetPayload<
    S extends boolean | null | undefined | ItemGrapeArgs,
    U = keyof S
      > = S extends true
        ? ItemGrape
    : S extends undefined
    ? never
    : S extends ItemGrapeArgs | ItemGrapeFindManyArgs
    ?'include' extends U
    ? ItemGrape  & {
    [P in TrueKeys<S['include']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'grape' ? GrapeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'grape' ? GrapeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ItemGrape ? ItemGrape[P] : never
  } 
    : ItemGrape
  : ItemGrape


  type ItemGrapeCountArgs = Merge<
    Omit<ItemGrapeFindManyArgs, 'select' | 'include'> & {
      select?: ItemGrapeCountAggregateInputType | true
    }
  >

  export interface ItemGrapeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ItemGrape that matches the filter.
     * @param {ItemGrapeFindUniqueArgs} args - Arguments to find a ItemGrape
     * @example
     * // Get one ItemGrape
     * const itemGrape = await prisma.itemGrape.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemGrapeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemGrapeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ItemGrape'> extends True ? CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>> : CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape | null, null>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T> | null, null>>

    /**
     * Find the first ItemGrape that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGrapeFindFirstArgs} args - Arguments to find a ItemGrape
     * @example
     * // Get one ItemGrape
     * const itemGrape = await prisma.itemGrape.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemGrapeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemGrapeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ItemGrape'> extends True ? CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>> : CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape | null, null>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T> | null, null>>

    /**
     * Find zero or more ItemGrapes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGrapeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemGrapes
     * const itemGrapes = await prisma.itemGrape.findMany()
     * 
     * // Get first 10 ItemGrapes
     * const itemGrapes = await prisma.itemGrape.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const itemGrapeWithItem_idOnly = await prisma.itemGrape.findMany({ select: { item_id: true } })
     * 
    **/
    findMany<T extends ItemGrapeFindManyArgs>(
      args?: SelectSubset<T, ItemGrapeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ItemGrape>>, PrismaPromise<Array<ItemGrapeGetPayload<T>>>>

    /**
     * Create a ItemGrape.
     * @param {ItemGrapeCreateArgs} args - Arguments to create a ItemGrape.
     * @example
     * // Create one ItemGrape
     * const ItemGrape = await prisma.itemGrape.create({
     *   data: {
     *     // ... data to create a ItemGrape
     *   }
     * })
     * 
    **/
    create<T extends ItemGrapeCreateArgs>(
      args: SelectSubset<T, ItemGrapeCreateArgs>
    ): CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>>

    /**
     * Create many ItemGrapes.
     *     @param {ItemGrapeCreateManyArgs} args - Arguments to create many ItemGrapes.
     *     @example
     *     // Create many ItemGrapes
     *     const itemGrape = await prisma.itemGrape.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemGrapeCreateManyArgs>(
      args?: SelectSubset<T, ItemGrapeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ItemGrape.
     * @param {ItemGrapeDeleteArgs} args - Arguments to delete one ItemGrape.
     * @example
     * // Delete one ItemGrape
     * const ItemGrape = await prisma.itemGrape.delete({
     *   where: {
     *     // ... filter to delete one ItemGrape
     *   }
     * })
     * 
    **/
    delete<T extends ItemGrapeDeleteArgs>(
      args: SelectSubset<T, ItemGrapeDeleteArgs>
    ): CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>>

    /**
     * Update one ItemGrape.
     * @param {ItemGrapeUpdateArgs} args - Arguments to update one ItemGrape.
     * @example
     * // Update one ItemGrape
     * const itemGrape = await prisma.itemGrape.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemGrapeUpdateArgs>(
      args: SelectSubset<T, ItemGrapeUpdateArgs>
    ): CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>>

    /**
     * Delete zero or more ItemGrapes.
     * @param {ItemGrapeDeleteManyArgs} args - Arguments to filter ItemGrapes to delete.
     * @example
     * // Delete a few ItemGrapes
     * const { count } = await prisma.itemGrape.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemGrapeDeleteManyArgs>(
      args?: SelectSubset<T, ItemGrapeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemGrapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGrapeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemGrapes
     * const itemGrape = await prisma.itemGrape.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemGrapeUpdateManyArgs>(
      args: SelectSubset<T, ItemGrapeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemGrape.
     * @param {ItemGrapeUpsertArgs} args - Arguments to update or create a ItemGrape.
     * @example
     * // Update or create a ItemGrape
     * const itemGrape = await prisma.itemGrape.upsert({
     *   create: {
     *     // ... data to create a ItemGrape
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemGrape we want to update
     *   }
     * })
    **/
    upsert<T extends ItemGrapeUpsertArgs>(
      args: SelectSubset<T, ItemGrapeUpsertArgs>
    ): CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>>

    /**
     * Find one ItemGrape that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ItemGrapeFindUniqueOrThrowArgs} args - Arguments to find a ItemGrape
     * @example
     * // Get one ItemGrape
     * const itemGrape = await prisma.itemGrape.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemGrapeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ItemGrapeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>>

    /**
     * Find the first ItemGrape that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGrapeFindFirstOrThrowArgs} args - Arguments to find a ItemGrape
     * @example
     * // Get one ItemGrape
     * const itemGrape = await prisma.itemGrape.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemGrapeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemGrapeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ItemGrapeClient<ItemGrape>, Prisma__ItemGrapeClient<ItemGrapeGetPayload<T>>>

    /**
     * Count the number of ItemGrapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGrapeCountArgs} args - Arguments to filter ItemGrapes to count.
     * @example
     * // Count the number of ItemGrapes
     * const count = await prisma.itemGrape.count({
     *   where: {
     *     // ... the filter for the ItemGrapes we want to count
     *   }
     * })
    **/
    count<T extends ItemGrapeCountArgs>(
      args?: Subset<T, ItemGrapeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemGrapeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemGrape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGrapeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemGrapeAggregateArgs>(args: Subset<T, ItemGrapeAggregateArgs>): PrismaPromise<GetItemGrapeAggregateType<T>>

    /**
     * Group by ItemGrape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGrapeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGrapeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGrapeGroupByArgs['orderBy'] }
        : { orderBy?: ItemGrapeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGrapeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGrapeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemGrape.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemGrapeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    item<T extends ItemArgs = {}>(args?: Subset<T, ItemArgs>): CheckSelect<T, Prisma__ItemClient<Item | Null>, Prisma__ItemClient<ItemGetPayload<T> | Null>>;

    grape<T extends GrapeArgs = {}>(args?: Subset<T, GrapeArgs>): CheckSelect<T, Prisma__GrapeClient<Grape | Null>, Prisma__GrapeClient<GrapeGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ItemGrape base type for findUnique actions
   */
  export type ItemGrapeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
    /**
     * Filter, which ItemGrape to fetch.
     * 
    **/
    where: ItemGrapeWhereUniqueInput
  }

  /**
   * ItemGrape: findUnique
   */
  export interface ItemGrapeFindUniqueArgs extends ItemGrapeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemGrape base type for findFirst actions
   */
  export type ItemGrapeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
    /**
     * Filter, which ItemGrape to fetch.
     * 
    **/
    where?: ItemGrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGrapes to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemGrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemGrapes.
     * 
    **/
    cursor?: ItemGrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGrapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGrapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemGrapes.
     * 
    **/
    distinct?: Enumerable<ItemGrapeScalarFieldEnum>
  }

  /**
   * ItemGrape: findFirst
   */
  export interface ItemGrapeFindFirstArgs extends ItemGrapeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ItemGrape findMany
   */
  export type ItemGrapeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
    /**
     * Filter, which ItemGrapes to fetch.
     * 
    **/
    where?: ItemGrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGrapes to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemGrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemGrapes.
     * 
    **/
    cursor?: ItemGrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGrapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGrapes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ItemGrapeScalarFieldEnum>
  }


  /**
   * ItemGrape create
   */
  export type ItemGrapeCreateArgs = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
    /**
     * The data needed to create a ItemGrape.
     * 
    **/
    data: XOR<ItemGrapeCreateInput, ItemGrapeUncheckedCreateInput>
  }


  /**
   * ItemGrape createMany
   */
  export type ItemGrapeCreateManyArgs = {
    /**
     * The data used to create many ItemGrapes.
     * 
    **/
    data: Enumerable<ItemGrapeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ItemGrape update
   */
  export type ItemGrapeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
    /**
     * The data needed to update a ItemGrape.
     * 
    **/
    data: XOR<ItemGrapeUpdateInput, ItemGrapeUncheckedUpdateInput>
    /**
     * Choose, which ItemGrape to update.
     * 
    **/
    where: ItemGrapeWhereUniqueInput
  }


  /**
   * ItemGrape updateMany
   */
  export type ItemGrapeUpdateManyArgs = {
    /**
     * The data used to update ItemGrapes.
     * 
    **/
    data: XOR<ItemGrapeUpdateManyMutationInput, ItemGrapeUncheckedUpdateManyInput>
    /**
     * Filter which ItemGrapes to update
     * 
    **/
    where?: ItemGrapeWhereInput
  }


  /**
   * ItemGrape upsert
   */
  export type ItemGrapeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
    /**
     * The filter to search for the ItemGrape to update in case it exists.
     * 
    **/
    where: ItemGrapeWhereUniqueInput
    /**
     * In case the ItemGrape found by the `where` argument doesn't exist, create a new ItemGrape with this data.
     * 
    **/
    create: XOR<ItemGrapeCreateInput, ItemGrapeUncheckedCreateInput>
    /**
     * In case the ItemGrape was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ItemGrapeUpdateInput, ItemGrapeUncheckedUpdateInput>
  }


  /**
   * ItemGrape delete
   */
  export type ItemGrapeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
    /**
     * Filter which ItemGrape to delete.
     * 
    **/
    where: ItemGrapeWhereUniqueInput
  }


  /**
   * ItemGrape deleteMany
   */
  export type ItemGrapeDeleteManyArgs = {
    /**
     * Filter which ItemGrapes to delete
     * 
    **/
    where?: ItemGrapeWhereInput
  }


  /**
   * ItemGrape: findUniqueOrThrow
   */
  export type ItemGrapeFindUniqueOrThrowArgs = ItemGrapeFindUniqueArgsBase
      

  /**
   * ItemGrape: findFirstOrThrow
   */
  export type ItemGrapeFindFirstOrThrowArgs = ItemGrapeFindFirstArgsBase
      

  /**
   * ItemGrape without action
   */
  export type ItemGrapeArgs = {
    /**
     * Select specific fields to fetch from the ItemGrape
     * 
    **/
    select?: ItemGrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemGrapeInclude | null
  }



  /**
   * Model Grape
   */


  export type AggregateGrape = {
    _count: GrapeCountAggregateOutputType | null
    _avg: GrapeAvgAggregateOutputType | null
    _sum: GrapeSumAggregateOutputType | null
    _min: GrapeMinAggregateOutputType | null
    _max: GrapeMaxAggregateOutputType | null
  }

  export type GrapeAvgAggregateOutputType = {
    external_id: number | null
  }

  export type GrapeSumAggregateOutputType = {
    external_id: number | null
  }

  export type GrapeMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type GrapeMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type GrapeCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    created_at: number
    updatedAt: number
    _all: number
  }


  export type GrapeAvgAggregateInputType = {
    external_id?: true
  }

  export type GrapeSumAggregateInputType = {
    external_id?: true
  }

  export type GrapeMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    created_at?: true
    updatedAt?: true
  }

  export type GrapeMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    created_at?: true
    updatedAt?: true
  }

  export type GrapeCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    created_at?: true
    updatedAt?: true
    _all?: true
  }

  export type GrapeAggregateArgs = {
    /**
     * Filter which Grape to aggregate.
     * 
    **/
    where?: GrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grapes to fetch.
     * 
    **/
    orderBy?: Enumerable<GrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grapes
    **/
    _count?: true | GrapeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrapeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrapeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrapeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrapeMaxAggregateInputType
  }

  export type GetGrapeAggregateType<T extends GrapeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrape]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrape[P]>
      : GetScalarType<T[P], AggregateGrape[P]>
  }




  export type GrapeGroupByArgs = {
    where?: GrapeWhereInput
    orderBy?: Enumerable<GrapeOrderByWithAggregationInput>
    by: Array<GrapeScalarFieldEnum>
    having?: GrapeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrapeCountAggregateInputType | true
    _avg?: GrapeAvgAggregateInputType
    _sum?: GrapeSumAggregateInputType
    _min?: GrapeMinAggregateInputType
    _max?: GrapeMaxAggregateInputType
  }


  export type GrapeGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    created_at: Date
    updatedAt: Date
    _count: GrapeCountAggregateOutputType | null
    _avg: GrapeAvgAggregateOutputType | null
    _sum: GrapeSumAggregateOutputType | null
    _min: GrapeMinAggregateOutputType | null
    _max: GrapeMaxAggregateOutputType | null
  }

  type GetGrapeGroupByPayload<T extends GrapeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GrapeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrapeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrapeGroupByOutputType[P]>
            : GetScalarType<T[P], GrapeGroupByOutputType[P]>
        }
      >
    >


  export type GrapeSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    item_grape?: boolean | ItemGrapeFindManyArgs
    created_at?: boolean
    updatedAt?: boolean
    _count?: boolean | GrapeCountOutputTypeArgs
  }

  export type GrapeInclude = {
    item_grape?: boolean | ItemGrapeFindManyArgs
    _count?: boolean | GrapeCountOutputTypeArgs
  }

  export type GrapeGetPayload<
    S extends boolean | null | undefined | GrapeArgs,
    U = keyof S
      > = S extends true
        ? Grape
    : S extends undefined
    ? never
    : S extends GrapeArgs | GrapeFindManyArgs
    ?'include' extends U
    ? Grape  & {
    [P in TrueKeys<S['include']>]:
        P extends 'item_grape' ? Array < ItemGrapeGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? GrapeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'item_grape' ? Array < ItemGrapeGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? GrapeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Grape ? Grape[P] : never
  } 
    : Grape
  : Grape


  type GrapeCountArgs = Merge<
    Omit<GrapeFindManyArgs, 'select' | 'include'> & {
      select?: GrapeCountAggregateInputType | true
    }
  >

  export interface GrapeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Grape that matches the filter.
     * @param {GrapeFindUniqueArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GrapeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GrapeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Grape'> extends True ? CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>> : CheckSelect<T, Prisma__GrapeClient<Grape | null, null>, Prisma__GrapeClient<GrapeGetPayload<T> | null, null>>

    /**
     * Find the first Grape that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeFindFirstArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GrapeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GrapeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Grape'> extends True ? CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>> : CheckSelect<T, Prisma__GrapeClient<Grape | null, null>, Prisma__GrapeClient<GrapeGetPayload<T> | null, null>>

    /**
     * Find zero or more Grapes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grapes
     * const grapes = await prisma.grape.findMany()
     * 
     * // Get first 10 Grapes
     * const grapes = await prisma.grape.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grapeWithIdOnly = await prisma.grape.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GrapeFindManyArgs>(
      args?: SelectSubset<T, GrapeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Grape>>, PrismaPromise<Array<GrapeGetPayload<T>>>>

    /**
     * Create a Grape.
     * @param {GrapeCreateArgs} args - Arguments to create a Grape.
     * @example
     * // Create one Grape
     * const Grape = await prisma.grape.create({
     *   data: {
     *     // ... data to create a Grape
     *   }
     * })
     * 
    **/
    create<T extends GrapeCreateArgs>(
      args: SelectSubset<T, GrapeCreateArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Create many Grapes.
     *     @param {GrapeCreateManyArgs} args - Arguments to create many Grapes.
     *     @example
     *     // Create many Grapes
     *     const grape = await prisma.grape.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GrapeCreateManyArgs>(
      args?: SelectSubset<T, GrapeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Grape.
     * @param {GrapeDeleteArgs} args - Arguments to delete one Grape.
     * @example
     * // Delete one Grape
     * const Grape = await prisma.grape.delete({
     *   where: {
     *     // ... filter to delete one Grape
     *   }
     * })
     * 
    **/
    delete<T extends GrapeDeleteArgs>(
      args: SelectSubset<T, GrapeDeleteArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Update one Grape.
     * @param {GrapeUpdateArgs} args - Arguments to update one Grape.
     * @example
     * // Update one Grape
     * const grape = await prisma.grape.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GrapeUpdateArgs>(
      args: SelectSubset<T, GrapeUpdateArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Delete zero or more Grapes.
     * @param {GrapeDeleteManyArgs} args - Arguments to filter Grapes to delete.
     * @example
     * // Delete a few Grapes
     * const { count } = await prisma.grape.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GrapeDeleteManyArgs>(
      args?: SelectSubset<T, GrapeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grapes
     * const grape = await prisma.grape.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GrapeUpdateManyArgs>(
      args: SelectSubset<T, GrapeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Grape.
     * @param {GrapeUpsertArgs} args - Arguments to update or create a Grape.
     * @example
     * // Update or create a Grape
     * const grape = await prisma.grape.upsert({
     *   create: {
     *     // ... data to create a Grape
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grape we want to update
     *   }
     * })
    **/
    upsert<T extends GrapeUpsertArgs>(
      args: SelectSubset<T, GrapeUpsertArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Find one Grape that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {GrapeFindUniqueOrThrowArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GrapeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GrapeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Find the first Grape that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeFindFirstOrThrowArgs} args - Arguments to find a Grape
     * @example
     * // Get one Grape
     * const grape = await prisma.grape.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GrapeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GrapeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__GrapeClient<Grape>, Prisma__GrapeClient<GrapeGetPayload<T>>>

    /**
     * Count the number of Grapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeCountArgs} args - Arguments to filter Grapes to count.
     * @example
     * // Count the number of Grapes
     * const count = await prisma.grape.count({
     *   where: {
     *     // ... the filter for the Grapes we want to count
     *   }
     * })
    **/
    count<T extends GrapeCountArgs>(
      args?: Subset<T, GrapeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrapeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrapeAggregateArgs>(args: Subset<T, GrapeAggregateArgs>): PrismaPromise<GetGrapeAggregateType<T>>

    /**
     * Group by Grape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrapeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GrapeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GrapeGroupByArgs['orderBy'] }
        : { orderBy?: GrapeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GrapeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrapeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Grape.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GrapeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    item_grape<T extends ItemGrapeFindManyArgs = {}>(args?: Subset<T, ItemGrapeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ItemGrape>| Null>, PrismaPromise<Array<ItemGrapeGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Grape base type for findUnique actions
   */
  export type GrapeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter, which Grape to fetch.
     * 
    **/
    where: GrapeWhereUniqueInput
  }

  /**
   * Grape: findUnique
   */
  export interface GrapeFindUniqueArgs extends GrapeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Grape base type for findFirst actions
   */
  export type GrapeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter, which Grape to fetch.
     * 
    **/
    where?: GrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grapes to fetch.
     * 
    **/
    orderBy?: Enumerable<GrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grapes.
     * 
    **/
    cursor?: GrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grapes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grapes.
     * 
    **/
    distinct?: Enumerable<GrapeScalarFieldEnum>
  }

  /**
   * Grape: findFirst
   */
  export interface GrapeFindFirstArgs extends GrapeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Grape findMany
   */
  export type GrapeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter, which Grapes to fetch.
     * 
    **/
    where?: GrapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grapes to fetch.
     * 
    **/
    orderBy?: Enumerable<GrapeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grapes.
     * 
    **/
    cursor?: GrapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grapes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grapes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GrapeScalarFieldEnum>
  }


  /**
   * Grape create
   */
  export type GrapeCreateArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * The data needed to create a Grape.
     * 
    **/
    data: XOR<GrapeCreateInput, GrapeUncheckedCreateInput>
  }


  /**
   * Grape createMany
   */
  export type GrapeCreateManyArgs = {
    /**
     * The data used to create many Grapes.
     * 
    **/
    data: Enumerable<GrapeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Grape update
   */
  export type GrapeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * The data needed to update a Grape.
     * 
    **/
    data: XOR<GrapeUpdateInput, GrapeUncheckedUpdateInput>
    /**
     * Choose, which Grape to update.
     * 
    **/
    where: GrapeWhereUniqueInput
  }


  /**
   * Grape updateMany
   */
  export type GrapeUpdateManyArgs = {
    /**
     * The data used to update Grapes.
     * 
    **/
    data: XOR<GrapeUpdateManyMutationInput, GrapeUncheckedUpdateManyInput>
    /**
     * Filter which Grapes to update
     * 
    **/
    where?: GrapeWhereInput
  }


  /**
   * Grape upsert
   */
  export type GrapeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * The filter to search for the Grape to update in case it exists.
     * 
    **/
    where: GrapeWhereUniqueInput
    /**
     * In case the Grape found by the `where` argument doesn't exist, create a new Grape with this data.
     * 
    **/
    create: XOR<GrapeCreateInput, GrapeUncheckedCreateInput>
    /**
     * In case the Grape was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GrapeUpdateInput, GrapeUncheckedUpdateInput>
  }


  /**
   * Grape delete
   */
  export type GrapeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
    /**
     * Filter which Grape to delete.
     * 
    **/
    where: GrapeWhereUniqueInput
  }


  /**
   * Grape deleteMany
   */
  export type GrapeDeleteManyArgs = {
    /**
     * Filter which Grapes to delete
     * 
    **/
    where?: GrapeWhereInput
  }


  /**
   * Grape: findUniqueOrThrow
   */
  export type GrapeFindUniqueOrThrowArgs = GrapeFindUniqueArgsBase
      

  /**
   * Grape: findFirstOrThrow
   */
  export type GrapeFindFirstOrThrowArgs = GrapeFindFirstArgsBase
      

  /**
   * Grape without action
   */
  export type GrapeArgs = {
    /**
     * Select specific fields to fetch from the Grape
     * 
    **/
    select?: GrapeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GrapeInclude | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    external_id: number | null
  }

  export type CountrySumAggregateOutputType = {
    external_id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    external_id?: true
  }

  export type CountrySumAggregateInputType = {
    external_id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CountryAggregateArgs = {
    /**
     * Filter which Country to aggregate.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: Array<CountryScalarFieldEnum>
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    value: string
    created_at: Date
    updated_at: Date
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    value?: boolean
    states?: boolean | StateFindManyArgs
    items?: boolean | ItemFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryInclude = {
    states?: boolean | StateFindManyArgs
    items?: boolean | ItemFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryGetPayload<
    S extends boolean | null | undefined | CountryArgs,
    U = keyof S
      > = S extends true
        ? Country
    : S extends undefined
    ? never
    : S extends CountryArgs | CountryFindManyArgs
    ?'include' extends U
    ? Country  & {
    [P in TrueKeys<S['include']>]:
        P extends 'states' ? Array < StateGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'states' ? Array < StateGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CountryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Country ? Country[P] : never
  } 
    : Country
  : Country


  type CountryCountArgs = Merge<
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }
  >

  export interface CountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null, null>, Prisma__CountryClient<CountryGetPayload<T> | null, null>>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null, null>, Prisma__CountryClient<CountryGetPayload<T> | null, null>>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs>(
      args?: SelectSubset<T, CountryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Country>>, PrismaPromise<Array<CountryGetPayload<T>>>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs>(
      args: SelectSubset<T, CountryCreateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs>(
      args?: SelectSubset<T, CountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs>(
      args: SelectSubset<T, CountryDeleteArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs>(
      args: SelectSubset<T, CountryUpdateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs>(
      args?: SelectSubset<T, CountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs>(
      args: SelectSubset<T, CountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs>(
      args: SelectSubset<T, CountryUpsertArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Find one Country that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Find the first Country that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    states<T extends StateFindManyArgs = {}>(args?: Subset<T, StateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<State>| Null>, PrismaPromise<Array<StateGetPayload<T>>| Null>>;

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>| Null>, PrismaPromise<Array<ItemGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Country base type for findUnique actions
   */
  export type CountryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where: CountryWhereUniqueInput
  }

  /**
   * Country: findUnique
   */
  export interface CountryFindUniqueArgs extends CountryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country base type for findFirst actions
   */
  export type CountryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Country to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     * 
    **/
    distinct?: Enumerable<CountryScalarFieldEnum>
  }

  /**
   * Country: findFirst
   */
  export interface CountryFindFirstArgs extends CountryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findMany
   */
  export type CountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Countries to fetch.
     * 
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     * 
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     * 
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to create a Country.
     * 
    **/
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs = {
    /**
     * The data used to create many Countries.
     * 
    **/
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The data needed to update a Country.
     * 
    **/
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs = {
    /**
     * The data used to update Countries.
     * 
    **/
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * The filter to search for the Country to update in case it exists.
     * 
    **/
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     * 
    **/
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
    /**
     * Filter which Country to delete.
     * 
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs = {
    /**
     * Filter which Countries to delete
     * 
    **/
    where?: CountryWhereInput
  }


  /**
   * Country: findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs = CountryFindUniqueArgsBase
      

  /**
   * Country: findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs = CountryFindFirstArgsBase
      

  /**
   * Country without action
   */
  export type CountryArgs = {
    /**
     * Select specific fields to fetch from the Country
     * 
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CountryInclude | null
  }



  /**
   * Model State
   */


  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateAvgAggregateOutputType = {
    external_id: number | null
  }

  export type StateSumAggregateOutputType = {
    external_id: number | null
  }

  export type StateMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    country_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StateMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    country_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    country_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StateAvgAggregateInputType = {
    external_id?: true
  }

  export type StateSumAggregateInputType = {
    external_id?: true
  }

  export type StateMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    country_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    country_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    country_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StateAggregateArgs = {
    /**
     * Filter which State to aggregate.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs = {
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithAggregationInput>
    by: Array<StateScalarFieldEnum>
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _avg?: StateAvgAggregateInputType
    _sum?: StateSumAggregateInputType
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }


  export type StateGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    country_id: string
    created_at: Date
    updated_at: Date
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    country_id?: boolean
    country?: boolean | CountryArgs
    regions?: boolean | RegionFindManyArgs
    cities?: boolean | CityFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateInclude = {
    country?: boolean | CountryArgs
    regions?: boolean | RegionFindManyArgs
    cities?: boolean | CityFindManyArgs
    _count?: boolean | StateCountOutputTypeArgs
  }

  export type StateGetPayload<
    S extends boolean | null | undefined | StateArgs,
    U = keyof S
      > = S extends true
        ? State
    : S extends undefined
    ? never
    : S extends StateArgs | StateFindManyArgs
    ?'include' extends U
    ? State  & {
    [P in TrueKeys<S['include']>]:
        P extends 'country' ? CountryGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'regions' ? Array < RegionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'cities' ? Array < CityGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'country' ? CountryGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'regions' ? Array < RegionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'cities' ? Array < CityGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? StateCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof State ? State[P] : never
  } 
    : State
  : State


  type StateCountArgs = Merge<
    Omit<StateFindManyArgs, 'select' | 'include'> & {
      select?: StateCountAggregateInputType | true
    }
  >

  export interface StateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null, null>, Prisma__StateClient<StateGetPayload<T> | null, null>>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null, null>, Prisma__StateClient<StateGetPayload<T> | null, null>>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StateFindManyArgs>(
      args?: SelectSubset<T, StateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<State>>, PrismaPromise<Array<StateGetPayload<T>>>>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends StateCreateArgs>(
      args: SelectSubset<T, StateCreateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Create many States.
     *     @param {StateCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const state = await prisma.state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StateCreateManyArgs>(
      args?: SelectSubset<T, StateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends StateDeleteArgs>(
      args: SelectSubset<T, StateDeleteArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateUpdateArgs>(
      args: SelectSubset<T, StateUpdateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateDeleteManyArgs>(
      args?: SelectSubset<T, StateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateUpdateManyArgs>(
      args: SelectSubset<T, StateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends StateUpsertArgs>(
      args: SelectSubset<T, StateUpsertArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Find one State that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StateFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Find the first State that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StateFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StateClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | Null>, Prisma__CountryClient<CountryGetPayload<T> | Null>>;

    regions<T extends RegionFindManyArgs = {}>(args?: Subset<T, RegionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Region>| Null>, PrismaPromise<Array<RegionGetPayload<T>>| Null>>;

    cities<T extends CityFindManyArgs = {}>(args?: Subset<T, CityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<City>| Null>, PrismaPromise<Array<CityGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * State base type for findUnique actions
   */
  export type StateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     * 
    **/
    where: StateWhereUniqueInput
  }

  /**
   * State: findUnique
   */
  export interface StateFindUniqueArgs extends StateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State base type for findFirst actions
   */
  export type StateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which State to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     * 
    **/
    distinct?: Enumerable<StateScalarFieldEnum>
  }

  /**
   * State: findFirst
   */
  export interface StateFindFirstArgs extends StateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State findMany
   */
  export type StateFindManyArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter, which States to fetch.
     * 
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     * 
    **/
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     * 
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State create
   */
  export type StateCreateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to create a State.
     * 
    **/
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }


  /**
   * State createMany
   */
  export type StateCreateManyArgs = {
    /**
     * The data used to create many States.
     * 
    **/
    data: Enumerable<StateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * State update
   */
  export type StateUpdateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The data needed to update a State.
     * 
    **/
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State updateMany
   */
  export type StateUpdateManyArgs = {
    /**
     * The data used to update States.
     * 
    **/
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State upsert
   */
  export type StateUpsertArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * The filter to search for the State to update in case it exists.
     * 
    **/
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     * 
    **/
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }


  /**
   * State delete
   */
  export type StateDeleteArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
    /**
     * Filter which State to delete.
     * 
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs = {
    /**
     * Filter which States to delete
     * 
    **/
    where?: StateWhereInput
  }


  /**
   * State: findUniqueOrThrow
   */
  export type StateFindUniqueOrThrowArgs = StateFindUniqueArgsBase
      

  /**
   * State: findFirstOrThrow
   */
  export type StateFindFirstOrThrowArgs = StateFindFirstArgsBase
      

  /**
   * State without action
   */
  export type StateArgs = {
    /**
     * Select specific fields to fetch from the State
     * 
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StateInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    external_id: number | null
  }

  export type CitySumAggregateOutputType = {
    external_id: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    state_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    state_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    state_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    external_id?: true
  }

  export type CitySumAggregateInputType = {
    external_id?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    state_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    state_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    state_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithAggregationInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    state_id: string
    created_at: Date
    updated_at: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    state_id?: boolean
    state?: boolean | StateArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type CityInclude = {
    state?: boolean | StateArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof City ? City[P] : never
  } 
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null, null>, Prisma__CityClient<CityGetPayload<T> | null, null>>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null, null>, Prisma__CityClient<CityGetPayload<T> | null, null>>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Find one City that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Find the first City that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | Null>, Prisma__StateClient<StateGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * City base type for findUnique actions
   */
  export type CityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where: CityWhereUniqueInput
  }

  /**
   * City: findUnique
   */
  export interface CityFindUniqueArgs extends CityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City base type for findFirst actions
   */
  export type CityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which City to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     * 
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }

  /**
   * City: findFirst
   */
  export interface CityFindFirstArgs extends CityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     * 
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    /**
     * The data used to create many Cities.
     * 
    **/
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     * 
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    /**
     * The data used to update Cities.
     * 
    **/
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     * 
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     * 
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    /**
     * Filter which Cities to delete
     * 
    **/
    where?: CityWhereInput
  }


  /**
   * City: findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs = CityFindUniqueArgsBase
      

  /**
   * City: findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs = CityFindFirstArgsBase
      

  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
  }



  /**
   * Model Region
   */


  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    external_id: number | null
  }

  export type RegionSumAggregateOutputType = {
    external_id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    state_id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RegionMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    state_id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    external_id: number
    state_id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    external_id?: true
  }

  export type RegionSumAggregateInputType = {
    external_id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    external_id?: true
    state_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    external_id?: true
    state_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    external_id?: true
    state_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RegionAggregateArgs = {
    /**
     * Filter which Region to aggregate.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs = {
    where?: RegionWhereInput
    orderBy?: Enumerable<RegionOrderByWithAggregationInput>
    by: Array<RegionScalarFieldEnum>
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }


  export type RegionGroupByOutputType = {
    id: string
    external_id: number | null
    state_id: string
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect = {
    id?: boolean
    external_id?: boolean
    state_id?: boolean
    state?: boolean | StateArgs
    name?: boolean
    slug?: boolean
    subregion?: boolean | SubRegionFindManyArgs
    items?: boolean | ItemFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | RegionCountOutputTypeArgs
  }

  export type RegionInclude = {
    state?: boolean | StateArgs
    subregion?: boolean | SubRegionFindManyArgs
    items?: boolean | ItemFindManyArgs
    _count?: boolean | RegionCountOutputTypeArgs
  }

  export type RegionGetPayload<
    S extends boolean | null | undefined | RegionArgs,
    U = keyof S
      > = S extends true
        ? Region
    : S extends undefined
    ? never
    : S extends RegionArgs | RegionFindManyArgs
    ?'include' extends U
    ? Region  & {
    [P in TrueKeys<S['include']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'subregion' ? Array < SubRegionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RegionCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'state' ? StateGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'subregion' ? Array < SubRegionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RegionCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Region ? Region[P] : never
  } 
    : Region
  : Region


  type RegionCountArgs = Merge<
    Omit<RegionFindManyArgs, 'select' | 'include'> & {
      select?: RegionCountAggregateInputType | true
    }
  >

  export interface RegionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null, null>, Prisma__RegionClient<RegionGetPayload<T> | null, null>>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null, null>, Prisma__RegionClient<RegionGetPayload<T> | null, null>>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs>(
      args?: SelectSubset<T, RegionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Region>>, PrismaPromise<Array<RegionGetPayload<T>>>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs>(
      args: SelectSubset<T, RegionCreateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs>(
      args?: SelectSubset<T, RegionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs>(
      args: SelectSubset<T, RegionDeleteArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs>(
      args: SelectSubset<T, RegionUpdateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs>(
      args?: SelectSubset<T, RegionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs>(
      args: SelectSubset<T, RegionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs>(
      args: SelectSubset<T, RegionUpsertArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Find one Region that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RegionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Find the first Region that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RegionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | Null>, Prisma__StateClient<StateGetPayload<T> | Null>>;

    subregion<T extends SubRegionFindManyArgs = {}>(args?: Subset<T, SubRegionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SubRegion>| Null>, PrismaPromise<Array<SubRegionGetPayload<T>>| Null>>;

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>| Null>, PrismaPromise<Array<ItemGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Region base type for findUnique actions
   */
  export type RegionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Region to fetch.
     * 
    **/
    where: RegionWhereUniqueInput
  }

  /**
   * Region: findUnique
   */
  export interface RegionFindUniqueArgs extends RegionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Region base type for findFirst actions
   */
  export type RegionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Region to fetch.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     * 
    **/
    distinct?: Enumerable<RegionScalarFieldEnum>
  }

  /**
   * Region: findFirst
   */
  export interface RegionFindFirstArgs extends RegionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Region findMany
   */
  export type RegionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Regions to fetch.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RegionScalarFieldEnum>
  }


  /**
   * Region create
   */
  export type RegionCreateArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The data needed to create a Region.
     * 
    **/
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }


  /**
   * Region createMany
   */
  export type RegionCreateManyArgs = {
    /**
     * The data used to create many Regions.
     * 
    **/
    data: Enumerable<RegionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Region update
   */
  export type RegionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The data needed to update a Region.
     * 
    **/
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     * 
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs = {
    /**
     * The data used to update Regions.
     * 
    **/
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     * 
    **/
    where?: RegionWhereInput
  }


  /**
   * Region upsert
   */
  export type RegionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The filter to search for the Region to update in case it exists.
     * 
    **/
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     * 
    **/
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }


  /**
   * Region delete
   */
  export type RegionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter which Region to delete.
     * 
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs = {
    /**
     * Filter which Regions to delete
     * 
    **/
    where?: RegionWhereInput
  }


  /**
   * Region: findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs = RegionFindUniqueArgsBase
      

  /**
   * Region: findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs = RegionFindFirstArgsBase
      

  /**
   * Region without action
   */
  export type RegionArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
  }



  /**
   * Model SubRegion
   */


  export type AggregateSubRegion = {
    _count: SubRegionCountAggregateOutputType | null
    _avg: SubRegionAvgAggregateOutputType | null
    _sum: SubRegionSumAggregateOutputType | null
    _min: SubRegionMinAggregateOutputType | null
    _max: SubRegionMaxAggregateOutputType | null
  }

  export type SubRegionAvgAggregateOutputType = {
    external_id: number | null
  }

  export type SubRegionSumAggregateOutputType = {
    external_id: number | null
  }

  export type SubRegionMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    region_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubRegionMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    region_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubRegionCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    region_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubRegionAvgAggregateInputType = {
    external_id?: true
  }

  export type SubRegionSumAggregateInputType = {
    external_id?: true
  }

  export type SubRegionMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    region_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SubRegionMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    region_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SubRegionCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    region_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubRegionAggregateArgs = {
    /**
     * Filter which SubRegion to aggregate.
     * 
    **/
    where?: SubRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubRegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubRegions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubRegions
    **/
    _count?: true | SubRegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubRegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubRegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubRegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubRegionMaxAggregateInputType
  }

  export type GetSubRegionAggregateType<T extends SubRegionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubRegion[P]>
      : GetScalarType<T[P], AggregateSubRegion[P]>
  }




  export type SubRegionGroupByArgs = {
    where?: SubRegionWhereInput
    orderBy?: Enumerable<SubRegionOrderByWithAggregationInput>
    by: Array<SubRegionScalarFieldEnum>
    having?: SubRegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubRegionCountAggregateInputType | true
    _avg?: SubRegionAvgAggregateInputType
    _sum?: SubRegionSumAggregateInputType
    _min?: SubRegionMinAggregateInputType
    _max?: SubRegionMaxAggregateInputType
  }


  export type SubRegionGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    region_id: string
    created_at: Date
    updated_at: Date
    _count: SubRegionCountAggregateOutputType | null
    _avg: SubRegionAvgAggregateOutputType | null
    _sum: SubRegionSumAggregateOutputType | null
    _min: SubRegionMinAggregateOutputType | null
    _max: SubRegionMaxAggregateOutputType | null
  }

  type GetSubRegionGroupByPayload<T extends SubRegionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubRegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubRegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubRegionGroupByOutputType[P]>
            : GetScalarType<T[P], SubRegionGroupByOutputType[P]>
        }
      >
    >


  export type SubRegionSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    region_id?: boolean
    region?: boolean | RegionArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubRegionInclude = {
    region?: boolean | RegionArgs
  }

  export type SubRegionGetPayload<
    S extends boolean | null | undefined | SubRegionArgs,
    U = keyof S
      > = S extends true
        ? SubRegion
    : S extends undefined
    ? never
    : S extends SubRegionArgs | SubRegionFindManyArgs
    ?'include' extends U
    ? SubRegion  & {
    [P in TrueKeys<S['include']>]:
        P extends 'region' ? RegionGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'region' ? RegionGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SubRegion ? SubRegion[P] : never
  } 
    : SubRegion
  : SubRegion


  type SubRegionCountArgs = Merge<
    Omit<SubRegionFindManyArgs, 'select' | 'include'> & {
      select?: SubRegionCountAggregateInputType | true
    }
  >

  export interface SubRegionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SubRegion that matches the filter.
     * @param {SubRegionFindUniqueArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubRegionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubRegionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubRegion'> extends True ? CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>> : CheckSelect<T, Prisma__SubRegionClient<SubRegion | null, null>, Prisma__SubRegionClient<SubRegionGetPayload<T> | null, null>>

    /**
     * Find the first SubRegion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionFindFirstArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubRegionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubRegionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubRegion'> extends True ? CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>> : CheckSelect<T, Prisma__SubRegionClient<SubRegion | null, null>, Prisma__SubRegionClient<SubRegionGetPayload<T> | null, null>>

    /**
     * Find zero or more SubRegions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubRegions
     * const subRegions = await prisma.subRegion.findMany()
     * 
     * // Get first 10 SubRegions
     * const subRegions = await prisma.subRegion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subRegionWithIdOnly = await prisma.subRegion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubRegionFindManyArgs>(
      args?: SelectSubset<T, SubRegionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubRegion>>, PrismaPromise<Array<SubRegionGetPayload<T>>>>

    /**
     * Create a SubRegion.
     * @param {SubRegionCreateArgs} args - Arguments to create a SubRegion.
     * @example
     * // Create one SubRegion
     * const SubRegion = await prisma.subRegion.create({
     *   data: {
     *     // ... data to create a SubRegion
     *   }
     * })
     * 
    **/
    create<T extends SubRegionCreateArgs>(
      args: SelectSubset<T, SubRegionCreateArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Create many SubRegions.
     *     @param {SubRegionCreateManyArgs} args - Arguments to create many SubRegions.
     *     @example
     *     // Create many SubRegions
     *     const subRegion = await prisma.subRegion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubRegionCreateManyArgs>(
      args?: SelectSubset<T, SubRegionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubRegion.
     * @param {SubRegionDeleteArgs} args - Arguments to delete one SubRegion.
     * @example
     * // Delete one SubRegion
     * const SubRegion = await prisma.subRegion.delete({
     *   where: {
     *     // ... filter to delete one SubRegion
     *   }
     * })
     * 
    **/
    delete<T extends SubRegionDeleteArgs>(
      args: SelectSubset<T, SubRegionDeleteArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Update one SubRegion.
     * @param {SubRegionUpdateArgs} args - Arguments to update one SubRegion.
     * @example
     * // Update one SubRegion
     * const subRegion = await prisma.subRegion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubRegionUpdateArgs>(
      args: SelectSubset<T, SubRegionUpdateArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Delete zero or more SubRegions.
     * @param {SubRegionDeleteManyArgs} args - Arguments to filter SubRegions to delete.
     * @example
     * // Delete a few SubRegions
     * const { count } = await prisma.subRegion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubRegionDeleteManyArgs>(
      args?: SelectSubset<T, SubRegionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubRegions
     * const subRegion = await prisma.subRegion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubRegionUpdateManyArgs>(
      args: SelectSubset<T, SubRegionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubRegion.
     * @param {SubRegionUpsertArgs} args - Arguments to update or create a SubRegion.
     * @example
     * // Update or create a SubRegion
     * const subRegion = await prisma.subRegion.upsert({
     *   create: {
     *     // ... data to create a SubRegion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubRegion we want to update
     *   }
     * })
    **/
    upsert<T extends SubRegionUpsertArgs>(
      args: SelectSubset<T, SubRegionUpsertArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Find one SubRegion that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SubRegionFindUniqueOrThrowArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubRegionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubRegionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Find the first SubRegion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionFindFirstOrThrowArgs} args - Arguments to find a SubRegion
     * @example
     * // Get one SubRegion
     * const subRegion = await prisma.subRegion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubRegionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubRegionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SubRegionClient<SubRegion>, Prisma__SubRegionClient<SubRegionGetPayload<T>>>

    /**
     * Count the number of SubRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionCountArgs} args - Arguments to filter SubRegions to count.
     * @example
     * // Count the number of SubRegions
     * const count = await prisma.subRegion.count({
     *   where: {
     *     // ... the filter for the SubRegions we want to count
     *   }
     * })
    **/
    count<T extends SubRegionCountArgs>(
      args?: Subset<T, SubRegionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubRegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubRegion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubRegionAggregateArgs>(args: Subset<T, SubRegionAggregateArgs>): PrismaPromise<GetSubRegionAggregateType<T>>

    /**
     * Group by SubRegion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubRegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubRegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubRegionGroupByArgs['orderBy'] }
        : { orderBy?: SubRegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubRegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubRegionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubRegion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubRegionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    region<T extends RegionArgs = {}>(args?: Subset<T, RegionArgs>): CheckSelect<T, Prisma__RegionClient<Region | Null>, Prisma__RegionClient<RegionGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubRegion base type for findUnique actions
   */
  export type SubRegionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter, which SubRegion to fetch.
     * 
    **/
    where: SubRegionWhereUniqueInput
  }

  /**
   * SubRegion: findUnique
   */
  export interface SubRegionFindUniqueArgs extends SubRegionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubRegion base type for findFirst actions
   */
  export type SubRegionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter, which SubRegion to fetch.
     * 
    **/
    where?: SubRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubRegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubRegions.
     * 
    **/
    cursor?: SubRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubRegions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubRegions.
     * 
    **/
    distinct?: Enumerable<SubRegionScalarFieldEnum>
  }

  /**
   * SubRegion: findFirst
   */
  export interface SubRegionFindFirstArgs extends SubRegionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubRegion findMany
   */
  export type SubRegionFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter, which SubRegions to fetch.
     * 
    **/
    where?: SubRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubRegions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubRegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubRegions.
     * 
    **/
    cursor?: SubRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubRegions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubRegions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubRegionScalarFieldEnum>
  }


  /**
   * SubRegion create
   */
  export type SubRegionCreateArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * The data needed to create a SubRegion.
     * 
    **/
    data: XOR<SubRegionCreateInput, SubRegionUncheckedCreateInput>
  }


  /**
   * SubRegion createMany
   */
  export type SubRegionCreateManyArgs = {
    /**
     * The data used to create many SubRegions.
     * 
    **/
    data: Enumerable<SubRegionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubRegion update
   */
  export type SubRegionUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * The data needed to update a SubRegion.
     * 
    **/
    data: XOR<SubRegionUpdateInput, SubRegionUncheckedUpdateInput>
    /**
     * Choose, which SubRegion to update.
     * 
    **/
    where: SubRegionWhereUniqueInput
  }


  /**
   * SubRegion updateMany
   */
  export type SubRegionUpdateManyArgs = {
    /**
     * The data used to update SubRegions.
     * 
    **/
    data: XOR<SubRegionUpdateManyMutationInput, SubRegionUncheckedUpdateManyInput>
    /**
     * Filter which SubRegions to update
     * 
    **/
    where?: SubRegionWhereInput
  }


  /**
   * SubRegion upsert
   */
  export type SubRegionUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * The filter to search for the SubRegion to update in case it exists.
     * 
    **/
    where: SubRegionWhereUniqueInput
    /**
     * In case the SubRegion found by the `where` argument doesn't exist, create a new SubRegion with this data.
     * 
    **/
    create: XOR<SubRegionCreateInput, SubRegionUncheckedCreateInput>
    /**
     * In case the SubRegion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubRegionUpdateInput, SubRegionUncheckedUpdateInput>
  }


  /**
   * SubRegion delete
   */
  export type SubRegionDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
    /**
     * Filter which SubRegion to delete.
     * 
    **/
    where: SubRegionWhereUniqueInput
  }


  /**
   * SubRegion deleteMany
   */
  export type SubRegionDeleteManyArgs = {
    /**
     * Filter which SubRegions to delete
     * 
    **/
    where?: SubRegionWhereInput
  }


  /**
   * SubRegion: findUniqueOrThrow
   */
  export type SubRegionFindUniqueOrThrowArgs = SubRegionFindUniqueArgsBase
      

  /**
   * SubRegion: findFirstOrThrow
   */
  export type SubRegionFindFirstOrThrowArgs = SubRegionFindFirstArgsBase
      

  /**
   * SubRegion without action
   */
  export type SubRegionArgs = {
    /**
     * Select specific fields to fetch from the SubRegion
     * 
    **/
    select?: SubRegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubRegionInclude | null
  }



  /**
   * Model WineType
   */


  export type AggregateWineType = {
    _count: WineTypeCountAggregateOutputType | null
    _avg: WineTypeAvgAggregateOutputType | null
    _sum: WineTypeSumAggregateOutputType | null
    _min: WineTypeMinAggregateOutputType | null
    _max: WineTypeMaxAggregateOutputType | null
  }

  export type WineTypeAvgAggregateOutputType = {
    external_id: number | null
  }

  export type WineTypeSumAggregateOutputType = {
    external_id: number | null
  }

  export type WineTypeMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WineTypeMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WineTypeCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WineTypeAvgAggregateInputType = {
    external_id?: true
  }

  export type WineTypeSumAggregateInputType = {
    external_id?: true
  }

  export type WineTypeMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type WineTypeMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type WineTypeCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WineTypeAggregateArgs = {
    /**
     * Filter which WineType to aggregate.
     * 
    **/
    where?: WineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<WineTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WineTypes
    **/
    _count?: true | WineTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WineTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WineTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WineTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WineTypeMaxAggregateInputType
  }

  export type GetWineTypeAggregateType<T extends WineTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateWineType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWineType[P]>
      : GetScalarType<T[P], AggregateWineType[P]>
  }




  export type WineTypeGroupByArgs = {
    where?: WineTypeWhereInput
    orderBy?: Enumerable<WineTypeOrderByWithAggregationInput>
    by: Array<WineTypeScalarFieldEnum>
    having?: WineTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WineTypeCountAggregateInputType | true
    _avg?: WineTypeAvgAggregateInputType
    _sum?: WineTypeSumAggregateInputType
    _min?: WineTypeMinAggregateInputType
    _max?: WineTypeMaxAggregateInputType
  }


  export type WineTypeGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: WineTypeCountAggregateOutputType | null
    _avg: WineTypeAvgAggregateOutputType | null
    _sum: WineTypeSumAggregateOutputType | null
    _min: WineTypeMinAggregateOutputType | null
    _max: WineTypeMaxAggregateOutputType | null
  }

  type GetWineTypeGroupByPayload<T extends WineTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WineTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WineTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WineTypeGroupByOutputType[P]>
            : GetScalarType<T[P], WineTypeGroupByOutputType[P]>
        }
      >
    >


  export type WineTypeSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    slug?: boolean
    items?: boolean | ItemFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    _count?: boolean | WineTypeCountOutputTypeArgs
  }

  export type WineTypeInclude = {
    items?: boolean | ItemFindManyArgs
    _count?: boolean | WineTypeCountOutputTypeArgs
  }

  export type WineTypeGetPayload<
    S extends boolean | null | undefined | WineTypeArgs,
    U = keyof S
      > = S extends true
        ? WineType
    : S extends undefined
    ? never
    : S extends WineTypeArgs | WineTypeFindManyArgs
    ?'include' extends U
    ? WineType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? WineTypeCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? WineTypeCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof WineType ? WineType[P] : never
  } 
    : WineType
  : WineType


  type WineTypeCountArgs = Merge<
    Omit<WineTypeFindManyArgs, 'select' | 'include'> & {
      select?: WineTypeCountAggregateInputType | true
    }
  >

  export interface WineTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one WineType that matches the filter.
     * @param {WineTypeFindUniqueArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WineTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WineTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WineType'> extends True ? CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>> : CheckSelect<T, Prisma__WineTypeClient<WineType | null, null>, Prisma__WineTypeClient<WineTypeGetPayload<T> | null, null>>

    /**
     * Find the first WineType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeFindFirstArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WineTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WineTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WineType'> extends True ? CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>> : CheckSelect<T, Prisma__WineTypeClient<WineType | null, null>, Prisma__WineTypeClient<WineTypeGetPayload<T> | null, null>>

    /**
     * Find zero or more WineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WineTypes
     * const wineTypes = await prisma.wineType.findMany()
     * 
     * // Get first 10 WineTypes
     * const wineTypes = await prisma.wineType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wineTypeWithIdOnly = await prisma.wineType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WineTypeFindManyArgs>(
      args?: SelectSubset<T, WineTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WineType>>, PrismaPromise<Array<WineTypeGetPayload<T>>>>

    /**
     * Create a WineType.
     * @param {WineTypeCreateArgs} args - Arguments to create a WineType.
     * @example
     * // Create one WineType
     * const WineType = await prisma.wineType.create({
     *   data: {
     *     // ... data to create a WineType
     *   }
     * })
     * 
    **/
    create<T extends WineTypeCreateArgs>(
      args: SelectSubset<T, WineTypeCreateArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Create many WineTypes.
     *     @param {WineTypeCreateManyArgs} args - Arguments to create many WineTypes.
     *     @example
     *     // Create many WineTypes
     *     const wineType = await prisma.wineType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WineTypeCreateManyArgs>(
      args?: SelectSubset<T, WineTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WineType.
     * @param {WineTypeDeleteArgs} args - Arguments to delete one WineType.
     * @example
     * // Delete one WineType
     * const WineType = await prisma.wineType.delete({
     *   where: {
     *     // ... filter to delete one WineType
     *   }
     * })
     * 
    **/
    delete<T extends WineTypeDeleteArgs>(
      args: SelectSubset<T, WineTypeDeleteArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Update one WineType.
     * @param {WineTypeUpdateArgs} args - Arguments to update one WineType.
     * @example
     * // Update one WineType
     * const wineType = await prisma.wineType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WineTypeUpdateArgs>(
      args: SelectSubset<T, WineTypeUpdateArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Delete zero or more WineTypes.
     * @param {WineTypeDeleteManyArgs} args - Arguments to filter WineTypes to delete.
     * @example
     * // Delete a few WineTypes
     * const { count } = await prisma.wineType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WineTypeDeleteManyArgs>(
      args?: SelectSubset<T, WineTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WineTypes
     * const wineType = await prisma.wineType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WineTypeUpdateManyArgs>(
      args: SelectSubset<T, WineTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WineType.
     * @param {WineTypeUpsertArgs} args - Arguments to update or create a WineType.
     * @example
     * // Update or create a WineType
     * const wineType = await prisma.wineType.upsert({
     *   create: {
     *     // ... data to create a WineType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WineType we want to update
     *   }
     * })
    **/
    upsert<T extends WineTypeUpsertArgs>(
      args: SelectSubset<T, WineTypeUpsertArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Find one WineType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {WineTypeFindUniqueOrThrowArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WineTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WineTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Find the first WineType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeFindFirstOrThrowArgs} args - Arguments to find a WineType
     * @example
     * // Get one WineType
     * const wineType = await prisma.wineType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WineTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WineTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__WineTypeClient<WineType>, Prisma__WineTypeClient<WineTypeGetPayload<T>>>

    /**
     * Count the number of WineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeCountArgs} args - Arguments to filter WineTypes to count.
     * @example
     * // Count the number of WineTypes
     * const count = await prisma.wineType.count({
     *   where: {
     *     // ... the filter for the WineTypes we want to count
     *   }
     * })
    **/
    count<T extends WineTypeCountArgs>(
      args?: Subset<T, WineTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WineTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WineTypeAggregateArgs>(args: Subset<T, WineTypeAggregateArgs>): PrismaPromise<GetWineTypeAggregateType<T>>

    /**
     * Group by WineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WineTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WineTypeGroupByArgs['orderBy'] }
        : { orderBy?: WineTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WineTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWineTypeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WineType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WineTypeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>| Null>, PrismaPromise<Array<ItemGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WineType base type for findUnique actions
   */
  export type WineTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter, which WineType to fetch.
     * 
    **/
    where: WineTypeWhereUniqueInput
  }

  /**
   * WineType: findUnique
   */
  export interface WineTypeFindUniqueArgs extends WineTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WineType base type for findFirst actions
   */
  export type WineTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter, which WineType to fetch.
     * 
    **/
    where?: WineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<WineTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WineTypes.
     * 
    **/
    cursor?: WineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WineTypes.
     * 
    **/
    distinct?: Enumerable<WineTypeScalarFieldEnum>
  }

  /**
   * WineType: findFirst
   */
  export interface WineTypeFindFirstArgs extends WineTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WineType findMany
   */
  export type WineTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter, which WineTypes to fetch.
     * 
    **/
    where?: WineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<WineTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WineTypes.
     * 
    **/
    cursor?: WineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WineTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WineTypeScalarFieldEnum>
  }


  /**
   * WineType create
   */
  export type WineTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * The data needed to create a WineType.
     * 
    **/
    data: XOR<WineTypeCreateInput, WineTypeUncheckedCreateInput>
  }


  /**
   * WineType createMany
   */
  export type WineTypeCreateManyArgs = {
    /**
     * The data used to create many WineTypes.
     * 
    **/
    data: Enumerable<WineTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WineType update
   */
  export type WineTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * The data needed to update a WineType.
     * 
    **/
    data: XOR<WineTypeUpdateInput, WineTypeUncheckedUpdateInput>
    /**
     * Choose, which WineType to update.
     * 
    **/
    where: WineTypeWhereUniqueInput
  }


  /**
   * WineType updateMany
   */
  export type WineTypeUpdateManyArgs = {
    /**
     * The data used to update WineTypes.
     * 
    **/
    data: XOR<WineTypeUpdateManyMutationInput, WineTypeUncheckedUpdateManyInput>
    /**
     * Filter which WineTypes to update
     * 
    **/
    where?: WineTypeWhereInput
  }


  /**
   * WineType upsert
   */
  export type WineTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * The filter to search for the WineType to update in case it exists.
     * 
    **/
    where: WineTypeWhereUniqueInput
    /**
     * In case the WineType found by the `where` argument doesn't exist, create a new WineType with this data.
     * 
    **/
    create: XOR<WineTypeCreateInput, WineTypeUncheckedCreateInput>
    /**
     * In case the WineType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WineTypeUpdateInput, WineTypeUncheckedUpdateInput>
  }


  /**
   * WineType delete
   */
  export type WineTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
    /**
     * Filter which WineType to delete.
     * 
    **/
    where: WineTypeWhereUniqueInput
  }


  /**
   * WineType deleteMany
   */
  export type WineTypeDeleteManyArgs = {
    /**
     * Filter which WineTypes to delete
     * 
    **/
    where?: WineTypeWhereInput
  }


  /**
   * WineType: findUniqueOrThrow
   */
  export type WineTypeFindUniqueOrThrowArgs = WineTypeFindUniqueArgsBase
      

  /**
   * WineType: findFirstOrThrow
   */
  export type WineTypeFindFirstOrThrowArgs = WineTypeFindFirstArgsBase
      

  /**
   * WineType without action
   */
  export type WineTypeArgs = {
    /**
     * Select specific fields to fetch from the WineType
     * 
    **/
    select?: WineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineTypeInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    external_id: number | null
    total: number | null
  }

  export type OrderSumAggregateOutputType = {
    external_id: number | null
    total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    code: string | null
    account_id: string | null
    total: number | null
    coupon_id: string | null
    user_id: string | null
    user_address_id: string | null
    is_read: boolean | null
    order_status_id: string | null
    campaign_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    code: string | null
    account_id: string | null
    total: number | null
    coupon_id: string | null
    user_id: string | null
    user_address_id: string | null
    is_read: boolean | null
    order_status_id: string | null
    campaign_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    external_id: number
    code: number
    account_id: number
    total: number
    coupon_id: number
    user_id: number
    user_address_id: number
    is_read: number
    order_status_id: number
    campaign_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    external_id?: true
    total?: true
  }

  export type OrderSumAggregateInputType = {
    external_id?: true
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    external_id?: true
    code?: true
    account_id?: true
    total?: true
    coupon_id?: true
    user_id?: true
    user_address_id?: true
    is_read?: true
    order_status_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    external_id?: true
    code?: true
    account_id?: true
    total?: true
    coupon_id?: true
    user_id?: true
    user_address_id?: true
    is_read?: true
    order_status_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    external_id?: true
    code?: true
    account_id?: true
    total?: true
    coupon_id?: true
    user_id?: true
    user_address_id?: true
    is_read?: true
    order_status_id?: true
    campaign_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    external_id: number | null
    code: string
    account_id: string
    total: number
    coupon_id: string | null
    user_id: string
    user_address_id: string
    is_read: boolean
    order_status_id: string
    campaign_id: string | null
    created_at: Date
    updated_at: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    external_id?: boolean
    code?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    total?: boolean
    coupon_id?: boolean
    coupon?: boolean | CouponArgs
    user_id?: boolean
    user?: boolean | UserArgs
    user_address_id?: boolean
    user_address?: boolean | UserAddressArgs
    is_read?: boolean
    order_status_id?: boolean
    order_status?: boolean | OrderStatusArgs
    campaign_id?: boolean
    campaign?: boolean | CampaignArgs
    created_at?: boolean
    updated_at?: boolean
    order_items?: boolean | OrderItemFindManyArgs
    invoice?: boolean | InvoiceFindManyArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderInclude = {
    account?: boolean | AccountArgs
    coupon?: boolean | CouponArgs
    user?: boolean | UserArgs
    user_address?: boolean | UserAddressArgs
    order_status?: boolean | OrderStatusArgs
    campaign?: boolean | CampaignArgs
    order_items?: boolean | OrderItemFindManyArgs
    invoice?: boolean | InvoiceFindManyArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<
    S extends boolean | null | undefined | OrderArgs,
    U = keyof S
      > = S extends true
        ? Order
    : S extends undefined
    ? never
    : S extends OrderArgs | OrderFindManyArgs
    ?'include' extends U
    ? Order  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'coupon' ? CouponGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user_address' ? UserAddressGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'order_status' ? OrderStatusGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'campaign' ? CampaignGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'order_items' ? Array < OrderItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'invoice' ? Array < InvoiceGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'coupon' ? CouponGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user_address' ? UserAddressGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'order_status' ? OrderStatusGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'campaign' ? CampaignGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'order_items' ? Array < OrderItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'invoice' ? Array < InvoiceGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Order ? Order[P] : never
  } 
    : Order
  : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null, null>, Prisma__OrderClient<OrderGetPayload<T> | null, null>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null, null>, Prisma__OrderClient<OrderGetPayload<T> | null, null>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Find one Order that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    coupon<T extends CouponArgs = {}>(args?: Subset<T, CouponArgs>): CheckSelect<T, Prisma__CouponClient<Coupon | Null>, Prisma__CouponClient<CouponGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    user_address<T extends UserAddressArgs = {}>(args?: Subset<T, UserAddressArgs>): CheckSelect<T, Prisma__UserAddressClient<UserAddress | Null>, Prisma__UserAddressClient<UserAddressGetPayload<T> | Null>>;

    order_status<T extends OrderStatusArgs = {}>(args?: Subset<T, OrderStatusArgs>): CheckSelect<T, Prisma__OrderStatusClient<OrderStatus | Null>, Prisma__OrderStatusClient<OrderStatusGetPayload<T> | Null>>;

    campaign<T extends CampaignArgs = {}>(args?: Subset<T, CampaignArgs>): CheckSelect<T, Prisma__CampaignClient<Campaign | Null>, Prisma__CampaignClient<CampaignGetPayload<T> | Null>>;

    order_items<T extends OrderItemFindManyArgs = {}>(args?: Subset<T, OrderItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderItem>| Null>, PrismaPromise<Array<OrderItemGetPayload<T>>| Null>>;

    invoice<T extends InvoiceFindManyArgs = {}>(args?: Subset<T, InvoiceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Invoice>| Null>, PrismaPromise<Array<InvoiceGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }

  /**
   * Order: findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order: findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order: findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = OrderFindUniqueArgsBase
      

  /**
   * Order: findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = OrderFindFirstArgsBase
      

  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model OrderStatus
   */


  export type AggregateOrderStatus = {
    _count: OrderStatusCountAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  export type OrderStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderStatusCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OrderStatusMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderStatusMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderStatusCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OrderStatusAggregateArgs = {
    /**
     * Filter which OrderStatus to aggregate.
     * 
    **/
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderStatuses
    **/
    _count?: true | OrderStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStatusMaxAggregateInputType
  }

  export type GetOrderStatusAggregateType<T extends OrderStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStatus[P]>
      : GetScalarType<T[P], AggregateOrderStatus[P]>
  }




  export type OrderStatusGroupByArgs = {
    where?: OrderStatusWhereInput
    orderBy?: Enumerable<OrderStatusOrderByWithAggregationInput>
    by: Array<OrderStatusScalarFieldEnum>
    having?: OrderStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStatusCountAggregateInputType | true
    _min?: OrderStatusMinAggregateInputType
    _max?: OrderStatusMaxAggregateInputType
  }


  export type OrderStatusGroupByOutputType = {
    id: string
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: OrderStatusCountAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  type GetOrderStatusGroupByPayload<T extends OrderStatusGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
        }
      >
    >


  export type OrderStatusSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    orders?: boolean | OrderFindManyArgs
    _count?: boolean | OrderStatusCountOutputTypeArgs
  }

  export type OrderStatusInclude = {
    orders?: boolean | OrderFindManyArgs
    _count?: boolean | OrderStatusCountOutputTypeArgs
  }

  export type OrderStatusGetPayload<
    S extends boolean | null | undefined | OrderStatusArgs,
    U = keyof S
      > = S extends true
        ? OrderStatus
    : S extends undefined
    ? never
    : S extends OrderStatusArgs | OrderStatusFindManyArgs
    ?'include' extends U
    ? OrderStatus  & {
    [P in TrueKeys<S['include']>]:
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OrderStatusCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'orders' ? Array < OrderGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OrderStatusCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OrderStatus ? OrderStatus[P] : never
  } 
    : OrderStatus
  : OrderStatus


  type OrderStatusCountArgs = Merge<
    Omit<OrderStatusFindManyArgs, 'select' | 'include'> & {
      select?: OrderStatusCountAggregateInputType | true
    }
  >

  export interface OrderStatusDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OrderStatus that matches the filter.
     * @param {OrderStatusFindUniqueArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderStatus'> extends True ? CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>> : CheckSelect<T, Prisma__OrderStatusClient<OrderStatus | null, null>, Prisma__OrderStatusClient<OrderStatusGetPayload<T> | null, null>>

    /**
     * Find the first OrderStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderStatus'> extends True ? CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>> : CheckSelect<T, Prisma__OrderStatusClient<OrderStatus | null, null>, Prisma__OrderStatusClient<OrderStatusGetPayload<T> | null, null>>

    /**
     * Find zero or more OrderStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany()
     * 
     * // Get first 10 OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderStatusWithIdOnly = await prisma.orderStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderStatusFindManyArgs>(
      args?: SelectSubset<T, OrderStatusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderStatus>>, PrismaPromise<Array<OrderStatusGetPayload<T>>>>

    /**
     * Create a OrderStatus.
     * @param {OrderStatusCreateArgs} args - Arguments to create a OrderStatus.
     * @example
     * // Create one OrderStatus
     * const OrderStatus = await prisma.orderStatus.create({
     *   data: {
     *     // ... data to create a OrderStatus
     *   }
     * })
     * 
    **/
    create<T extends OrderStatusCreateArgs>(
      args: SelectSubset<T, OrderStatusCreateArgs>
    ): CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>>

    /**
     * Create many OrderStatuses.
     *     @param {OrderStatusCreateManyArgs} args - Arguments to create many OrderStatuses.
     *     @example
     *     // Create many OrderStatuses
     *     const orderStatus = await prisma.orderStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderStatusCreateManyArgs>(
      args?: SelectSubset<T, OrderStatusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderStatus.
     * @param {OrderStatusDeleteArgs} args - Arguments to delete one OrderStatus.
     * @example
     * // Delete one OrderStatus
     * const OrderStatus = await prisma.orderStatus.delete({
     *   where: {
     *     // ... filter to delete one OrderStatus
     *   }
     * })
     * 
    **/
    delete<T extends OrderStatusDeleteArgs>(
      args: SelectSubset<T, OrderStatusDeleteArgs>
    ): CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>>

    /**
     * Update one OrderStatus.
     * @param {OrderStatusUpdateArgs} args - Arguments to update one OrderStatus.
     * @example
     * // Update one OrderStatus
     * const orderStatus = await prisma.orderStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderStatusUpdateArgs>(
      args: SelectSubset<T, OrderStatusUpdateArgs>
    ): CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>>

    /**
     * Delete zero or more OrderStatuses.
     * @param {OrderStatusDeleteManyArgs} args - Arguments to filter OrderStatuses to delete.
     * @example
     * // Delete a few OrderStatuses
     * const { count } = await prisma.orderStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderStatusDeleteManyArgs>(
      args?: SelectSubset<T, OrderStatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderStatuses
     * const orderStatus = await prisma.orderStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderStatusUpdateManyArgs>(
      args: SelectSubset<T, OrderStatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderStatus.
     * @param {OrderStatusUpsertArgs} args - Arguments to update or create a OrderStatus.
     * @example
     * // Update or create a OrderStatus
     * const orderStatus = await prisma.orderStatus.upsert({
     *   create: {
     *     // ... data to create a OrderStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStatus we want to update
     *   }
     * })
    **/
    upsert<T extends OrderStatusUpsertArgs>(
      args: SelectSubset<T, OrderStatusUpsertArgs>
    ): CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>>

    /**
     * Find one OrderStatus that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrderStatusFindUniqueOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderStatusFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderStatusFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>>

    /**
     * Find the first OrderStatus that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderStatusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderStatusFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderStatusClient<OrderStatus>, Prisma__OrderStatusClient<OrderStatusGetPayload<T>>>

    /**
     * Count the number of OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusCountArgs} args - Arguments to filter OrderStatuses to count.
     * @example
     * // Count the number of OrderStatuses
     * const count = await prisma.orderStatus.count({
     *   where: {
     *     // ... the filter for the OrderStatuses we want to count
     *   }
     * })
    **/
    count<T extends OrderStatusCountArgs>(
      args?: Subset<T, OrderStatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStatusAggregateArgs>(args: Subset<T, OrderStatusAggregateArgs>): PrismaPromise<GetOrderStatusAggregateType<T>>

    /**
     * Group by OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStatusGroupByArgs['orderBy'] }
        : { orderBy?: OrderStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStatusGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderStatusClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>| Null>, PrismaPromise<Array<OrderGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrderStatus base type for findUnique actions
   */
  export type OrderStatusFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
    /**
     * Filter, which OrderStatus to fetch.
     * 
    **/
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus: findUnique
   */
  export interface OrderStatusFindUniqueArgs extends OrderStatusFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderStatus base type for findFirst actions
   */
  export type OrderStatusFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
    /**
     * Filter, which OrderStatus to fetch.
     * 
    **/
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     * 
    **/
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     * 
    **/
    distinct?: Enumerable<OrderStatusScalarFieldEnum>
  }

  /**
   * OrderStatus: findFirst
   */
  export interface OrderStatusFindFirstArgs extends OrderStatusFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderStatus findMany
   */
  export type OrderStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
    /**
     * Filter, which OrderStatuses to fetch.
     * 
    **/
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderStatuses.
     * 
    **/
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderStatusScalarFieldEnum>
  }


  /**
   * OrderStatus create
   */
  export type OrderStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
    /**
     * The data needed to create a OrderStatus.
     * 
    **/
    data: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
  }


  /**
   * OrderStatus createMany
   */
  export type OrderStatusCreateManyArgs = {
    /**
     * The data used to create many OrderStatuses.
     * 
    **/
    data: Enumerable<OrderStatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderStatus update
   */
  export type OrderStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
    /**
     * The data needed to update a OrderStatus.
     * 
    **/
    data: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
    /**
     * Choose, which OrderStatus to update.
     * 
    **/
    where: OrderStatusWhereUniqueInput
  }


  /**
   * OrderStatus updateMany
   */
  export type OrderStatusUpdateManyArgs = {
    /**
     * The data used to update OrderStatuses.
     * 
    **/
    data: XOR<OrderStatusUpdateManyMutationInput, OrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatuses to update
     * 
    **/
    where?: OrderStatusWhereInput
  }


  /**
   * OrderStatus upsert
   */
  export type OrderStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
    /**
     * The filter to search for the OrderStatus to update in case it exists.
     * 
    **/
    where: OrderStatusWhereUniqueInput
    /**
     * In case the OrderStatus found by the `where` argument doesn't exist, create a new OrderStatus with this data.
     * 
    **/
    create: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
    /**
     * In case the OrderStatus was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
  }


  /**
   * OrderStatus delete
   */
  export type OrderStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
    /**
     * Filter which OrderStatus to delete.
     * 
    **/
    where: OrderStatusWhereUniqueInput
  }


  /**
   * OrderStatus deleteMany
   */
  export type OrderStatusDeleteManyArgs = {
    /**
     * Filter which OrderStatuses to delete
     * 
    **/
    where?: OrderStatusWhereInput
  }


  /**
   * OrderStatus: findUniqueOrThrow
   */
  export type OrderStatusFindUniqueOrThrowArgs = OrderStatusFindUniqueArgsBase
      

  /**
   * OrderStatus: findFirstOrThrow
   */
  export type OrderStatusFindFirstOrThrowArgs = OrderStatusFindFirstArgsBase
      

  /**
   * OrderStatus without action
   */
  export type OrderStatusArgs = {
    /**
     * Select specific fields to fetch from the OrderStatus
     * 
    **/
    select?: OrderStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderStatusInclude | null
  }



  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    email: string | null
    mobile_phone: string | null
    phone: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    origin_registration: CustomerOriginRegistration | null
    cpf_cnpj: string | null
    note: string | null
    converted: boolean | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    email: string | null
    mobile_phone: string | null
    phone: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    origin_registration: CustomerOriginRegistration | null
    cpf_cnpj: string | null
    note: string | null
    converted: boolean | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    account_id: number
    email: number
    mobile_phone: number
    phone: number
    is_active: number
    created_at: number
    updated_at: number
    origin_registration: number
    cpf_cnpj: number
    note: number
    converted: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    account_id?: true
    email?: true
    mobile_phone?: true
    phone?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    origin_registration?: true
    cpf_cnpj?: true
    note?: true
    converted?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    account_id?: true
    email?: true
    mobile_phone?: true
    phone?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    origin_registration?: true
    cpf_cnpj?: true
    note?: true
    converted?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    account_id?: true
    email?: true
    mobile_phone?: true
    phone?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    origin_registration?: true
    cpf_cnpj?: true
    note?: true
    converted?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: Array<CustomerScalarFieldEnum>
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: string
    account_id: string
    email: string
    mobile_phone: string
    phone: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    origin_registration: CustomerOriginRegistration
    cpf_cnpj: string
    note: string
    converted: boolean
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    id?: boolean
    account_id?: boolean
    account?: boolean | AccountArgs
    email?: boolean
    mobile_phone?: boolean
    phone?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    origin_registration?: boolean
    cpf_cnpj?: boolean
    note?: boolean
    converted?: boolean
  }

  export type CustomerInclude = {
    account?: boolean | AccountArgs
  }

  export type CustomerGetPayload<
    S extends boolean | null | undefined | CustomerArgs,
    U = keyof S
      > = S extends true
        ? Customer
    : S extends undefined
    ? never
    : S extends CustomerArgs | CustomerFindManyArgs
    ?'include' extends U
    ? Customer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Customer ? Customer[P] : never
  } 
    : Customer
  : Customer


  type CustomerCountArgs = Merge<
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }
  >

  export interface CustomerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null, null>, Prisma__CustomerClient<CustomerGetPayload<T> | null, null>>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null, null>, Prisma__CustomerClient<CustomerGetPayload<T> | null, null>>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Customer>>, PrismaPromise<Array<CustomerGetPayload<T>>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Find one Customer that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customer base type for findUnique actions
   */
  export type CustomerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer: findUnique
   */
  export interface CustomerFindUniqueArgs extends CustomerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer base type for findFirst actions
   */
  export type CustomerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * Customer: findFirst
   */
  export interface CustomerFindFirstArgs extends CustomerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to create a Customer.
     * 
    **/
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    /**
     * The data used to create many Customers.
     * 
    **/
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to update a Customer.
     * 
    **/
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    /**
     * The data used to update Customers.
     * 
    **/
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The filter to search for the Customer to update in case it exists.
     * 
    **/
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     * 
    **/
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter which Customer to delete.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer: findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs = CustomerFindUniqueArgsBase
      

  /**
   * Customer: findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs = CustomerFindFirstArgsBase
      

  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
  }



  /**
   * Model OrderItem
   */


  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    order_id: string | null
    item_id: string | null
    created_at: Date | null
    updated_at: Date | null
    price: number | null
    quantity: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    order_id: string | null
    item_id: string | null
    created_at: Date | null
    updated_at: Date | null
    price: number | null
    quantity: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    order_id: number
    item_id: number
    created_at: number
    updated_at: number
    price: number
    quantity: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type OrderItemSumAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type OrderItemMinAggregateInputType = {
    order_id?: true
    item_id?: true
    created_at?: true
    updated_at?: true
    price?: true
    quantity?: true
  }

  export type OrderItemMaxAggregateInputType = {
    order_id?: true
    item_id?: true
    created_at?: true
    updated_at?: true
    price?: true
    quantity?: true
  }

  export type OrderItemCountAggregateInputType = {
    order_id?: true
    item_id?: true
    created_at?: true
    updated_at?: true
    price?: true
    quantity?: true
    _all?: true
  }

  export type OrderItemAggregateArgs = {
    /**
     * Filter which OrderItem to aggregate.
     * 
    **/
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs = {
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByWithAggregationInput>
    by: Array<OrderItemScalarFieldEnum>
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }


  export type OrderItemGroupByOutputType = {
    order_id: string
    item_id: string
    created_at: Date
    updated_at: Date
    price: number
    quantity: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect = {
    order_id?: boolean
    order?: boolean | OrderArgs
    item_id?: boolean
    item?: boolean | ItemArgs
    created_at?: boolean
    updated_at?: boolean
    price?: boolean
    quantity?: boolean
  }

  export type OrderItemInclude = {
    order?: boolean | OrderArgs
    item?: boolean | ItemArgs
  }

  export type OrderItemGetPayload<
    S extends boolean | null | undefined | OrderItemArgs,
    U = keyof S
      > = S extends true
        ? OrderItem
    : S extends undefined
    ? never
    : S extends OrderItemArgs | OrderItemFindManyArgs
    ?'include' extends U
    ? OrderItem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'item' ? ItemGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'item' ? ItemGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof OrderItem ? OrderItem[P] : never
  } 
    : OrderItem
  : OrderItem


  type OrderItemCountArgs = Merge<
    Omit<OrderItemFindManyArgs, 'select' | 'include'> & {
      select?: OrderItemCountAggregateInputType | true
    }
  >

  export interface OrderItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderItem'> extends True ? CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>> : CheckSelect<T, Prisma__OrderItemClient<OrderItem | null, null>, Prisma__OrderItemClient<OrderItemGetPayload<T> | null, null>>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderItem'> extends True ? CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>> : CheckSelect<T, Prisma__OrderItemClient<OrderItem | null, null>, Prisma__OrderItemClient<OrderItemGetPayload<T> | null, null>>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const orderItemWithOrder_idOnly = await prisma.orderItem.findMany({ select: { order_id: true } })
     * 
    **/
    findMany<T extends OrderItemFindManyArgs>(
      args?: SelectSubset<T, OrderItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderItem>>, PrismaPromise<Array<OrderItemGetPayload<T>>>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
    **/
    create<T extends OrderItemCreateArgs>(
      args: SelectSubset<T, OrderItemCreateArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Create many OrderItems.
     *     @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     *     @example
     *     // Create many OrderItems
     *     const orderItem = await prisma.orderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderItemCreateManyArgs>(
      args?: SelectSubset<T, OrderItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
    **/
    delete<T extends OrderItemDeleteArgs>(
      args: SelectSubset<T, OrderItemDeleteArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderItemUpdateArgs>(
      args: SelectSubset<T, OrderItemUpdateArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderItemDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderItemUpdateManyArgs>(
      args: SelectSubset<T, OrderItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends OrderItemUpsertArgs>(
      args: SelectSubset<T, OrderItemUpsertArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Find one OrderItem that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderItemClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | Null>, Prisma__OrderClient<OrderGetPayload<T> | Null>>;

    item<T extends ItemArgs = {}>(args?: Subset<T, ItemArgs>): CheckSelect<T, Prisma__ItemClient<Item | Null>, Prisma__ItemClient<ItemGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OrderItem base type for findUnique actions
   */
  export type OrderItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     * 
    **/
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem: findUnique
   */
  export interface OrderItemFindUniqueArgs extends OrderItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderItem base type for findFirst actions
   */
  export type OrderItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItem to fetch.
     * 
    **/
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     * 
    **/
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     * 
    **/
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }

  /**
   * OrderItem: findFirst
   */
  export interface OrderItemFindFirstArgs extends OrderItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItems to fetch.
     * 
    **/
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     * 
    **/
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * The data needed to create a OrderItem.
     * 
    **/
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }


  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs = {
    /**
     * The data used to create many OrderItems.
     * 
    **/
    data: Enumerable<OrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * The data needed to update a OrderItem.
     * 
    **/
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     * 
    **/
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs = {
    /**
     * The data used to update OrderItems.
     * 
    **/
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     * 
    **/
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     * 
    **/
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     * 
    **/
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }


  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Filter which OrderItem to delete.
     * 
    **/
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs = {
    /**
     * Filter which OrderItems to delete
     * 
    **/
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem: findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs = OrderItemFindUniqueArgsBase
      

  /**
   * OrderItem: findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs = OrderItemFindFirstArgsBase
      

  /**
   * OrderItem without action
   */
  export type OrderItemArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
  }



  /**
   * Model Invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    account_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    account_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    order_id: number
    account_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvoiceMinAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvoiceAggregateArgs = {
    /**
     * Filter which Invoice to aggregate.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs = {
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithAggregationInput>
    by: Array<InvoiceScalarFieldEnum>
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    order_id: string
    account_id: string
    created_at: Date
    updated_at: Date
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect = {
    id?: boolean
    order_id?: boolean
    order?: boolean | OrderArgs
    account_id?: boolean
    account?: boolean | AccountArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type InvoiceInclude = {
    order?: boolean | OrderArgs
    account?: boolean | AccountArgs
  }

  export type InvoiceGetPayload<
    S extends boolean | null | undefined | InvoiceArgs,
    U = keyof S
      > = S extends true
        ? Invoice
    : S extends undefined
    ? never
    : S extends InvoiceArgs | InvoiceFindManyArgs
    ?'include' extends U
    ? Invoice  & {
    [P in TrueKeys<S['include']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'order' ? OrderGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Invoice ? Invoice[P] : never
  } 
    : Invoice
  : Invoice


  type InvoiceCountArgs = Merge<
    Omit<InvoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }
  >

  export interface InvoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invoice'> extends True ? CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceClient<Invoice | null, null>, Prisma__InvoiceClient<InvoiceGetPayload<T> | null, null>>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invoice'> extends True ? CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceClient<Invoice | null, null>, Prisma__InvoiceClient<InvoiceGetPayload<T> | null, null>>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs>(
      args?: SelectSubset<T, InvoiceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Invoice>>, PrismaPromise<Array<InvoiceGetPayload<T>>>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs>(
      args: SelectSubset<T, InvoiceCreateArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs>(
      args?: SelectSubset<T, InvoiceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs>(
      args: SelectSubset<T, InvoiceDeleteArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs>(
      args: SelectSubset<T, InvoiceUpdateArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs>(
      args: SelectSubset<T, InvoiceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs>(
      args: SelectSubset<T, InvoiceUpsertArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Find one Invoice that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InvoiceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Find the first Invoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | Null>, Prisma__OrderClient<OrderGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invoice base type for findUnique actions
   */
  export type InvoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter, which Invoice to fetch.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice: findUnique
   */
  export interface InvoiceFindUniqueArgs extends InvoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice base type for findFirst actions
   */
  export type InvoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter, which Invoice to fetch.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     * 
    **/
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }

  /**
   * Invoice: findFirst
   */
  export interface InvoiceFindFirstArgs extends InvoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter, which Invoices to fetch.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The data needed to create a Invoice.
     * 
    **/
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs = {
    /**
     * The data used to create many Invoices.
     * 
    **/
    data: Enumerable<InvoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The data needed to update a Invoice.
     * 
    **/
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs = {
    /**
     * The data used to update Invoices.
     * 
    **/
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     * 
    **/
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     * 
    **/
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     * 
    **/
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter which Invoice to delete.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs = {
    /**
     * Filter which Invoices to delete
     * 
    **/
    where?: InvoiceWhereInput
  }


  /**
   * Invoice: findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs = InvoiceFindUniqueArgsBase
      

  /**
   * Invoice: findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs = InvoiceFindFirstArgsBase
      

  /**
   * Invoice without action
   */
  export type InvoiceArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
  }



  /**
   * Model Device
   */


  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    external_id: number | null
  }

  export type DeviceSumAggregateOutputType = {
    external_id: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    device_physical_id: string | null
    platform: PlatformType | null
    version: string | null
    token_notification: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    device_physical_id: string | null
    platform: PlatformType | null
    version: string | null
    token_notification: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    external_id: number
    device_physical_id: number
    platform: number
    version: number
    token_notification: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    external_id?: true
  }

  export type DeviceSumAggregateInputType = {
    external_id?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    external_id?: true
    device_physical_id?: true
    platform?: true
    version?: true
    token_notification?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    external_id?: true
    device_physical_id?: true
    platform?: true
    version?: true
    token_notification?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    external_id?: true
    device_physical_id?: true
    platform?: true
    version?: true
    token_notification?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeviceAggregateArgs = {
    /**
     * Filter which Device to aggregate.
     * 
    **/
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs = {
    where?: DeviceWhereInput
    orderBy?: Enumerable<DeviceOrderByWithAggregationInput>
    by: Array<DeviceScalarFieldEnum>
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }


  export type DeviceGroupByOutputType = {
    id: string
    external_id: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at: Date
    updated_at: Date
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect = {
    id?: boolean
    external_id?: boolean
    device_physical_id?: boolean
    platform?: boolean
    version?: boolean
    token_notification?: boolean
    created_at?: boolean
    updated_at?: boolean
    device_user?: boolean | DeviceUserFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    sms_notification?: boolean | SmsNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | DeviceCountOutputTypeArgs
  }

  export type DeviceInclude = {
    device_user?: boolean | DeviceUserFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    sms_notification?: boolean | SmsNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | DeviceCountOutputTypeArgs
  }

  export type DeviceGetPayload<
    S extends boolean | null | undefined | DeviceArgs,
    U = keyof S
      > = S extends true
        ? Device
    : S extends undefined
    ? never
    : S extends DeviceArgs | DeviceFindManyArgs
    ?'include' extends U
    ? Device  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? DeviceCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device_user' ? Array < DeviceUserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? DeviceCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Device ? Device[P] : never
  } 
    : Device
  : Device


  type DeviceCountArgs = Merge<
    Omit<DeviceFindManyArgs, 'select' | 'include'> & {
      select?: DeviceCountAggregateInputType | true
    }
  >

  export interface DeviceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeviceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Device'> extends True ? CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>> : CheckSelect<T, Prisma__DeviceClient<Device | null, null>, Prisma__DeviceClient<DeviceGetPayload<T> | null, null>>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeviceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Device'> extends True ? CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>> : CheckSelect<T, Prisma__DeviceClient<Device | null, null>, Prisma__DeviceClient<DeviceGetPayload<T> | null, null>>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeviceFindManyArgs>(
      args?: SelectSubset<T, DeviceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Device>>, PrismaPromise<Array<DeviceGetPayload<T>>>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
    **/
    create<T extends DeviceCreateArgs>(
      args: SelectSubset<T, DeviceCreateArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Create many Devices.
     *     @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     *     @example
     *     // Create many Devices
     *     const device = await prisma.device.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeviceCreateManyArgs>(
      args?: SelectSubset<T, DeviceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
    **/
    delete<T extends DeviceDeleteArgs>(
      args: SelectSubset<T, DeviceDeleteArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceUpdateArgs>(
      args: SelectSubset<T, DeviceUpdateArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceDeleteManyArgs>(
      args?: SelectSubset<T, DeviceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceUpdateManyArgs>(
      args: SelectSubset<T, DeviceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceUpsertArgs>(
      args: SelectSubset<T, DeviceUpsertArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Find one Device that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeviceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Find the first Device that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeviceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceClient<Device>, Prisma__DeviceClient<DeviceGetPayload<T>>>

    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeviceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device_user<T extends DeviceUserFindManyArgs = {}>(args?: Subset<T, DeviceUserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceUser>| Null>, PrismaPromise<Array<DeviceUserGetPayload<T>>| Null>>;

    push_notification<T extends PushNotificationFindManyArgs = {}>(args?: Subset<T, PushNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PushNotification>| Null>, PrismaPromise<Array<PushNotificationGetPayload<T>>| Null>>;

    sms_notification<T extends SmsNotificationFindManyArgs = {}>(args?: Subset<T, SmsNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SmsNotification>| Null>, PrismaPromise<Array<SmsNotificationGetPayload<T>>| Null>>;

    device_notification<T extends DeviceNotificationFindManyArgs = {}>(args?: Subset<T, DeviceNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceNotification>| Null>, PrismaPromise<Array<DeviceNotificationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Device base type for findUnique actions
   */
  export type DeviceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     * 
    **/
    where: DeviceWhereUniqueInput
  }

  /**
   * Device: findUnique
   */
  export interface DeviceFindUniqueArgs extends DeviceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Device base type for findFirst actions
   */
  export type DeviceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     * 
    **/
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     * 
    **/
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     * 
    **/
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }

  /**
   * Device: findFirst
   */
  export interface DeviceFindFirstArgs extends DeviceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter, which Devices to fetch.
     * 
    **/
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     * 
    **/
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }


  /**
   * Device create
   */
  export type DeviceCreateArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * The data needed to create a Device.
     * 
    **/
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }


  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs = {
    /**
     * The data used to create many Devices.
     * 
    **/
    data: Enumerable<DeviceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Device update
   */
  export type DeviceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * The data needed to update a Device.
     * 
    **/
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     * 
    **/
    where: DeviceWhereUniqueInput
  }


  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs = {
    /**
     * The data used to update Devices.
     * 
    **/
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     * 
    **/
    where?: DeviceWhereInput
  }


  /**
   * Device upsert
   */
  export type DeviceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * The filter to search for the Device to update in case it exists.
     * 
    **/
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     * 
    **/
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }


  /**
   * Device delete
   */
  export type DeviceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
    /**
     * Filter which Device to delete.
     * 
    **/
    where: DeviceWhereUniqueInput
  }


  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs = {
    /**
     * Filter which Devices to delete
     * 
    **/
    where?: DeviceWhereInput
  }


  /**
   * Device: findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs = DeviceFindUniqueArgsBase
      

  /**
   * Device: findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs = DeviceFindFirstArgsBase
      

  /**
   * Device without action
   */
  export type DeviceArgs = {
    /**
     * Select specific fields to fetch from the Device
     * 
    **/
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceInclude | null
  }



  /**
   * Model DeviceUser
   */


  export type AggregateDeviceUser = {
    _count: DeviceUserCountAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  export type DeviceUserMinAggregateOutputType = {
    device_id: string | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceUserMaxAggregateOutputType = {
    device_id: string | null
    user_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceUserCountAggregateOutputType = {
    device_id: number
    user_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeviceUserMinAggregateInputType = {
    device_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceUserMaxAggregateInputType = {
    device_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceUserCountAggregateInputType = {
    device_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeviceUserAggregateArgs = {
    /**
     * Filter which DeviceUser to aggregate.
     * 
    **/
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceUsers
    **/
    _count?: true | DeviceUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceUserMaxAggregateInputType
  }

  export type GetDeviceUserAggregateType<T extends DeviceUserAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceUser[P]>
      : GetScalarType<T[P], AggregateDeviceUser[P]>
  }




  export type DeviceUserGroupByArgs = {
    where?: DeviceUserWhereInput
    orderBy?: Enumerable<DeviceUserOrderByWithAggregationInput>
    by: Array<DeviceUserScalarFieldEnum>
    having?: DeviceUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceUserCountAggregateInputType | true
    _min?: DeviceUserMinAggregateInputType
    _max?: DeviceUserMaxAggregateInputType
  }


  export type DeviceUserGroupByOutputType = {
    device_id: string
    user_id: string
    created_at: Date
    updated_at: Date
    _count: DeviceUserCountAggregateOutputType | null
    _min: DeviceUserMinAggregateOutputType | null
    _max: DeviceUserMaxAggregateOutputType | null
  }

  type GetDeviceUserGroupByPayload<T extends DeviceUserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeviceUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceUserGroupByOutputType[P]>
        }
      >
    >


  export type DeviceUserSelect = {
    device_id?: boolean
    device?: boolean | DeviceArgs
    user_id?: boolean
    user?: boolean | UserArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type DeviceUserInclude = {
    device?: boolean | DeviceArgs
    user?: boolean | UserArgs
  }

  export type DeviceUserGetPayload<
    S extends boolean | null | undefined | DeviceUserArgs,
    U = keyof S
      > = S extends true
        ? DeviceUser
    : S extends undefined
    ? never
    : S extends DeviceUserArgs | DeviceUserFindManyArgs
    ?'include' extends U
    ? DeviceUser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof DeviceUser ? DeviceUser[P] : never
  } 
    : DeviceUser
  : DeviceUser


  type DeviceUserCountArgs = Merge<
    Omit<DeviceUserFindManyArgs, 'select' | 'include'> & {
      select?: DeviceUserCountAggregateInputType | true
    }
  >

  export interface DeviceUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DeviceUser that matches the filter.
     * @param {DeviceUserFindUniqueArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeviceUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeviceUser'> extends True ? CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>> : CheckSelect<T, Prisma__DeviceUserClient<DeviceUser | null, null>, Prisma__DeviceUserClient<DeviceUserGetPayload<T> | null, null>>

    /**
     * Find the first DeviceUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeviceUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeviceUser'> extends True ? CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>> : CheckSelect<T, Prisma__DeviceUserClient<DeviceUser | null, null>, Prisma__DeviceUserClient<DeviceUserGetPayload<T> | null, null>>

    /**
     * Find zero or more DeviceUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany()
     * 
     * // Get first 10 DeviceUsers
     * const deviceUsers = await prisma.deviceUser.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceUserWithDevice_idOnly = await prisma.deviceUser.findMany({ select: { device_id: true } })
     * 
    **/
    findMany<T extends DeviceUserFindManyArgs>(
      args?: SelectSubset<T, DeviceUserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DeviceUser>>, PrismaPromise<Array<DeviceUserGetPayload<T>>>>

    /**
     * Create a DeviceUser.
     * @param {DeviceUserCreateArgs} args - Arguments to create a DeviceUser.
     * @example
     * // Create one DeviceUser
     * const DeviceUser = await prisma.deviceUser.create({
     *   data: {
     *     // ... data to create a DeviceUser
     *   }
     * })
     * 
    **/
    create<T extends DeviceUserCreateArgs>(
      args: SelectSubset<T, DeviceUserCreateArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Create many DeviceUsers.
     *     @param {DeviceUserCreateManyArgs} args - Arguments to create many DeviceUsers.
     *     @example
     *     // Create many DeviceUsers
     *     const deviceUser = await prisma.deviceUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeviceUserCreateManyArgs>(
      args?: SelectSubset<T, DeviceUserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceUser.
     * @param {DeviceUserDeleteArgs} args - Arguments to delete one DeviceUser.
     * @example
     * // Delete one DeviceUser
     * const DeviceUser = await prisma.deviceUser.delete({
     *   where: {
     *     // ... filter to delete one DeviceUser
     *   }
     * })
     * 
    **/
    delete<T extends DeviceUserDeleteArgs>(
      args: SelectSubset<T, DeviceUserDeleteArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Update one DeviceUser.
     * @param {DeviceUserUpdateArgs} args - Arguments to update one DeviceUser.
     * @example
     * // Update one DeviceUser
     * const deviceUser = await prisma.deviceUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceUserUpdateArgs>(
      args: SelectSubset<T, DeviceUserUpdateArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Delete zero or more DeviceUsers.
     * @param {DeviceUserDeleteManyArgs} args - Arguments to filter DeviceUsers to delete.
     * @example
     * // Delete a few DeviceUsers
     * const { count } = await prisma.deviceUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceUserDeleteManyArgs>(
      args?: SelectSubset<T, DeviceUserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceUsers
     * const deviceUser = await prisma.deviceUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceUserUpdateManyArgs>(
      args: SelectSubset<T, DeviceUserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceUser.
     * @param {DeviceUserUpsertArgs} args - Arguments to update or create a DeviceUser.
     * @example
     * // Update or create a DeviceUser
     * const deviceUser = await prisma.deviceUser.upsert({
     *   create: {
     *     // ... data to create a DeviceUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceUser we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceUserUpsertArgs>(
      args: SelectSubset<T, DeviceUserUpsertArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Find one DeviceUser that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeviceUserFindUniqueOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeviceUserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Find the first DeviceUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserFindFirstOrThrowArgs} args - Arguments to find a DeviceUser
     * @example
     * // Get one DeviceUser
     * const deviceUser = await prisma.deviceUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeviceUserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceUserClient<DeviceUser>, Prisma__DeviceUserClient<DeviceUserGetPayload<T>>>

    /**
     * Count the number of DeviceUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserCountArgs} args - Arguments to filter DeviceUsers to count.
     * @example
     * // Count the number of DeviceUsers
     * const count = await prisma.deviceUser.count({
     *   where: {
     *     // ... the filter for the DeviceUsers we want to count
     *   }
     * })
    **/
    count<T extends DeviceUserCountArgs>(
      args?: Subset<T, DeviceUserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceUserAggregateArgs>(args: Subset<T, DeviceUserAggregateArgs>): PrismaPromise<GetDeviceUserAggregateType<T>>

    /**
     * Group by DeviceUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceUserGroupByArgs['orderBy'] }
        : { orderBy?: DeviceUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeviceUserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeviceUser base type for findUnique actions
   */
  export type DeviceUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter, which DeviceUser to fetch.
     * 
    **/
    where: DeviceUserWhereUniqueInput
  }

  /**
   * DeviceUser: findUnique
   */
  export interface DeviceUserFindUniqueArgs extends DeviceUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceUser base type for findFirst actions
   */
  export type DeviceUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter, which DeviceUser to fetch.
     * 
    **/
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceUsers.
     * 
    **/
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceUsers.
     * 
    **/
    distinct?: Enumerable<DeviceUserScalarFieldEnum>
  }

  /**
   * DeviceUser: findFirst
   */
  export interface DeviceUserFindFirstArgs extends DeviceUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceUser findMany
   */
  export type DeviceUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter, which DeviceUsers to fetch.
     * 
    **/
    where?: DeviceUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceUsers to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceUsers.
     * 
    **/
    cursor?: DeviceUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceUsers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceUsers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeviceUserScalarFieldEnum>
  }


  /**
   * DeviceUser create
   */
  export type DeviceUserCreateArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * The data needed to create a DeviceUser.
     * 
    **/
    data: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
  }


  /**
   * DeviceUser createMany
   */
  export type DeviceUserCreateManyArgs = {
    /**
     * The data used to create many DeviceUsers.
     * 
    **/
    data: Enumerable<DeviceUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeviceUser update
   */
  export type DeviceUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * The data needed to update a DeviceUser.
     * 
    **/
    data: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
    /**
     * Choose, which DeviceUser to update.
     * 
    **/
    where: DeviceUserWhereUniqueInput
  }


  /**
   * DeviceUser updateMany
   */
  export type DeviceUserUpdateManyArgs = {
    /**
     * The data used to update DeviceUsers.
     * 
    **/
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyInput>
    /**
     * Filter which DeviceUsers to update
     * 
    **/
    where?: DeviceUserWhereInput
  }


  /**
   * DeviceUser upsert
   */
  export type DeviceUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * The filter to search for the DeviceUser to update in case it exists.
     * 
    **/
    where: DeviceUserWhereUniqueInput
    /**
     * In case the DeviceUser found by the `where` argument doesn't exist, create a new DeviceUser with this data.
     * 
    **/
    create: XOR<DeviceUserCreateInput, DeviceUserUncheckedCreateInput>
    /**
     * In case the DeviceUser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeviceUserUpdateInput, DeviceUserUncheckedUpdateInput>
  }


  /**
   * DeviceUser delete
   */
  export type DeviceUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
    /**
     * Filter which DeviceUser to delete.
     * 
    **/
    where: DeviceUserWhereUniqueInput
  }


  /**
   * DeviceUser deleteMany
   */
  export type DeviceUserDeleteManyArgs = {
    /**
     * Filter which DeviceUsers to delete
     * 
    **/
    where?: DeviceUserWhereInput
  }


  /**
   * DeviceUser: findUniqueOrThrow
   */
  export type DeviceUserFindUniqueOrThrowArgs = DeviceUserFindUniqueArgsBase
      

  /**
   * DeviceUser: findFirstOrThrow
   */
  export type DeviceUserFindFirstOrThrowArgs = DeviceUserFindFirstArgsBase
      

  /**
   * DeviceUser without action
   */
  export type DeviceUserArgs = {
    /**
     * Select specific fields to fetch from the DeviceUser
     * 
    **/
    select?: DeviceUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceUserInclude | null
  }



  /**
   * Model Notifications
   */


  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    type: TypeNotification | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    type: TypeNotification | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    title: number
    message: number
    created_at: number
    updated_at: number
    type: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
    updated_at?: true
    type?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
    updated_at?: true
    type?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
    updated_at?: true
    type?: true
    _all?: true
  }

  export type NotificationsAggregateArgs = {
    /**
     * Filter which Notifications to aggregate.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs = {
    where?: NotificationsWhereInput
    orderBy?: Enumerable<NotificationsOrderByWithAggregationInput>
    by: Array<NotificationsScalarFieldEnum>
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }


  export type NotificationsGroupByOutputType = {
    id: string
    title: string
    message: string
    created_at: Date
    updated_at: Date
    type: TypeNotification
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect = {
    id?: boolean
    title?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    type?: boolean
    sms_notification?: boolean | SmsNotificationFindManyArgs
    email_notification?: boolean | EmailNotificationFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | NotificationsCountOutputTypeArgs
  }

  export type NotificationsInclude = {
    sms_notification?: boolean | SmsNotificationFindManyArgs
    email_notification?: boolean | EmailNotificationFindManyArgs
    push_notification?: boolean | PushNotificationFindManyArgs
    device_notification?: boolean | DeviceNotificationFindManyArgs
    _count?: boolean | NotificationsCountOutputTypeArgs
  }

  export type NotificationsGetPayload<
    S extends boolean | null | undefined | NotificationsArgs,
    U = keyof S
      > = S extends true
        ? Notifications
    : S extends undefined
    ? never
    : S extends NotificationsArgs | NotificationsFindManyArgs
    ?'include' extends U
    ? Notifications  & {
    [P in TrueKeys<S['include']>]:
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'email_notification' ? Array < EmailNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? NotificationsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'sms_notification' ? Array < SmsNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'email_notification' ? Array < EmailNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'push_notification' ? Array < PushNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'device_notification' ? Array < DeviceNotificationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? NotificationsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Notifications ? Notifications[P] : never
  } 
    : Notifications
  : Notifications


  type NotificationsCountArgs = Merge<
    Omit<NotificationsFindManyArgs, 'select' | 'include'> & {
      select?: NotificationsCountAggregateInputType | true
    }
  >

  export interface NotificationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notifications'> extends True ? CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>> : CheckSelect<T, Prisma__NotificationsClient<Notifications | null, null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | null, null>>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notifications'> extends True ? CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>> : CheckSelect<T, Prisma__NotificationsClient<Notifications | null, null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | null, null>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationsFindManyArgs>(
      args?: SelectSubset<T, NotificationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notifications>>, PrismaPromise<Array<NotificationsGetPayload<T>>>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
    **/
    create<T extends NotificationsCreateArgs>(
      args: SelectSubset<T, NotificationsCreateArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Create many Notifications.
     *     @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notifications = await prisma.notifications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationsCreateManyArgs>(
      args?: SelectSubset<T, NotificationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
    **/
    delete<T extends NotificationsDeleteArgs>(
      args: SelectSubset<T, NotificationsDeleteArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationsUpdateArgs>(
      args: SelectSubset<T, NotificationsUpdateArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationsDeleteManyArgs>(
      args?: SelectSubset<T, NotificationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationsUpdateManyArgs>(
      args: SelectSubset<T, NotificationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationsUpsertArgs>(
      args: SelectSubset<T, NotificationsUpsertArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Find one Notifications that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Find the first Notifications that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__NotificationsClient<Notifications>, Prisma__NotificationsClient<NotificationsGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sms_notification<T extends SmsNotificationFindManyArgs = {}>(args?: Subset<T, SmsNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SmsNotification>| Null>, PrismaPromise<Array<SmsNotificationGetPayload<T>>| Null>>;

    email_notification<T extends EmailNotificationFindManyArgs = {}>(args?: Subset<T, EmailNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EmailNotification>| Null>, PrismaPromise<Array<EmailNotificationGetPayload<T>>| Null>>;

    push_notification<T extends PushNotificationFindManyArgs = {}>(args?: Subset<T, PushNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PushNotification>| Null>, PrismaPromise<Array<PushNotificationGetPayload<T>>| Null>>;

    device_notification<T extends DeviceNotificationFindManyArgs = {}>(args?: Subset<T, DeviceNotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DeviceNotification>| Null>, PrismaPromise<Array<DeviceNotificationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notifications base type for findUnique actions
   */
  export type NotificationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications: findUnique
   */
  export interface NotificationsFindUniqueArgs extends NotificationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notifications base type for findFirst actions
   */
  export type NotificationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationsScalarFieldEnum>
  }

  /**
   * Notifications: findFirst
   */
  export interface NotificationsFindFirstArgs extends NotificationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationsScalarFieldEnum>
  }


  /**
   * Notifications create
   */
  export type NotificationsCreateArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The data needed to create a Notifications.
     * 
    **/
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }


  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     * 
    **/
    data: Enumerable<NotificationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The data needed to update a Notifications.
     * 
    **/
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     * 
    **/
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     * 
    **/
    where?: NotificationsWhereInput
  }


  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     * 
    **/
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     * 
    **/
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }


  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
    /**
     * Filter which Notifications to delete.
     * 
    **/
    where: NotificationsWhereUniqueInput
  }


  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     * 
    **/
    where?: NotificationsWhereInput
  }


  /**
   * Notifications: findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs = NotificationsFindUniqueArgsBase
      

  /**
   * Notifications: findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs = NotificationsFindFirstArgsBase
      

  /**
   * Notifications without action
   */
  export type NotificationsArgs = {
    /**
     * Select specific fields to fetch from the Notifications
     * 
    **/
    select?: NotificationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationsInclude | null
  }



  /**
   * Model EmailNotification
   */


  export type AggregateEmailNotification = {
    _count: EmailNotificationCountAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  export type EmailNotificationMinAggregateOutputType = {
    id: string | null
    notification_id: string | null
    to: string | null
    from: string | null
    from_name: string | null
    cc: string | null
    bcc: string | null
    type: EmailTypeNotification | null
    subject: string | null
    body: string | null
    url_callback: string | null
    opened: string | null
    clicked: string | null
    failed: string | null
    error_description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmailNotificationMaxAggregateOutputType = {
    id: string | null
    notification_id: string | null
    to: string | null
    from: string | null
    from_name: string | null
    cc: string | null
    bcc: string | null
    type: EmailTypeNotification | null
    subject: string | null
    body: string | null
    url_callback: string | null
    opened: string | null
    clicked: string | null
    failed: string | null
    error_description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmailNotificationCountAggregateOutputType = {
    id: number
    notification_id: number
    to: number
    from: number
    from_name: number
    cc: number
    bcc: number
    type: number
    subject: number
    body: number
    url_callback: number
    opened: number
    clicked: number
    failed: number
    error_description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EmailNotificationMinAggregateInputType = {
    id?: true
    notification_id?: true
    to?: true
    from?: true
    from_name?: true
    cc?: true
    bcc?: true
    type?: true
    subject?: true
    body?: true
    url_callback?: true
    opened?: true
    clicked?: true
    failed?: true
    error_description?: true
    created_at?: true
    updated_at?: true
  }

  export type EmailNotificationMaxAggregateInputType = {
    id?: true
    notification_id?: true
    to?: true
    from?: true
    from_name?: true
    cc?: true
    bcc?: true
    type?: true
    subject?: true
    body?: true
    url_callback?: true
    opened?: true
    clicked?: true
    failed?: true
    error_description?: true
    created_at?: true
    updated_at?: true
  }

  export type EmailNotificationCountAggregateInputType = {
    id?: true
    notification_id?: true
    to?: true
    from?: true
    from_name?: true
    cc?: true
    bcc?: true
    type?: true
    subject?: true
    body?: true
    url_callback?: true
    opened?: true
    clicked?: true
    failed?: true
    error_description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EmailNotificationAggregateArgs = {
    /**
     * Filter which EmailNotification to aggregate.
     * 
    **/
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<EmailNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailNotifications
    **/
    _count?: true | EmailNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type GetEmailNotificationAggregateType<T extends EmailNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailNotification[P]>
      : GetScalarType<T[P], AggregateEmailNotification[P]>
  }




  export type EmailNotificationGroupByArgs = {
    where?: EmailNotificationWhereInput
    orderBy?: Enumerable<EmailNotificationOrderByWithAggregationInput>
    by: Array<EmailNotificationScalarFieldEnum>
    having?: EmailNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailNotificationCountAggregateInputType | true
    _min?: EmailNotificationMinAggregateInputType
    _max?: EmailNotificationMaxAggregateInputType
  }


  export type EmailNotificationGroupByOutputType = {
    id: string
    notification_id: string
    to: string
    from: string
    from_name: string
    cc: string | null
    bcc: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened: string | null
    clicked: string | null
    failed: string | null
    error_description: string | null
    created_at: Date
    updated_at: Date
    _count: EmailNotificationCountAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  type GetEmailNotificationGroupByPayload<T extends EmailNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmailNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailNotificationSelect = {
    id?: boolean
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    to?: boolean
    from?: boolean
    from_name?: boolean
    cc?: boolean
    bcc?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    url_callback?: boolean
    opened?: boolean
    clicked?: boolean
    failed?: boolean
    error_description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type EmailNotificationInclude = {
    notification?: boolean | NotificationsArgs
  }

  export type EmailNotificationGetPayload<
    S extends boolean | null | undefined | EmailNotificationArgs,
    U = keyof S
      > = S extends true
        ? EmailNotification
    : S extends undefined
    ? never
    : S extends EmailNotificationArgs | EmailNotificationFindManyArgs
    ?'include' extends U
    ? EmailNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof EmailNotification ? EmailNotification[P] : never
  } 
    : EmailNotification
  : EmailNotification


  type EmailNotificationCountArgs = Merge<
    Omit<EmailNotificationFindManyArgs, 'select' | 'include'> & {
      select?: EmailNotificationCountAggregateInputType | true
    }
  >

  export interface EmailNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one EmailNotification that matches the filter.
     * @param {EmailNotificationFindUniqueArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmailNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EmailNotification'> extends True ? CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>> : CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification | null, null>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T> | null, null>>

    /**
     * Find the first EmailNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmailNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EmailNotification'> extends True ? CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>> : CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification | null, null>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more EmailNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany()
     * 
     * // Get first 10 EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailNotificationFindManyArgs>(
      args?: SelectSubset<T, EmailNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EmailNotification>>, PrismaPromise<Array<EmailNotificationGetPayload<T>>>>

    /**
     * Create a EmailNotification.
     * @param {EmailNotificationCreateArgs} args - Arguments to create a EmailNotification.
     * @example
     * // Create one EmailNotification
     * const EmailNotification = await prisma.emailNotification.create({
     *   data: {
     *     // ... data to create a EmailNotification
     *   }
     * })
     * 
    **/
    create<T extends EmailNotificationCreateArgs>(
      args: SelectSubset<T, EmailNotificationCreateArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Create many EmailNotifications.
     *     @param {EmailNotificationCreateManyArgs} args - Arguments to create many EmailNotifications.
     *     @example
     *     // Create many EmailNotifications
     *     const emailNotification = await prisma.emailNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailNotificationCreateManyArgs>(
      args?: SelectSubset<T, EmailNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EmailNotification.
     * @param {EmailNotificationDeleteArgs} args - Arguments to delete one EmailNotification.
     * @example
     * // Delete one EmailNotification
     * const EmailNotification = await prisma.emailNotification.delete({
     *   where: {
     *     // ... filter to delete one EmailNotification
     *   }
     * })
     * 
    **/
    delete<T extends EmailNotificationDeleteArgs>(
      args: SelectSubset<T, EmailNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Update one EmailNotification.
     * @param {EmailNotificationUpdateArgs} args - Arguments to update one EmailNotification.
     * @example
     * // Update one EmailNotification
     * const emailNotification = await prisma.emailNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailNotificationUpdateArgs>(
      args: SelectSubset<T, EmailNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Delete zero or more EmailNotifications.
     * @param {EmailNotificationDeleteManyArgs} args - Arguments to filter EmailNotifications to delete.
     * @example
     * // Delete a few EmailNotifications
     * const { count } = await prisma.emailNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailNotificationDeleteManyArgs>(
      args?: SelectSubset<T, EmailNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailNotifications
     * const emailNotification = await prisma.emailNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailNotificationUpdateManyArgs>(
      args: SelectSubset<T, EmailNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailNotification.
     * @param {EmailNotificationUpsertArgs} args - Arguments to update or create a EmailNotification.
     * @example
     * // Update or create a EmailNotification
     * const emailNotification = await prisma.emailNotification.upsert({
     *   create: {
     *     // ... data to create a EmailNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailNotification we want to update
     *   }
     * })
    **/
    upsert<T extends EmailNotificationUpsertArgs>(
      args: SelectSubset<T, EmailNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Find one EmailNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {EmailNotificationFindUniqueOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EmailNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Find the first EmailNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EmailNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__EmailNotificationClient<EmailNotification>, Prisma__EmailNotificationClient<EmailNotificationGetPayload<T>>>

    /**
     * Count the number of EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationCountArgs} args - Arguments to filter EmailNotifications to count.
     * @example
     * // Count the number of EmailNotifications
     * const count = await prisma.emailNotification.count({
     *   where: {
     *     // ... the filter for the EmailNotifications we want to count
     *   }
     * })
    **/
    count<T extends EmailNotificationCountArgs>(
      args?: Subset<T, EmailNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailNotificationAggregateArgs>(args: Subset<T, EmailNotificationAggregateArgs>): PrismaPromise<GetEmailNotificationAggregateType<T>>

    /**
     * Group by EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailNotificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmailNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EmailNotification base type for findUnique actions
   */
  export type EmailNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter, which EmailNotification to fetch.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification: findUnique
   */
  export interface EmailNotificationFindUniqueArgs extends EmailNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmailNotification base type for findFirst actions
   */
  export type EmailNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter, which EmailNotification to fetch.
     * 
    **/
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<EmailNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     * 
    **/
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     * 
    **/
    distinct?: Enumerable<EmailNotificationScalarFieldEnum>
  }

  /**
   * EmailNotification: findFirst
   */
  export interface EmailNotificationFindFirstArgs extends EmailNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmailNotification findMany
   */
  export type EmailNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter, which EmailNotifications to fetch.
     * 
    **/
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<EmailNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailNotifications.
     * 
    **/
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmailNotificationScalarFieldEnum>
  }


  /**
   * EmailNotification create
   */
  export type EmailNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * The data needed to create a EmailNotification.
     * 
    **/
    data: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
  }


  /**
   * EmailNotification createMany
   */
  export type EmailNotificationCreateManyArgs = {
    /**
     * The data used to create many EmailNotifications.
     * 
    **/
    data: Enumerable<EmailNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EmailNotification update
   */
  export type EmailNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * The data needed to update a EmailNotification.
     * 
    **/
    data: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
    /**
     * Choose, which EmailNotification to update.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
  }


  /**
   * EmailNotification updateMany
   */
  export type EmailNotificationUpdateManyArgs = {
    /**
     * The data used to update EmailNotifications.
     * 
    **/
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailNotifications to update
     * 
    **/
    where?: EmailNotificationWhereInput
  }


  /**
   * EmailNotification upsert
   */
  export type EmailNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * The filter to search for the EmailNotification to update in case it exists.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
    /**
     * In case the EmailNotification found by the `where` argument doesn't exist, create a new EmailNotification with this data.
     * 
    **/
    create: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
    /**
     * In case the EmailNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
  }


  /**
   * EmailNotification delete
   */
  export type EmailNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
    /**
     * Filter which EmailNotification to delete.
     * 
    **/
    where: EmailNotificationWhereUniqueInput
  }


  /**
   * EmailNotification deleteMany
   */
  export type EmailNotificationDeleteManyArgs = {
    /**
     * Filter which EmailNotifications to delete
     * 
    **/
    where?: EmailNotificationWhereInput
  }


  /**
   * EmailNotification: findUniqueOrThrow
   */
  export type EmailNotificationFindUniqueOrThrowArgs = EmailNotificationFindUniqueArgsBase
      

  /**
   * EmailNotification: findFirstOrThrow
   */
  export type EmailNotificationFindFirstOrThrowArgs = EmailNotificationFindFirstArgsBase
      

  /**
   * EmailNotification without action
   */
  export type EmailNotificationArgs = {
    /**
     * Select specific fields to fetch from the EmailNotification
     * 
    **/
    select?: EmailNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmailNotificationInclude | null
  }



  /**
   * Model SmsNotification
   */


  export type AggregateSmsNotification = {
    _count: SmsNotificationCountAggregateOutputType | null
    _min: SmsNotificationMinAggregateOutputType | null
    _max: SmsNotificationMaxAggregateOutputType | null
  }

  export type SmsNotificationMinAggregateOutputType = {
    id: string | null
    notification_id: string | null
    device_id: string | null
    to: string | null
    subject: string | null
    body: string | null
    send: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SmsNotificationMaxAggregateOutputType = {
    id: string | null
    notification_id: string | null
    device_id: string | null
    to: string | null
    subject: string | null
    body: string | null
    send: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SmsNotificationCountAggregateOutputType = {
    id: number
    notification_id: number
    device_id: number
    to: number
    subject: number
    body: number
    send: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SmsNotificationMinAggregateInputType = {
    id?: true
    notification_id?: true
    device_id?: true
    to?: true
    subject?: true
    body?: true
    send?: true
    created_at?: true
    updated_at?: true
  }

  export type SmsNotificationMaxAggregateInputType = {
    id?: true
    notification_id?: true
    device_id?: true
    to?: true
    subject?: true
    body?: true
    send?: true
    created_at?: true
    updated_at?: true
  }

  export type SmsNotificationCountAggregateInputType = {
    id?: true
    notification_id?: true
    device_id?: true
    to?: true
    subject?: true
    body?: true
    send?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SmsNotificationAggregateArgs = {
    /**
     * Filter which SmsNotification to aggregate.
     * 
    **/
    where?: SmsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<SmsNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SmsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmsNotifications
    **/
    _count?: true | SmsNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmsNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmsNotificationMaxAggregateInputType
  }

  export type GetSmsNotificationAggregateType<T extends SmsNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSmsNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmsNotification[P]>
      : GetScalarType<T[P], AggregateSmsNotification[P]>
  }




  export type SmsNotificationGroupByArgs = {
    where?: SmsNotificationWhereInput
    orderBy?: Enumerable<SmsNotificationOrderByWithAggregationInput>
    by: Array<SmsNotificationScalarFieldEnum>
    having?: SmsNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmsNotificationCountAggregateInputType | true
    _min?: SmsNotificationMinAggregateInputType
    _max?: SmsNotificationMaxAggregateInputType
  }


  export type SmsNotificationGroupByOutputType = {
    id: string
    notification_id: string
    device_id: string
    to: string
    subject: string
    body: string
    send: string | null
    created_at: Date
    updated_at: Date
    _count: SmsNotificationCountAggregateOutputType | null
    _min: SmsNotificationMinAggregateOutputType | null
    _max: SmsNotificationMaxAggregateOutputType | null
  }

  type GetSmsNotificationGroupByPayload<T extends SmsNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SmsNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmsNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmsNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], SmsNotificationGroupByOutputType[P]>
        }
      >
    >


  export type SmsNotificationSelect = {
    id?: boolean
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    device_id?: boolean
    device?: boolean | DeviceArgs
    to?: boolean
    subject?: boolean
    body?: boolean
    send?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SmsNotificationInclude = {
    notification?: boolean | NotificationsArgs
    device?: boolean | DeviceArgs
  }

  export type SmsNotificationGetPayload<
    S extends boolean | null | undefined | SmsNotificationArgs,
    U = keyof S
      > = S extends true
        ? SmsNotification
    : S extends undefined
    ? never
    : S extends SmsNotificationArgs | SmsNotificationFindManyArgs
    ?'include' extends U
    ? SmsNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SmsNotification ? SmsNotification[P] : never
  } 
    : SmsNotification
  : SmsNotification


  type SmsNotificationCountArgs = Merge<
    Omit<SmsNotificationFindManyArgs, 'select' | 'include'> & {
      select?: SmsNotificationCountAggregateInputType | true
    }
  >

  export interface SmsNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SmsNotification that matches the filter.
     * @param {SmsNotificationFindUniqueArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SmsNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SmsNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SmsNotification'> extends True ? CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>> : CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification | null, null>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T> | null, null>>

    /**
     * Find the first SmsNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationFindFirstArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SmsNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SmsNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SmsNotification'> extends True ? CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>> : CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification | null, null>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more SmsNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmsNotifications
     * const smsNotifications = await prisma.smsNotification.findMany()
     * 
     * // Get first 10 SmsNotifications
     * const smsNotifications = await prisma.smsNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smsNotificationWithIdOnly = await prisma.smsNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SmsNotificationFindManyArgs>(
      args?: SelectSubset<T, SmsNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SmsNotification>>, PrismaPromise<Array<SmsNotificationGetPayload<T>>>>

    /**
     * Create a SmsNotification.
     * @param {SmsNotificationCreateArgs} args - Arguments to create a SmsNotification.
     * @example
     * // Create one SmsNotification
     * const SmsNotification = await prisma.smsNotification.create({
     *   data: {
     *     // ... data to create a SmsNotification
     *   }
     * })
     * 
    **/
    create<T extends SmsNotificationCreateArgs>(
      args: SelectSubset<T, SmsNotificationCreateArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Create many SmsNotifications.
     *     @param {SmsNotificationCreateManyArgs} args - Arguments to create many SmsNotifications.
     *     @example
     *     // Create many SmsNotifications
     *     const smsNotification = await prisma.smsNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SmsNotificationCreateManyArgs>(
      args?: SelectSubset<T, SmsNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SmsNotification.
     * @param {SmsNotificationDeleteArgs} args - Arguments to delete one SmsNotification.
     * @example
     * // Delete one SmsNotification
     * const SmsNotification = await prisma.smsNotification.delete({
     *   where: {
     *     // ... filter to delete one SmsNotification
     *   }
     * })
     * 
    **/
    delete<T extends SmsNotificationDeleteArgs>(
      args: SelectSubset<T, SmsNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Update one SmsNotification.
     * @param {SmsNotificationUpdateArgs} args - Arguments to update one SmsNotification.
     * @example
     * // Update one SmsNotification
     * const smsNotification = await prisma.smsNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SmsNotificationUpdateArgs>(
      args: SelectSubset<T, SmsNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Delete zero or more SmsNotifications.
     * @param {SmsNotificationDeleteManyArgs} args - Arguments to filter SmsNotifications to delete.
     * @example
     * // Delete a few SmsNotifications
     * const { count } = await prisma.smsNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SmsNotificationDeleteManyArgs>(
      args?: SelectSubset<T, SmsNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmsNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmsNotifications
     * const smsNotification = await prisma.smsNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SmsNotificationUpdateManyArgs>(
      args: SelectSubset<T, SmsNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SmsNotification.
     * @param {SmsNotificationUpsertArgs} args - Arguments to update or create a SmsNotification.
     * @example
     * // Update or create a SmsNotification
     * const smsNotification = await prisma.smsNotification.upsert({
     *   create: {
     *     // ... data to create a SmsNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmsNotification we want to update
     *   }
     * })
    **/
    upsert<T extends SmsNotificationUpsertArgs>(
      args: SelectSubset<T, SmsNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Find one SmsNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SmsNotificationFindUniqueOrThrowArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SmsNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SmsNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Find the first SmsNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationFindFirstOrThrowArgs} args - Arguments to find a SmsNotification
     * @example
     * // Get one SmsNotification
     * const smsNotification = await prisma.smsNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SmsNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SmsNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SmsNotificationClient<SmsNotification>, Prisma__SmsNotificationClient<SmsNotificationGetPayload<T>>>

    /**
     * Count the number of SmsNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationCountArgs} args - Arguments to filter SmsNotifications to count.
     * @example
     * // Count the number of SmsNotifications
     * const count = await prisma.smsNotification.count({
     *   where: {
     *     // ... the filter for the SmsNotifications we want to count
     *   }
     * })
    **/
    count<T extends SmsNotificationCountArgs>(
      args?: Subset<T, SmsNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmsNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmsNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmsNotificationAggregateArgs>(args: Subset<T, SmsNotificationAggregateArgs>): PrismaPromise<GetSmsNotificationAggregateType<T>>

    /**
     * Group by SmsNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmsNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmsNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmsNotificationGroupByArgs['orderBy'] }
        : { orderBy?: SmsNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmsNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmsNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SmsNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SmsNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SmsNotification base type for findUnique actions
   */
  export type SmsNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter, which SmsNotification to fetch.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
  }

  /**
   * SmsNotification: findUnique
   */
  export interface SmsNotificationFindUniqueArgs extends SmsNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SmsNotification base type for findFirst actions
   */
  export type SmsNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter, which SmsNotification to fetch.
     * 
    **/
    where?: SmsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<SmsNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmsNotifications.
     * 
    **/
    cursor?: SmsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmsNotifications.
     * 
    **/
    distinct?: Enumerable<SmsNotificationScalarFieldEnum>
  }

  /**
   * SmsNotification: findFirst
   */
  export interface SmsNotificationFindFirstArgs extends SmsNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SmsNotification findMany
   */
  export type SmsNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter, which SmsNotifications to fetch.
     * 
    **/
    where?: SmsNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmsNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<SmsNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmsNotifications.
     * 
    **/
    cursor?: SmsNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmsNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmsNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SmsNotificationScalarFieldEnum>
  }


  /**
   * SmsNotification create
   */
  export type SmsNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * The data needed to create a SmsNotification.
     * 
    **/
    data: XOR<SmsNotificationCreateInput, SmsNotificationUncheckedCreateInput>
  }


  /**
   * SmsNotification createMany
   */
  export type SmsNotificationCreateManyArgs = {
    /**
     * The data used to create many SmsNotifications.
     * 
    **/
    data: Enumerable<SmsNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SmsNotification update
   */
  export type SmsNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * The data needed to update a SmsNotification.
     * 
    **/
    data: XOR<SmsNotificationUpdateInput, SmsNotificationUncheckedUpdateInput>
    /**
     * Choose, which SmsNotification to update.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
  }


  /**
   * SmsNotification updateMany
   */
  export type SmsNotificationUpdateManyArgs = {
    /**
     * The data used to update SmsNotifications.
     * 
    **/
    data: XOR<SmsNotificationUpdateManyMutationInput, SmsNotificationUncheckedUpdateManyInput>
    /**
     * Filter which SmsNotifications to update
     * 
    **/
    where?: SmsNotificationWhereInput
  }


  /**
   * SmsNotification upsert
   */
  export type SmsNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * The filter to search for the SmsNotification to update in case it exists.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
    /**
     * In case the SmsNotification found by the `where` argument doesn't exist, create a new SmsNotification with this data.
     * 
    **/
    create: XOR<SmsNotificationCreateInput, SmsNotificationUncheckedCreateInput>
    /**
     * In case the SmsNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SmsNotificationUpdateInput, SmsNotificationUncheckedUpdateInput>
  }


  /**
   * SmsNotification delete
   */
  export type SmsNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
    /**
     * Filter which SmsNotification to delete.
     * 
    **/
    where: SmsNotificationWhereUniqueInput
  }


  /**
   * SmsNotification deleteMany
   */
  export type SmsNotificationDeleteManyArgs = {
    /**
     * Filter which SmsNotifications to delete
     * 
    **/
    where?: SmsNotificationWhereInput
  }


  /**
   * SmsNotification: findUniqueOrThrow
   */
  export type SmsNotificationFindUniqueOrThrowArgs = SmsNotificationFindUniqueArgsBase
      

  /**
   * SmsNotification: findFirstOrThrow
   */
  export type SmsNotificationFindFirstOrThrowArgs = SmsNotificationFindFirstArgsBase
      

  /**
   * SmsNotification without action
   */
  export type SmsNotificationArgs = {
    /**
     * Select specific fields to fetch from the SmsNotification
     * 
    **/
    select?: SmsNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SmsNotificationInclude | null
  }



  /**
   * Model PushNotification
   */


  export type AggregatePushNotification = {
    _count: PushNotificationCountAggregateOutputType | null
    _min: PushNotificationMinAggregateOutputType | null
    _max: PushNotificationMaxAggregateOutputType | null
  }

  export type PushNotificationMinAggregateOutputType = {
    id: string | null
    notification_id: string | null
    title: string | null
    subject: string | null
    send: string | null
    device_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PushNotificationMaxAggregateOutputType = {
    id: string | null
    notification_id: string | null
    title: string | null
    subject: string | null
    send: string | null
    device_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PushNotificationCountAggregateOutputType = {
    id: number
    notification_id: number
    title: number
    subject: number
    send: number
    device_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PushNotificationMinAggregateInputType = {
    id?: true
    notification_id?: true
    title?: true
    subject?: true
    send?: true
    device_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PushNotificationMaxAggregateInputType = {
    id?: true
    notification_id?: true
    title?: true
    subject?: true
    send?: true
    device_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PushNotificationCountAggregateInputType = {
    id?: true
    notification_id?: true
    title?: true
    subject?: true
    send?: true
    device_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PushNotificationAggregateArgs = {
    /**
     * Filter which PushNotification to aggregate.
     * 
    **/
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<PushNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushNotifications
    **/
    _count?: true | PushNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushNotificationMaxAggregateInputType
  }

  export type GetPushNotificationAggregateType<T extends PushNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePushNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushNotification[P]>
      : GetScalarType<T[P], AggregatePushNotification[P]>
  }




  export type PushNotificationGroupByArgs = {
    where?: PushNotificationWhereInput
    orderBy?: Enumerable<PushNotificationOrderByWithAggregationInput>
    by: Array<PushNotificationScalarFieldEnum>
    having?: PushNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushNotificationCountAggregateInputType | true
    _min?: PushNotificationMinAggregateInputType
    _max?: PushNotificationMaxAggregateInputType
  }


  export type PushNotificationGroupByOutputType = {
    id: string
    notification_id: string
    title: string
    subject: string
    send: string | null
    device_id: string
    created_at: Date
    updated_at: Date
    _count: PushNotificationCountAggregateOutputType | null
    _min: PushNotificationMinAggregateOutputType | null
    _max: PushNotificationMaxAggregateOutputType | null
  }

  type GetPushNotificationGroupByPayload<T extends PushNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PushNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], PushNotificationGroupByOutputType[P]>
        }
      >
    >


  export type PushNotificationSelect = {
    id?: boolean
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    title?: boolean
    subject?: boolean
    send?: boolean
    device_id?: boolean
    device?: boolean | DeviceArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type PushNotificationInclude = {
    notification?: boolean | NotificationsArgs
    device?: boolean | DeviceArgs
  }

  export type PushNotificationGetPayload<
    S extends boolean | null | undefined | PushNotificationArgs,
    U = keyof S
      > = S extends true
        ? PushNotification
    : S extends undefined
    ? never
    : S extends PushNotificationArgs | PushNotificationFindManyArgs
    ?'include' extends U
    ? PushNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof PushNotification ? PushNotification[P] : never
  } 
    : PushNotification
  : PushNotification


  type PushNotificationCountArgs = Merge<
    Omit<PushNotificationFindManyArgs, 'select' | 'include'> & {
      select?: PushNotificationCountAggregateInputType | true
    }
  >

  export interface PushNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PushNotification that matches the filter.
     * @param {PushNotificationFindUniqueArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PushNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PushNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PushNotification'> extends True ? CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>> : CheckSelect<T, Prisma__PushNotificationClient<PushNotification | null, null>, Prisma__PushNotificationClient<PushNotificationGetPayload<T> | null, null>>

    /**
     * Find the first PushNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindFirstArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PushNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PushNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PushNotification'> extends True ? CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>> : CheckSelect<T, Prisma__PushNotificationClient<PushNotification | null, null>, Prisma__PushNotificationClient<PushNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more PushNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushNotifications
     * const pushNotifications = await prisma.pushNotification.findMany()
     * 
     * // Get first 10 PushNotifications
     * const pushNotifications = await prisma.pushNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushNotificationWithIdOnly = await prisma.pushNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PushNotificationFindManyArgs>(
      args?: SelectSubset<T, PushNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PushNotification>>, PrismaPromise<Array<PushNotificationGetPayload<T>>>>

    /**
     * Create a PushNotification.
     * @param {PushNotificationCreateArgs} args - Arguments to create a PushNotification.
     * @example
     * // Create one PushNotification
     * const PushNotification = await prisma.pushNotification.create({
     *   data: {
     *     // ... data to create a PushNotification
     *   }
     * })
     * 
    **/
    create<T extends PushNotificationCreateArgs>(
      args: SelectSubset<T, PushNotificationCreateArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Create many PushNotifications.
     *     @param {PushNotificationCreateManyArgs} args - Arguments to create many PushNotifications.
     *     @example
     *     // Create many PushNotifications
     *     const pushNotification = await prisma.pushNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PushNotificationCreateManyArgs>(
      args?: SelectSubset<T, PushNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PushNotification.
     * @param {PushNotificationDeleteArgs} args - Arguments to delete one PushNotification.
     * @example
     * // Delete one PushNotification
     * const PushNotification = await prisma.pushNotification.delete({
     *   where: {
     *     // ... filter to delete one PushNotification
     *   }
     * })
     * 
    **/
    delete<T extends PushNotificationDeleteArgs>(
      args: SelectSubset<T, PushNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Update one PushNotification.
     * @param {PushNotificationUpdateArgs} args - Arguments to update one PushNotification.
     * @example
     * // Update one PushNotification
     * const pushNotification = await prisma.pushNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PushNotificationUpdateArgs>(
      args: SelectSubset<T, PushNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Delete zero or more PushNotifications.
     * @param {PushNotificationDeleteManyArgs} args - Arguments to filter PushNotifications to delete.
     * @example
     * // Delete a few PushNotifications
     * const { count } = await prisma.pushNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PushNotificationDeleteManyArgs>(
      args?: SelectSubset<T, PushNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushNotifications
     * const pushNotification = await prisma.pushNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PushNotificationUpdateManyArgs>(
      args: SelectSubset<T, PushNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PushNotification.
     * @param {PushNotificationUpsertArgs} args - Arguments to update or create a PushNotification.
     * @example
     * // Update or create a PushNotification
     * const pushNotification = await prisma.pushNotification.upsert({
     *   create: {
     *     // ... data to create a PushNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushNotification we want to update
     *   }
     * })
    **/
    upsert<T extends PushNotificationUpsertArgs>(
      args: SelectSubset<T, PushNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Find one PushNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PushNotificationFindUniqueOrThrowArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PushNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PushNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Find the first PushNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindFirstOrThrowArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PushNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PushNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PushNotificationClient<PushNotification>, Prisma__PushNotificationClient<PushNotificationGetPayload<T>>>

    /**
     * Count the number of PushNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationCountArgs} args - Arguments to filter PushNotifications to count.
     * @example
     * // Count the number of PushNotifications
     * const count = await prisma.pushNotification.count({
     *   where: {
     *     // ... the filter for the PushNotifications we want to count
     *   }
     * })
    **/
    count<T extends PushNotificationCountArgs>(
      args?: Subset<T, PushNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushNotificationAggregateArgs>(args: Subset<T, PushNotificationAggregateArgs>): PrismaPromise<GetPushNotificationAggregateType<T>>

    /**
     * Group by PushNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushNotificationGroupByArgs['orderBy'] }
        : { orderBy?: PushNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PushNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PushNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PushNotification base type for findUnique actions
   */
  export type PushNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter, which PushNotification to fetch.
     * 
    **/
    where: PushNotificationWhereUniqueInput
  }

  /**
   * PushNotification: findUnique
   */
  export interface PushNotificationFindUniqueArgs extends PushNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PushNotification base type for findFirst actions
   */
  export type PushNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter, which PushNotification to fetch.
     * 
    **/
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<PushNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushNotifications.
     * 
    **/
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushNotifications.
     * 
    **/
    distinct?: Enumerable<PushNotificationScalarFieldEnum>
  }

  /**
   * PushNotification: findFirst
   */
  export interface PushNotificationFindFirstArgs extends PushNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PushNotification findMany
   */
  export type PushNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter, which PushNotifications to fetch.
     * 
    **/
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<PushNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushNotifications.
     * 
    **/
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PushNotificationScalarFieldEnum>
  }


  /**
   * PushNotification create
   */
  export type PushNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * The data needed to create a PushNotification.
     * 
    **/
    data: XOR<PushNotificationCreateInput, PushNotificationUncheckedCreateInput>
  }


  /**
   * PushNotification createMany
   */
  export type PushNotificationCreateManyArgs = {
    /**
     * The data used to create many PushNotifications.
     * 
    **/
    data: Enumerable<PushNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PushNotification update
   */
  export type PushNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * The data needed to update a PushNotification.
     * 
    **/
    data: XOR<PushNotificationUpdateInput, PushNotificationUncheckedUpdateInput>
    /**
     * Choose, which PushNotification to update.
     * 
    **/
    where: PushNotificationWhereUniqueInput
  }


  /**
   * PushNotification updateMany
   */
  export type PushNotificationUpdateManyArgs = {
    /**
     * The data used to update PushNotifications.
     * 
    **/
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyInput>
    /**
     * Filter which PushNotifications to update
     * 
    **/
    where?: PushNotificationWhereInput
  }


  /**
   * PushNotification upsert
   */
  export type PushNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * The filter to search for the PushNotification to update in case it exists.
     * 
    **/
    where: PushNotificationWhereUniqueInput
    /**
     * In case the PushNotification found by the `where` argument doesn't exist, create a new PushNotification with this data.
     * 
    **/
    create: XOR<PushNotificationCreateInput, PushNotificationUncheckedCreateInput>
    /**
     * In case the PushNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PushNotificationUpdateInput, PushNotificationUncheckedUpdateInput>
  }


  /**
   * PushNotification delete
   */
  export type PushNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
    /**
     * Filter which PushNotification to delete.
     * 
    **/
    where: PushNotificationWhereUniqueInput
  }


  /**
   * PushNotification deleteMany
   */
  export type PushNotificationDeleteManyArgs = {
    /**
     * Filter which PushNotifications to delete
     * 
    **/
    where?: PushNotificationWhereInput
  }


  /**
   * PushNotification: findUniqueOrThrow
   */
  export type PushNotificationFindUniqueOrThrowArgs = PushNotificationFindUniqueArgsBase
      

  /**
   * PushNotification: findFirstOrThrow
   */
  export type PushNotificationFindFirstOrThrowArgs = PushNotificationFindFirstArgsBase
      

  /**
   * PushNotification without action
   */
  export type PushNotificationArgs = {
    /**
     * Select specific fields to fetch from the PushNotification
     * 
    **/
    select?: PushNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PushNotificationInclude | null
  }



  /**
   * Model DeviceNotification
   */


  export type AggregateDeviceNotification = {
    _count: DeviceNotificationCountAggregateOutputType | null
    _min: DeviceNotificationMinAggregateOutputType | null
    _max: DeviceNotificationMaxAggregateOutputType | null
  }

  export type DeviceNotificationMinAggregateOutputType = {
    device_id: string | null
    notification_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceNotificationMaxAggregateOutputType = {
    device_id: string | null
    notification_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeviceNotificationCountAggregateOutputType = {
    device_id: number
    notification_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeviceNotificationMinAggregateInputType = {
    device_id?: true
    notification_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceNotificationMaxAggregateInputType = {
    device_id?: true
    notification_id?: true
    created_at?: true
    updated_at?: true
  }

  export type DeviceNotificationCountAggregateInputType = {
    device_id?: true
    notification_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeviceNotificationAggregateArgs = {
    /**
     * Filter which DeviceNotification to aggregate.
     * 
    **/
    where?: DeviceNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DeviceNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceNotifications
    **/
    _count?: true | DeviceNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceNotificationMaxAggregateInputType
  }

  export type GetDeviceNotificationAggregateType<T extends DeviceNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceNotification[P]>
      : GetScalarType<T[P], AggregateDeviceNotification[P]>
  }




  export type DeviceNotificationGroupByArgs = {
    where?: DeviceNotificationWhereInput
    orderBy?: Enumerable<DeviceNotificationOrderByWithAggregationInput>
    by: Array<DeviceNotificationScalarFieldEnum>
    having?: DeviceNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceNotificationCountAggregateInputType | true
    _min?: DeviceNotificationMinAggregateInputType
    _max?: DeviceNotificationMaxAggregateInputType
  }


  export type DeviceNotificationGroupByOutputType = {
    device_id: string
    notification_id: string
    created_at: Date
    updated_at: Date
    _count: DeviceNotificationCountAggregateOutputType | null
    _min: DeviceNotificationMinAggregateOutputType | null
    _max: DeviceNotificationMaxAggregateOutputType | null
  }

  type GetDeviceNotificationGroupByPayload<T extends DeviceNotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeviceNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceNotificationGroupByOutputType[P]>
        }
      >
    >


  export type DeviceNotificationSelect = {
    device_id?: boolean
    device?: boolean | DeviceArgs
    notification_id?: boolean
    notification?: boolean | NotificationsArgs
    created_at?: boolean
    updated_at?: boolean
  }

  export type DeviceNotificationInclude = {
    device?: boolean | DeviceArgs
    notification?: boolean | NotificationsArgs
  }

  export type DeviceNotificationGetPayload<
    S extends boolean | null | undefined | DeviceNotificationArgs,
    U = keyof S
      > = S extends true
        ? DeviceNotification
    : S extends undefined
    ? never
    : S extends DeviceNotificationArgs | DeviceNotificationFindManyArgs
    ?'include' extends U
    ? DeviceNotification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'device' ? DeviceGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'notification' ? NotificationsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof DeviceNotification ? DeviceNotification[P] : never
  } 
    : DeviceNotification
  : DeviceNotification


  type DeviceNotificationCountArgs = Merge<
    Omit<DeviceNotificationFindManyArgs, 'select' | 'include'> & {
      select?: DeviceNotificationCountAggregateInputType | true
    }
  >

  export interface DeviceNotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DeviceNotification that matches the filter.
     * @param {DeviceNotificationFindUniqueArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceNotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeviceNotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeviceNotification'> extends True ? CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>> : CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification | null, null>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T> | null, null>>

    /**
     * Find the first DeviceNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationFindFirstArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceNotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeviceNotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeviceNotification'> extends True ? CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>> : CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification | null, null>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T> | null, null>>

    /**
     * Find zero or more DeviceNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceNotifications
     * const deviceNotifications = await prisma.deviceNotification.findMany()
     * 
     * // Get first 10 DeviceNotifications
     * const deviceNotifications = await prisma.deviceNotification.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceNotificationWithDevice_idOnly = await prisma.deviceNotification.findMany({ select: { device_id: true } })
     * 
    **/
    findMany<T extends DeviceNotificationFindManyArgs>(
      args?: SelectSubset<T, DeviceNotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DeviceNotification>>, PrismaPromise<Array<DeviceNotificationGetPayload<T>>>>

    /**
     * Create a DeviceNotification.
     * @param {DeviceNotificationCreateArgs} args - Arguments to create a DeviceNotification.
     * @example
     * // Create one DeviceNotification
     * const DeviceNotification = await prisma.deviceNotification.create({
     *   data: {
     *     // ... data to create a DeviceNotification
     *   }
     * })
     * 
    **/
    create<T extends DeviceNotificationCreateArgs>(
      args: SelectSubset<T, DeviceNotificationCreateArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Create many DeviceNotifications.
     *     @param {DeviceNotificationCreateManyArgs} args - Arguments to create many DeviceNotifications.
     *     @example
     *     // Create many DeviceNotifications
     *     const deviceNotification = await prisma.deviceNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeviceNotificationCreateManyArgs>(
      args?: SelectSubset<T, DeviceNotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceNotification.
     * @param {DeviceNotificationDeleteArgs} args - Arguments to delete one DeviceNotification.
     * @example
     * // Delete one DeviceNotification
     * const DeviceNotification = await prisma.deviceNotification.delete({
     *   where: {
     *     // ... filter to delete one DeviceNotification
     *   }
     * })
     * 
    **/
    delete<T extends DeviceNotificationDeleteArgs>(
      args: SelectSubset<T, DeviceNotificationDeleteArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Update one DeviceNotification.
     * @param {DeviceNotificationUpdateArgs} args - Arguments to update one DeviceNotification.
     * @example
     * // Update one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceNotificationUpdateArgs>(
      args: SelectSubset<T, DeviceNotificationUpdateArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Delete zero or more DeviceNotifications.
     * @param {DeviceNotificationDeleteManyArgs} args - Arguments to filter DeviceNotifications to delete.
     * @example
     * // Delete a few DeviceNotifications
     * const { count } = await prisma.deviceNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceNotificationDeleteManyArgs>(
      args?: SelectSubset<T, DeviceNotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceNotifications
     * const deviceNotification = await prisma.deviceNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceNotificationUpdateManyArgs>(
      args: SelectSubset<T, DeviceNotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceNotification.
     * @param {DeviceNotificationUpsertArgs} args - Arguments to update or create a DeviceNotification.
     * @example
     * // Update or create a DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.upsert({
     *   create: {
     *     // ... data to create a DeviceNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceNotification we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceNotificationUpsertArgs>(
      args: SelectSubset<T, DeviceNotificationUpsertArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Find one DeviceNotification that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DeviceNotificationFindUniqueOrThrowArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceNotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeviceNotificationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Find the first DeviceNotification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationFindFirstOrThrowArgs} args - Arguments to find a DeviceNotification
     * @example
     * // Get one DeviceNotification
     * const deviceNotification = await prisma.deviceNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceNotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeviceNotificationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DeviceNotificationClient<DeviceNotification>, Prisma__DeviceNotificationClient<DeviceNotificationGetPayload<T>>>

    /**
     * Count the number of DeviceNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationCountArgs} args - Arguments to filter DeviceNotifications to count.
     * @example
     * // Count the number of DeviceNotifications
     * const count = await prisma.deviceNotification.count({
     *   where: {
     *     // ... the filter for the DeviceNotifications we want to count
     *   }
     * })
    **/
    count<T extends DeviceNotificationCountArgs>(
      args?: Subset<T, DeviceNotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceNotificationAggregateArgs>(args: Subset<T, DeviceNotificationAggregateArgs>): PrismaPromise<GetDeviceNotificationAggregateType<T>>

    /**
     * Group by DeviceNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceNotificationGroupByArgs['orderBy'] }
        : { orderBy?: DeviceNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeviceNotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    device<T extends DeviceArgs = {}>(args?: Subset<T, DeviceArgs>): CheckSelect<T, Prisma__DeviceClient<Device | Null>, Prisma__DeviceClient<DeviceGetPayload<T> | Null>>;

    notification<T extends NotificationsArgs = {}>(args?: Subset<T, NotificationsArgs>): CheckSelect<T, Prisma__NotificationsClient<Notifications | Null>, Prisma__NotificationsClient<NotificationsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeviceNotification base type for findUnique actions
   */
  export type DeviceNotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter, which DeviceNotification to fetch.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
  }

  /**
   * DeviceNotification: findUnique
   */
  export interface DeviceNotificationFindUniqueArgs extends DeviceNotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceNotification base type for findFirst actions
   */
  export type DeviceNotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter, which DeviceNotification to fetch.
     * 
    **/
    where?: DeviceNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceNotifications.
     * 
    **/
    cursor?: DeviceNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceNotifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceNotifications.
     * 
    **/
    distinct?: Enumerable<DeviceNotificationScalarFieldEnum>
  }

  /**
   * DeviceNotification: findFirst
   */
  export interface DeviceNotificationFindFirstArgs extends DeviceNotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeviceNotification findMany
   */
  export type DeviceNotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter, which DeviceNotifications to fetch.
     * 
    **/
    where?: DeviceNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceNotifications to fetch.
     * 
    **/
    orderBy?: Enumerable<DeviceNotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceNotifications.
     * 
    **/
    cursor?: DeviceNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceNotifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceNotifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeviceNotificationScalarFieldEnum>
  }


  /**
   * DeviceNotification create
   */
  export type DeviceNotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * The data needed to create a DeviceNotification.
     * 
    **/
    data: XOR<DeviceNotificationCreateInput, DeviceNotificationUncheckedCreateInput>
  }


  /**
   * DeviceNotification createMany
   */
  export type DeviceNotificationCreateManyArgs = {
    /**
     * The data used to create many DeviceNotifications.
     * 
    **/
    data: Enumerable<DeviceNotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeviceNotification update
   */
  export type DeviceNotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * The data needed to update a DeviceNotification.
     * 
    **/
    data: XOR<DeviceNotificationUpdateInput, DeviceNotificationUncheckedUpdateInput>
    /**
     * Choose, which DeviceNotification to update.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
  }


  /**
   * DeviceNotification updateMany
   */
  export type DeviceNotificationUpdateManyArgs = {
    /**
     * The data used to update DeviceNotifications.
     * 
    **/
    data: XOR<DeviceNotificationUpdateManyMutationInput, DeviceNotificationUncheckedUpdateManyInput>
    /**
     * Filter which DeviceNotifications to update
     * 
    **/
    where?: DeviceNotificationWhereInput
  }


  /**
   * DeviceNotification upsert
   */
  export type DeviceNotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * The filter to search for the DeviceNotification to update in case it exists.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
    /**
     * In case the DeviceNotification found by the `where` argument doesn't exist, create a new DeviceNotification with this data.
     * 
    **/
    create: XOR<DeviceNotificationCreateInput, DeviceNotificationUncheckedCreateInput>
    /**
     * In case the DeviceNotification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DeviceNotificationUpdateInput, DeviceNotificationUncheckedUpdateInput>
  }


  /**
   * DeviceNotification delete
   */
  export type DeviceNotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
    /**
     * Filter which DeviceNotification to delete.
     * 
    **/
    where: DeviceNotificationWhereUniqueInput
  }


  /**
   * DeviceNotification deleteMany
   */
  export type DeviceNotificationDeleteManyArgs = {
    /**
     * Filter which DeviceNotifications to delete
     * 
    **/
    where?: DeviceNotificationWhereInput
  }


  /**
   * DeviceNotification: findUniqueOrThrow
   */
  export type DeviceNotificationFindUniqueOrThrowArgs = DeviceNotificationFindUniqueArgsBase
      

  /**
   * DeviceNotification: findFirstOrThrow
   */
  export type DeviceNotificationFindFirstOrThrowArgs = DeviceNotificationFindFirstArgsBase
      

  /**
   * DeviceNotification without action
   */
  export type DeviceNotificationArgs = {
    /**
     * Select specific fields to fetch from the DeviceNotification
     * 
    **/
    select?: DeviceNotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DeviceNotificationInclude | null
  }



  /**
   * Model Plan
   */


  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    external_id: number | null
    price: number | null
    max_users: number | null
    max_labels: number | null
  }

  export type PlanSumAggregateOutputType = {
    external_id: number | null
    price: number | null
    max_users: number | null
    max_labels: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    slug: string | null
    price: number | null
    max_users: number | null
    max_labels: number | null
    payment_cycle_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    description: string | null
    slug: string | null
    price: number | null
    max_users: number | null
    max_labels: number | null
    payment_cycle_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    description: number
    slug: number
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    external_id?: true
    price?: true
    max_users?: true
    max_labels?: true
  }

  export type PlanSumAggregateInputType = {
    external_id?: true
    price?: true
    max_users?: true
    max_labels?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    slug?: true
    price?: true
    max_users?: true
    max_labels?: true
    payment_cycle_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    slug?: true
    price?: true
    max_users?: true
    max_labels?: true
    payment_cycle_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    description?: true
    slug?: true
    price?: true
    max_users?: true
    max_labels?: true
    payment_cycle_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PlanAggregateArgs = {
    /**
     * Filter which Plan to aggregate.
     * 
    **/
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     * 
    **/
    orderBy?: Enumerable<PlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs = {
    where?: PlanWhereInput
    orderBy?: Enumerable<PlanOrderByWithAggregationInput>
    by: Array<PlanScalarFieldEnum>
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }


  export type PlanGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    created_at: Date
    updated_at: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    price?: boolean
    max_users?: boolean
    max_labels?: boolean
    payment_cycle_id?: boolean
    payment_cycle?: boolean | PaymentCycleArgs
    account?: boolean | AccountFindManyArgs
    created_at?: boolean
    updated_at?: boolean
    subscription?: boolean | SubscriptionFindManyArgs
    _count?: boolean | PlanCountOutputTypeArgs
  }

  export type PlanInclude = {
    payment_cycle?: boolean | PaymentCycleArgs
    account?: boolean | AccountFindManyArgs
    subscription?: boolean | SubscriptionFindManyArgs
    _count?: boolean | PlanCountOutputTypeArgs
  }

  export type PlanGetPayload<
    S extends boolean | null | undefined | PlanArgs,
    U = keyof S
      > = S extends true
        ? Plan
    : S extends undefined
    ? never
    : S extends PlanArgs | PlanFindManyArgs
    ?'include' extends U
    ? Plan  & {
    [P in TrueKeys<S['include']>]:
        P extends 'payment_cycle' ? PaymentCycleGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? Array < AccountGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PlanCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'payment_cycle' ? PaymentCycleGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? Array < AccountGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PlanCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Plan ? Plan[P] : never
  } 
    : Plan
  : Plan


  type PlanCountArgs = Merge<
    Omit<PlanFindManyArgs, 'select' | 'include'> & {
      select?: PlanCountAggregateInputType | true
    }
  >

  export interface PlanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Plan'> extends True ? CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>> : CheckSelect<T, Prisma__PlanClient<Plan | null, null>, Prisma__PlanClient<PlanGetPayload<T> | null, null>>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Plan'> extends True ? CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>> : CheckSelect<T, Prisma__PlanClient<Plan | null, null>, Prisma__PlanClient<PlanGetPayload<T> | null, null>>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlanFindManyArgs>(
      args?: SelectSubset<T, PlanFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Plan>>, PrismaPromise<Array<PlanGetPayload<T>>>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
    **/
    create<T extends PlanCreateArgs>(
      args: SelectSubset<T, PlanCreateArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Create many Plans.
     *     @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     *     @example
     *     // Create many Plans
     *     const plan = await prisma.plan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlanCreateManyArgs>(
      args?: SelectSubset<T, PlanCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
    **/
    delete<T extends PlanDeleteArgs>(
      args: SelectSubset<T, PlanDeleteArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlanUpdateArgs>(
      args: SelectSubset<T, PlanUpdateArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlanDeleteManyArgs>(
      args?: SelectSubset<T, PlanDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlanUpdateManyArgs>(
      args: SelectSubset<T, PlanUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
    **/
    upsert<T extends PlanUpsertArgs>(
      args: SelectSubset<T, PlanUpsertArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Find one Plan that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PlanFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Find the first Plan that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PlanFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PlanClient<Plan>, Prisma__PlanClient<PlanGetPayload<T>>>

    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlanClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    payment_cycle<T extends PaymentCycleArgs = {}>(args?: Subset<T, PaymentCycleArgs>): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle | Null>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T> | Null>>;

    account<T extends AccountFindManyArgs = {}>(args?: Subset<T, AccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Account>| Null>, PrismaPromise<Array<AccountGetPayload<T>>| Null>>;

    subscription<T extends SubscriptionFindManyArgs = {}>(args?: Subset<T, SubscriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Subscription>| Null>, PrismaPromise<Array<SubscriptionGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Plan base type for findUnique actions
   */
  export type PlanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter, which Plan to fetch.
     * 
    **/
    where: PlanWhereUniqueInput
  }

  /**
   * Plan: findUnique
   */
  export interface PlanFindUniqueArgs extends PlanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Plan base type for findFirst actions
   */
  export type PlanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter, which Plan to fetch.
     * 
    **/
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     * 
    **/
    orderBy?: Enumerable<PlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     * 
    **/
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     * 
    **/
    distinct?: Enumerable<PlanScalarFieldEnum>
  }

  /**
   * Plan: findFirst
   */
  export interface PlanFindFirstArgs extends PlanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter, which Plans to fetch.
     * 
    **/
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     * 
    **/
    orderBy?: Enumerable<PlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     * 
    **/
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlanScalarFieldEnum>
  }


  /**
   * Plan create
   */
  export type PlanCreateArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * The data needed to create a Plan.
     * 
    **/
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }


  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs = {
    /**
     * The data used to create many Plans.
     * 
    **/
    data: Enumerable<PlanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Plan update
   */
  export type PlanUpdateArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * The data needed to update a Plan.
     * 
    **/
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     * 
    **/
    where: PlanWhereUniqueInput
  }


  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs = {
    /**
     * The data used to update Plans.
     * 
    **/
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     * 
    **/
    where?: PlanWhereInput
  }


  /**
   * Plan upsert
   */
  export type PlanUpsertArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * The filter to search for the Plan to update in case it exists.
     * 
    **/
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     * 
    **/
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }


  /**
   * Plan delete
   */
  export type PlanDeleteArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
    /**
     * Filter which Plan to delete.
     * 
    **/
    where: PlanWhereUniqueInput
  }


  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs = {
    /**
     * Filter which Plans to delete
     * 
    **/
    where?: PlanWhereInput
  }


  /**
   * Plan: findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs = PlanFindUniqueArgsBase
      

  /**
   * Plan: findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs = PlanFindFirstArgsBase
      

  /**
   * Plan without action
   */
  export type PlanArgs = {
    /**
     * Select specific fields to fetch from the Plan
     * 
    **/
    select?: PlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlanInclude | null
  }



  /**
   * Model PaymentCycle
   */


  export type AggregatePaymentCycle = {
    _count: PaymentCycleCountAggregateOutputType | null
    _min: PaymentCycleMinAggregateOutputType | null
    _max: PaymentCycleMaxAggregateOutputType | null
  }

  export type PaymentCycleMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentCycleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentCycleCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentCycleMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentCycleMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentCycleCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentCycleAggregateArgs = {
    /**
     * Filter which PaymentCycle to aggregate.
     * 
    **/
    where?: PaymentCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCycles to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentCycleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCycles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCycles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentCycles
    **/
    _count?: true | PaymentCycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentCycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentCycleMaxAggregateInputType
  }

  export type GetPaymentCycleAggregateType<T extends PaymentCycleAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentCycle[P]>
      : GetScalarType<T[P], AggregatePaymentCycle[P]>
  }




  export type PaymentCycleGroupByArgs = {
    where?: PaymentCycleWhereInput
    orderBy?: Enumerable<PaymentCycleOrderByWithAggregationInput>
    by: Array<PaymentCycleScalarFieldEnum>
    having?: PaymentCycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCycleCountAggregateInputType | true
    _min?: PaymentCycleMinAggregateInputType
    _max?: PaymentCycleMaxAggregateInputType
  }


  export type PaymentCycleGroupByOutputType = {
    id: string
    name: string
    slug: string
    created_at: Date
    updated_at: Date
    _count: PaymentCycleCountAggregateOutputType | null
    _min: PaymentCycleMinAggregateOutputType | null
    _max: PaymentCycleMaxAggregateOutputType | null
  }

  type GetPaymentCycleGroupByPayload<T extends PaymentCycleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentCycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentCycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentCycleGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentCycleGroupByOutputType[P]>
        }
      >
    >


  export type PaymentCycleSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    created_at?: boolean
    updated_at?: boolean
    plans?: boolean | PlanFindManyArgs
    _count?: boolean | PaymentCycleCountOutputTypeArgs
  }

  export type PaymentCycleInclude = {
    plans?: boolean | PlanFindManyArgs
    _count?: boolean | PaymentCycleCountOutputTypeArgs
  }

  export type PaymentCycleGetPayload<
    S extends boolean | null | undefined | PaymentCycleArgs,
    U = keyof S
      > = S extends true
        ? PaymentCycle
    : S extends undefined
    ? never
    : S extends PaymentCycleArgs | PaymentCycleFindManyArgs
    ?'include' extends U
    ? PaymentCycle  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plans' ? Array < PlanGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PaymentCycleCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plans' ? Array < PlanGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PaymentCycleCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof PaymentCycle ? PaymentCycle[P] : never
  } 
    : PaymentCycle
  : PaymentCycle


  type PaymentCycleCountArgs = Merge<
    Omit<PaymentCycleFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCycleCountAggregateInputType | true
    }
  >

  export interface PaymentCycleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PaymentCycle that matches the filter.
     * @param {PaymentCycleFindUniqueArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentCycleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentCycleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentCycle'> extends True ? CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>> : CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle | null, null>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T> | null, null>>

    /**
     * Find the first PaymentCycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleFindFirstArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentCycleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentCycleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentCycle'> extends True ? CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>> : CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle | null, null>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T> | null, null>>

    /**
     * Find zero or more PaymentCycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentCycles
     * const paymentCycles = await prisma.paymentCycle.findMany()
     * 
     * // Get first 10 PaymentCycles
     * const paymentCycles = await prisma.paymentCycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentCycleWithIdOnly = await prisma.paymentCycle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentCycleFindManyArgs>(
      args?: SelectSubset<T, PaymentCycleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PaymentCycle>>, PrismaPromise<Array<PaymentCycleGetPayload<T>>>>

    /**
     * Create a PaymentCycle.
     * @param {PaymentCycleCreateArgs} args - Arguments to create a PaymentCycle.
     * @example
     * // Create one PaymentCycle
     * const PaymentCycle = await prisma.paymentCycle.create({
     *   data: {
     *     // ... data to create a PaymentCycle
     *   }
     * })
     * 
    **/
    create<T extends PaymentCycleCreateArgs>(
      args: SelectSubset<T, PaymentCycleCreateArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Create many PaymentCycles.
     *     @param {PaymentCycleCreateManyArgs} args - Arguments to create many PaymentCycles.
     *     @example
     *     // Create many PaymentCycles
     *     const paymentCycle = await prisma.paymentCycle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCycleCreateManyArgs>(
      args?: SelectSubset<T, PaymentCycleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentCycle.
     * @param {PaymentCycleDeleteArgs} args - Arguments to delete one PaymentCycle.
     * @example
     * // Delete one PaymentCycle
     * const PaymentCycle = await prisma.paymentCycle.delete({
     *   where: {
     *     // ... filter to delete one PaymentCycle
     *   }
     * })
     * 
    **/
    delete<T extends PaymentCycleDeleteArgs>(
      args: SelectSubset<T, PaymentCycleDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Update one PaymentCycle.
     * @param {PaymentCycleUpdateArgs} args - Arguments to update one PaymentCycle.
     * @example
     * // Update one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentCycleUpdateArgs>(
      args: SelectSubset<T, PaymentCycleUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Delete zero or more PaymentCycles.
     * @param {PaymentCycleDeleteManyArgs} args - Arguments to filter PaymentCycles to delete.
     * @example
     * // Delete a few PaymentCycles
     * const { count } = await prisma.paymentCycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentCycleDeleteManyArgs>(
      args?: SelectSubset<T, PaymentCycleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentCycles
     * const paymentCycle = await prisma.paymentCycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentCycleUpdateManyArgs>(
      args: SelectSubset<T, PaymentCycleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentCycle.
     * @param {PaymentCycleUpsertArgs} args - Arguments to update or create a PaymentCycle.
     * @example
     * // Update or create a PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.upsert({
     *   create: {
     *     // ... data to create a PaymentCycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentCycle we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentCycleUpsertArgs>(
      args: SelectSubset<T, PaymentCycleUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Find one PaymentCycle that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PaymentCycleFindUniqueOrThrowArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentCycleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PaymentCycleFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Find the first PaymentCycle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleFindFirstOrThrowArgs} args - Arguments to find a PaymentCycle
     * @example
     * // Get one PaymentCycle
     * const paymentCycle = await prisma.paymentCycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentCycleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentCycleFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PaymentCycleClient<PaymentCycle>, Prisma__PaymentCycleClient<PaymentCycleGetPayload<T>>>

    /**
     * Count the number of PaymentCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleCountArgs} args - Arguments to filter PaymentCycles to count.
     * @example
     * // Count the number of PaymentCycles
     * const count = await prisma.paymentCycle.count({
     *   where: {
     *     // ... the filter for the PaymentCycles we want to count
     *   }
     * })
    **/
    count<T extends PaymentCycleCountArgs>(
      args?: Subset<T, PaymentCycleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentCycleAggregateArgs>(args: Subset<T, PaymentCycleAggregateArgs>): PrismaPromise<GetPaymentCycleAggregateType<T>>

    /**
     * Group by PaymentCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentCycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentCycleGroupByArgs['orderBy'] }
        : { orderBy?: PaymentCycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentCycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentCycleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentCycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentCycleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plans<T extends PlanFindManyArgs = {}>(args?: Subset<T, PlanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Plan>| Null>, PrismaPromise<Array<PlanGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PaymentCycle base type for findUnique actions
   */
  export type PaymentCycleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter, which PaymentCycle to fetch.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
  }

  /**
   * PaymentCycle: findUnique
   */
  export interface PaymentCycleFindUniqueArgs extends PaymentCycleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentCycle base type for findFirst actions
   */
  export type PaymentCycleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter, which PaymentCycle to fetch.
     * 
    **/
    where?: PaymentCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCycles to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentCycleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentCycles.
     * 
    **/
    cursor?: PaymentCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCycles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCycles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentCycles.
     * 
    **/
    distinct?: Enumerable<PaymentCycleScalarFieldEnum>
  }

  /**
   * PaymentCycle: findFirst
   */
  export interface PaymentCycleFindFirstArgs extends PaymentCycleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentCycle findMany
   */
  export type PaymentCycleFindManyArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter, which PaymentCycles to fetch.
     * 
    **/
    where?: PaymentCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentCycles to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentCycleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentCycles.
     * 
    **/
    cursor?: PaymentCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentCycles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentCycles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentCycleScalarFieldEnum>
  }


  /**
   * PaymentCycle create
   */
  export type PaymentCycleCreateArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * The data needed to create a PaymentCycle.
     * 
    **/
    data: XOR<PaymentCycleCreateInput, PaymentCycleUncheckedCreateInput>
  }


  /**
   * PaymentCycle createMany
   */
  export type PaymentCycleCreateManyArgs = {
    /**
     * The data used to create many PaymentCycles.
     * 
    **/
    data: Enumerable<PaymentCycleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PaymentCycle update
   */
  export type PaymentCycleUpdateArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * The data needed to update a PaymentCycle.
     * 
    **/
    data: XOR<PaymentCycleUpdateInput, PaymentCycleUncheckedUpdateInput>
    /**
     * Choose, which PaymentCycle to update.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
  }


  /**
   * PaymentCycle updateMany
   */
  export type PaymentCycleUpdateManyArgs = {
    /**
     * The data used to update PaymentCycles.
     * 
    **/
    data: XOR<PaymentCycleUpdateManyMutationInput, PaymentCycleUncheckedUpdateManyInput>
    /**
     * Filter which PaymentCycles to update
     * 
    **/
    where?: PaymentCycleWhereInput
  }


  /**
   * PaymentCycle upsert
   */
  export type PaymentCycleUpsertArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * The filter to search for the PaymentCycle to update in case it exists.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
    /**
     * In case the PaymentCycle found by the `where` argument doesn't exist, create a new PaymentCycle with this data.
     * 
    **/
    create: XOR<PaymentCycleCreateInput, PaymentCycleUncheckedCreateInput>
    /**
     * In case the PaymentCycle was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentCycleUpdateInput, PaymentCycleUncheckedUpdateInput>
  }


  /**
   * PaymentCycle delete
   */
  export type PaymentCycleDeleteArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
    /**
     * Filter which PaymentCycle to delete.
     * 
    **/
    where: PaymentCycleWhereUniqueInput
  }


  /**
   * PaymentCycle deleteMany
   */
  export type PaymentCycleDeleteManyArgs = {
    /**
     * Filter which PaymentCycles to delete
     * 
    **/
    where?: PaymentCycleWhereInput
  }


  /**
   * PaymentCycle: findUniqueOrThrow
   */
  export type PaymentCycleFindUniqueOrThrowArgs = PaymentCycleFindUniqueArgsBase
      

  /**
   * PaymentCycle: findFirstOrThrow
   */
  export type PaymentCycleFindFirstOrThrowArgs = PaymentCycleFindFirstArgsBase
      

  /**
   * PaymentCycle without action
   */
  export type PaymentCycleArgs = {
    /**
     * Select specific fields to fetch from the PaymentCycle
     * 
    **/
    select?: PaymentCycleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentCycleInclude | null
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    plan_id: string | null
    account_id: string | null
    due: Date | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    plan_id: string | null
    account_id: string | null
    due: Date | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    plan_id: number
    account_id: number
    due: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    price?: true
  }

  export type SubscriptionSumAggregateInputType = {
    price?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    plan_id?: true
    account_id?: true
    due?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    plan_id?: true
    account_id?: true
    due?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    plan_id?: true
    account_id?: true
    due?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs = {
    /**
     * Filter which Subscription to aggregate.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs = {
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithAggregationInput>
    by: Array<SubscriptionScalarFieldEnum>
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: string
    plan_id: string
    account_id: string
    due: Date
    price: number
    created_at: Date
    updated_at: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect = {
    id?: boolean
    plan_id?: boolean
    plan?: boolean | PlanArgs
    account_id?: boolean
    account?: boolean | AccountArgs
    due?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubscriptionInclude = {
    plan?: boolean | PlanArgs
    account?: boolean | AccountArgs
  }

  export type SubscriptionGetPayload<
    S extends boolean | null | undefined | SubscriptionArgs,
    U = keyof S
      > = S extends true
        ? Subscription
    : S extends undefined
    ? never
    : S extends SubscriptionArgs | SubscriptionFindManyArgs
    ?'include' extends U
    ? Subscription  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plan' ? PlanGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plan' ? PlanGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Subscription ? Subscription[P] : never
  } 
    : Subscription
  : Subscription


  type SubscriptionCountArgs = Merge<
    Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }
  >

  export interface SubscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null, null>, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscription'> extends True ? CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>> : CheckSelect<T, Prisma__SubscriptionClient<Subscription | null, null>, Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs>(
      args?: SelectSubset<T, SubscriptionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Subscription>>, PrismaPromise<Array<SubscriptionGetPayload<T>>>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs>(
      args: SelectSubset<T, SubscriptionCreateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs>(
      args: SelectSubset<T, SubscriptionDeleteArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs>(
      args: SelectSubset<T, SubscriptionUpdateArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs>(
      args: SelectSubset<T, SubscriptionUpsertArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Find one Subscription that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Find the first Subscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SubscriptionClient<Subscription>, Prisma__SubscriptionClient<SubscriptionGetPayload<T>>>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plan<T extends PlanArgs = {}>(args?: Subset<T, PlanArgs>): CheckSelect<T, Prisma__PlanClient<Plan | Null>, Prisma__PlanClient<PlanGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subscription base type for findUnique actions
   */
  export type SubscriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription: findUnique
   */
  export interface SubscriptionFindUniqueArgs extends SubscriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription base type for findFirst actions
   */
  export type SubscriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     * 
    **/
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }

  /**
   * Subscription: findFirst
   */
  export interface SubscriptionFindFirstArgs extends SubscriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     * 
    **/
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     * 
    **/
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The data needed to create a Subscription.
     * 
    **/
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs = {
    /**
     * The data used to create many Subscriptions.
     * 
    **/
    data: Enumerable<SubscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The data needed to update a Subscription.
     * 
    **/
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs = {
    /**
     * The data used to update Subscriptions.
     * 
    **/
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     * 
    **/
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     * 
    **/
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     * 
    **/
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
    /**
     * Filter which Subscription to delete.
     * 
    **/
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs = {
    /**
     * Filter which Subscriptions to delete
     * 
    **/
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription: findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs = SubscriptionFindUniqueArgsBase
      

  /**
   * Subscription: findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs = SubscriptionFindFirstArgsBase
      

  /**
   * Subscription without action
   */
  export type SubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     * 
    **/
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubscriptionInclude | null
  }



  /**
   * Model StockItem
   */


  export type AggregateStockItem = {
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  export type StockItemAvgAggregateOutputType = {
    quantity: number | null
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockItemSumAggregateOutputType = {
    quantity: number | null
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockItemMinAggregateOutputType = {
    item_id: string | null
    account_id: string | null
    quantity: number | null
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockItemMaxAggregateOutputType = {
    item_id: string | null
    account_id: string | null
    quantity: number | null
    min_quantity: number | null
    max_quantity: number | null
  }

  export type StockItemCountAggregateOutputType = {
    item_id: number
    account_id: number
    quantity: number
    min_quantity: number
    max_quantity: number
    _all: number
  }


  export type StockItemAvgAggregateInputType = {
    quantity?: true
    min_quantity?: true
    max_quantity?: true
  }

  export type StockItemSumAggregateInputType = {
    quantity?: true
    min_quantity?: true
    max_quantity?: true
  }

  export type StockItemMinAggregateInputType = {
    item_id?: true
    account_id?: true
    quantity?: true
    min_quantity?: true
    max_quantity?: true
  }

  export type StockItemMaxAggregateInputType = {
    item_id?: true
    account_id?: true
    quantity?: true
    min_quantity?: true
    max_quantity?: true
  }

  export type StockItemCountAggregateInputType = {
    item_id?: true
    account_id?: true
    quantity?: true
    min_quantity?: true
    max_quantity?: true
    _all?: true
  }

  export type StockItemAggregateArgs = {
    /**
     * Filter which StockItem to aggregate.
     * 
    **/
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     * 
    **/
    orderBy?: Enumerable<StockItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockItems
    **/
    _count?: true | StockItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockItemMaxAggregateInputType
  }

  export type GetStockItemAggregateType<T extends StockItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStockItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockItem[P]>
      : GetScalarType<T[P], AggregateStockItem[P]>
  }




  export type StockItemGroupByArgs = {
    where?: StockItemWhereInput
    orderBy?: Enumerable<StockItemOrderByWithAggregationInput>
    by: Array<StockItemScalarFieldEnum>
    having?: StockItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockItemCountAggregateInputType | true
    _avg?: StockItemAvgAggregateInputType
    _sum?: StockItemSumAggregateInputType
    _min?: StockItemMinAggregateInputType
    _max?: StockItemMaxAggregateInputType
  }


  export type StockItemGroupByOutputType = {
    item_id: string
    account_id: string
    quantity: number
    min_quantity: number
    max_quantity: number
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  type GetStockItemGroupByPayload<T extends StockItemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StockItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockItemGroupByOutputType[P]>
            : GetScalarType<T[P], StockItemGroupByOutputType[P]>
        }
      >
    >


  export type StockItemSelect = {
    item_id?: boolean
    item?: boolean | ItemArgs
    account_id?: boolean
    account?: boolean | AccountArgs
    quantity?: boolean
    min_quantity?: boolean
    max_quantity?: boolean
  }

  export type StockItemInclude = {
    item?: boolean | ItemArgs
    account?: boolean | AccountArgs
  }

  export type StockItemGetPayload<
    S extends boolean | null | undefined | StockItemArgs,
    U = keyof S
      > = S extends true
        ? StockItem
    : S extends undefined
    ? never
    : S extends StockItemArgs | StockItemFindManyArgs
    ?'include' extends U
    ? StockItem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'account' ? AccountGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof StockItem ? StockItem[P] : never
  } 
    : StockItem
  : StockItem


  type StockItemCountArgs = Merge<
    Omit<StockItemFindManyArgs, 'select' | 'include'> & {
      select?: StockItemCountAggregateInputType | true
    }
  >

  export interface StockItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StockItem that matches the filter.
     * @param {StockItemFindUniqueArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StockItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StockItem'> extends True ? CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>> : CheckSelect<T, Prisma__StockItemClient<StockItem | null, null>, Prisma__StockItemClient<StockItemGetPayload<T> | null, null>>

    /**
     * Find the first StockItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StockItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StockItem'> extends True ? CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>> : CheckSelect<T, Prisma__StockItemClient<StockItem | null, null>, Prisma__StockItemClient<StockItemGetPayload<T> | null, null>>

    /**
     * Find zero or more StockItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockItems
     * const stockItems = await prisma.stockItem.findMany()
     * 
     * // Get first 10 StockItems
     * const stockItems = await prisma.stockItem.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const stockItemWithItem_idOnly = await prisma.stockItem.findMany({ select: { item_id: true } })
     * 
    **/
    findMany<T extends StockItemFindManyArgs>(
      args?: SelectSubset<T, StockItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StockItem>>, PrismaPromise<Array<StockItemGetPayload<T>>>>

    /**
     * Create a StockItem.
     * @param {StockItemCreateArgs} args - Arguments to create a StockItem.
     * @example
     * // Create one StockItem
     * const StockItem = await prisma.stockItem.create({
     *   data: {
     *     // ... data to create a StockItem
     *   }
     * })
     * 
    **/
    create<T extends StockItemCreateArgs>(
      args: SelectSubset<T, StockItemCreateArgs>
    ): CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>>

    /**
     * Create many StockItems.
     *     @param {StockItemCreateManyArgs} args - Arguments to create many StockItems.
     *     @example
     *     // Create many StockItems
     *     const stockItem = await prisma.stockItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockItemCreateManyArgs>(
      args?: SelectSubset<T, StockItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StockItem.
     * @param {StockItemDeleteArgs} args - Arguments to delete one StockItem.
     * @example
     * // Delete one StockItem
     * const StockItem = await prisma.stockItem.delete({
     *   where: {
     *     // ... filter to delete one StockItem
     *   }
     * })
     * 
    **/
    delete<T extends StockItemDeleteArgs>(
      args: SelectSubset<T, StockItemDeleteArgs>
    ): CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>>

    /**
     * Update one StockItem.
     * @param {StockItemUpdateArgs} args - Arguments to update one StockItem.
     * @example
     * // Update one StockItem
     * const stockItem = await prisma.stockItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockItemUpdateArgs>(
      args: SelectSubset<T, StockItemUpdateArgs>
    ): CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>>

    /**
     * Delete zero or more StockItems.
     * @param {StockItemDeleteManyArgs} args - Arguments to filter StockItems to delete.
     * @example
     * // Delete a few StockItems
     * const { count } = await prisma.stockItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockItemDeleteManyArgs>(
      args?: SelectSubset<T, StockItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockItems
     * const stockItem = await prisma.stockItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockItemUpdateManyArgs>(
      args: SelectSubset<T, StockItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StockItem.
     * @param {StockItemUpsertArgs} args - Arguments to update or create a StockItem.
     * @example
     * // Update or create a StockItem
     * const stockItem = await prisma.stockItem.upsert({
     *   create: {
     *     // ... data to create a StockItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockItem we want to update
     *   }
     * })
    **/
    upsert<T extends StockItemUpsertArgs>(
      args: SelectSubset<T, StockItemUpsertArgs>
    ): CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>>

    /**
     * Find one StockItem that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StockItemFindUniqueOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StockItemFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>>

    /**
     * Find the first StockItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StockItemFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StockItemClient<StockItem>, Prisma__StockItemClient<StockItemGetPayload<T>>>

    /**
     * Count the number of StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemCountArgs} args - Arguments to filter StockItems to count.
     * @example
     * // Count the number of StockItems
     * const count = await prisma.stockItem.count({
     *   where: {
     *     // ... the filter for the StockItems we want to count
     *   }
     * })
    **/
    count<T extends StockItemCountArgs>(
      args?: Subset<T, StockItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockItemAggregateArgs>(args: Subset<T, StockItemAggregateArgs>): PrismaPromise<GetStockItemAggregateType<T>>

    /**
     * Group by StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockItemGroupByArgs['orderBy'] }
        : { orderBy?: StockItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockItemGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StockItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StockItemClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    item<T extends ItemArgs = {}>(args?: Subset<T, ItemArgs>): CheckSelect<T, Prisma__ItemClient<Item | Null>, Prisma__ItemClient<ItemGetPayload<T> | Null>>;

    account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, Prisma__AccountClient<Account | Null>, Prisma__AccountClient<AccountGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StockItem base type for findUnique actions
   */
  export type StockItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
    /**
     * Filter, which StockItem to fetch.
     * 
    **/
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem: findUnique
   */
  export interface StockItemFindUniqueArgs extends StockItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockItem base type for findFirst actions
   */
  export type StockItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
    /**
     * Filter, which StockItem to fetch.
     * 
    **/
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     * 
    **/
    orderBy?: Enumerable<StockItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockItems.
     * 
    **/
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockItems.
     * 
    **/
    distinct?: Enumerable<StockItemScalarFieldEnum>
  }

  /**
   * StockItem: findFirst
   */
  export interface StockItemFindFirstArgs extends StockItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockItem findMany
   */
  export type StockItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
    /**
     * Filter, which StockItems to fetch.
     * 
    **/
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     * 
    **/
    orderBy?: Enumerable<StockItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockItems.
     * 
    **/
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StockItemScalarFieldEnum>
  }


  /**
   * StockItem create
   */
  export type StockItemCreateArgs = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
    /**
     * The data needed to create a StockItem.
     * 
    **/
    data: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
  }


  /**
   * StockItem createMany
   */
  export type StockItemCreateManyArgs = {
    /**
     * The data used to create many StockItems.
     * 
    **/
    data: Enumerable<StockItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StockItem update
   */
  export type StockItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
    /**
     * The data needed to update a StockItem.
     * 
    **/
    data: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
    /**
     * Choose, which StockItem to update.
     * 
    **/
    where: StockItemWhereUniqueInput
  }


  /**
   * StockItem updateMany
   */
  export type StockItemUpdateManyArgs = {
    /**
     * The data used to update StockItems.
     * 
    **/
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyInput>
    /**
     * Filter which StockItems to update
     * 
    **/
    where?: StockItemWhereInput
  }


  /**
   * StockItem upsert
   */
  export type StockItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
    /**
     * The filter to search for the StockItem to update in case it exists.
     * 
    **/
    where: StockItemWhereUniqueInput
    /**
     * In case the StockItem found by the `where` argument doesn't exist, create a new StockItem with this data.
     * 
    **/
    create: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
    /**
     * In case the StockItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
  }


  /**
   * StockItem delete
   */
  export type StockItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
    /**
     * Filter which StockItem to delete.
     * 
    **/
    where: StockItemWhereUniqueInput
  }


  /**
   * StockItem deleteMany
   */
  export type StockItemDeleteManyArgs = {
    /**
     * Filter which StockItems to delete
     * 
    **/
    where?: StockItemWhereInput
  }


  /**
   * StockItem: findUniqueOrThrow
   */
  export type StockItemFindUniqueOrThrowArgs = StockItemFindUniqueArgsBase
      

  /**
   * StockItem: findFirstOrThrow
   */
  export type StockItemFindFirstOrThrowArgs = StockItemFindFirstArgsBase
      

  /**
   * StockItem without action
   */
  export type StockItemArgs = {
    /**
     * Select specific fields to fetch from the StockItem
     * 
    **/
    select?: StockItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockItemInclude | null
  }



  /**
   * Model StockHistory
   */


  export type AggregateStockHistory = {
    _count: StockHistoryCountAggregateOutputType | null
    _avg: StockHistoryAvgAggregateOutputType | null
    _sum: StockHistorySumAggregateOutputType | null
    _min: StockHistoryMinAggregateOutputType | null
    _max: StockHistoryMaxAggregateOutputType | null
  }

  export type StockHistoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockHistorySumAggregateOutputType = {
    quantity: number | null
  }

  export type StockHistoryMinAggregateOutputType = {
    id: string | null
    item_id: string | null
    reason: string | null
    operation: StockHistoryType | null
    quantity: number | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StockHistoryMaxAggregateOutputType = {
    id: string | null
    item_id: string | null
    reason: string | null
    operation: StockHistoryType | null
    quantity: number | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StockHistoryCountAggregateOutputType = {
    id: number
    item_id: number
    reason: number
    operation: number
    quantity: number
    date: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StockHistoryAvgAggregateInputType = {
    quantity?: true
  }

  export type StockHistorySumAggregateInputType = {
    quantity?: true
  }

  export type StockHistoryMinAggregateInputType = {
    id?: true
    item_id?: true
    reason?: true
    operation?: true
    quantity?: true
    date?: true
    created_at?: true
    updated_at?: true
  }

  export type StockHistoryMaxAggregateInputType = {
    id?: true
    item_id?: true
    reason?: true
    operation?: true
    quantity?: true
    date?: true
    created_at?: true
    updated_at?: true
  }

  export type StockHistoryCountAggregateInputType = {
    id?: true
    item_id?: true
    reason?: true
    operation?: true
    quantity?: true
    date?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StockHistoryAggregateArgs = {
    /**
     * Filter which StockHistory to aggregate.
     * 
    **/
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<StockHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockHistories
    **/
    _count?: true | StockHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockHistoryMaxAggregateInputType
  }

  export type GetStockHistoryAggregateType<T extends StockHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStockHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockHistory[P]>
      : GetScalarType<T[P], AggregateStockHistory[P]>
  }




  export type StockHistoryGroupByArgs = {
    where?: StockHistoryWhereInput
    orderBy?: Enumerable<StockHistoryOrderByWithAggregationInput>
    by: Array<StockHistoryScalarFieldEnum>
    having?: StockHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockHistoryCountAggregateInputType | true
    _avg?: StockHistoryAvgAggregateInputType
    _sum?: StockHistorySumAggregateInputType
    _min?: StockHistoryMinAggregateInputType
    _max?: StockHistoryMaxAggregateInputType
  }


  export type StockHistoryGroupByOutputType = {
    id: string
    item_id: string
    reason: string | null
    operation: StockHistoryType
    quantity: number
    date: Date
    created_at: Date
    updated_at: Date
    _count: StockHistoryCountAggregateOutputType | null
    _avg: StockHistoryAvgAggregateOutputType | null
    _sum: StockHistorySumAggregateOutputType | null
    _min: StockHistoryMinAggregateOutputType | null
    _max: StockHistoryMaxAggregateOutputType | null
  }

  type GetStockHistoryGroupByPayload<T extends StockHistoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StockHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], StockHistoryGroupByOutputType[P]>
        }
      >
    >


  export type StockHistorySelect = {
    id?: boolean
    item_id?: boolean
    item?: boolean | ItemArgs
    reason?: boolean
    operation?: boolean
    quantity?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StockHistoryInclude = {
    item?: boolean | ItemArgs
  }

  export type StockHistoryGetPayload<
    S extends boolean | null | undefined | StockHistoryArgs,
    U = keyof S
      > = S extends true
        ? StockHistory
    : S extends undefined
    ? never
    : S extends StockHistoryArgs | StockHistoryFindManyArgs
    ?'include' extends U
    ? StockHistory  & {
    [P in TrueKeys<S['include']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'item' ? ItemGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof StockHistory ? StockHistory[P] : never
  } 
    : StockHistory
  : StockHistory


  type StockHistoryCountArgs = Merge<
    Omit<StockHistoryFindManyArgs, 'select' | 'include'> & {
      select?: StockHistoryCountAggregateInputType | true
    }
  >

  export interface StockHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StockHistory that matches the filter.
     * @param {StockHistoryFindUniqueArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StockHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StockHistory'> extends True ? CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>> : CheckSelect<T, Prisma__StockHistoryClient<StockHistory | null, null>, Prisma__StockHistoryClient<StockHistoryGetPayload<T> | null, null>>

    /**
     * Find the first StockHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindFirstArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StockHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StockHistory'> extends True ? CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>> : CheckSelect<T, Prisma__StockHistoryClient<StockHistory | null, null>, Prisma__StockHistoryClient<StockHistoryGetPayload<T> | null, null>>

    /**
     * Find zero or more StockHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockHistories
     * const stockHistories = await prisma.stockHistory.findMany()
     * 
     * // Get first 10 StockHistories
     * const stockHistories = await prisma.stockHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockHistoryWithIdOnly = await prisma.stockHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockHistoryFindManyArgs>(
      args?: SelectSubset<T, StockHistoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StockHistory>>, PrismaPromise<Array<StockHistoryGetPayload<T>>>>

    /**
     * Create a StockHistory.
     * @param {StockHistoryCreateArgs} args - Arguments to create a StockHistory.
     * @example
     * // Create one StockHistory
     * const StockHistory = await prisma.stockHistory.create({
     *   data: {
     *     // ... data to create a StockHistory
     *   }
     * })
     * 
    **/
    create<T extends StockHistoryCreateArgs>(
      args: SelectSubset<T, StockHistoryCreateArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Create many StockHistories.
     *     @param {StockHistoryCreateManyArgs} args - Arguments to create many StockHistories.
     *     @example
     *     // Create many StockHistories
     *     const stockHistory = await prisma.stockHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockHistoryCreateManyArgs>(
      args?: SelectSubset<T, StockHistoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StockHistory.
     * @param {StockHistoryDeleteArgs} args - Arguments to delete one StockHistory.
     * @example
     * // Delete one StockHistory
     * const StockHistory = await prisma.stockHistory.delete({
     *   where: {
     *     // ... filter to delete one StockHistory
     *   }
     * })
     * 
    **/
    delete<T extends StockHistoryDeleteArgs>(
      args: SelectSubset<T, StockHistoryDeleteArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Update one StockHistory.
     * @param {StockHistoryUpdateArgs} args - Arguments to update one StockHistory.
     * @example
     * // Update one StockHistory
     * const stockHistory = await prisma.stockHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockHistoryUpdateArgs>(
      args: SelectSubset<T, StockHistoryUpdateArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Delete zero or more StockHistories.
     * @param {StockHistoryDeleteManyArgs} args - Arguments to filter StockHistories to delete.
     * @example
     * // Delete a few StockHistories
     * const { count } = await prisma.stockHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockHistoryDeleteManyArgs>(
      args?: SelectSubset<T, StockHistoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockHistories
     * const stockHistory = await prisma.stockHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockHistoryUpdateManyArgs>(
      args: SelectSubset<T, StockHistoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StockHistory.
     * @param {StockHistoryUpsertArgs} args - Arguments to update or create a StockHistory.
     * @example
     * // Update or create a StockHistory
     * const stockHistory = await prisma.stockHistory.upsert({
     *   create: {
     *     // ... data to create a StockHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockHistory we want to update
     *   }
     * })
    **/
    upsert<T extends StockHistoryUpsertArgs>(
      args: SelectSubset<T, StockHistoryUpsertArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Find one StockHistory that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StockHistoryFindUniqueOrThrowArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StockHistoryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Find the first StockHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryFindFirstOrThrowArgs} args - Arguments to find a StockHistory
     * @example
     * // Get one StockHistory
     * const stockHistory = await prisma.stockHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StockHistoryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StockHistoryClient<StockHistory>, Prisma__StockHistoryClient<StockHistoryGetPayload<T>>>

    /**
     * Count the number of StockHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryCountArgs} args - Arguments to filter StockHistories to count.
     * @example
     * // Count the number of StockHistories
     * const count = await prisma.stockHistory.count({
     *   where: {
     *     // ... the filter for the StockHistories we want to count
     *   }
     * })
    **/
    count<T extends StockHistoryCountArgs>(
      args?: Subset<T, StockHistoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockHistoryAggregateArgs>(args: Subset<T, StockHistoryAggregateArgs>): PrismaPromise<GetStockHistoryAggregateType<T>>

    /**
     * Group by StockHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockHistoryGroupByArgs['orderBy'] }
        : { orderBy?: StockHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockHistoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StockHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StockHistoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    item<T extends ItemArgs = {}>(args?: Subset<T, ItemArgs>): CheckSelect<T, Prisma__ItemClient<Item | Null>, Prisma__ItemClient<ItemGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StockHistory base type for findUnique actions
   */
  export type StockHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter, which StockHistory to fetch.
     * 
    **/
    where: StockHistoryWhereUniqueInput
  }

  /**
   * StockHistory: findUnique
   */
  export interface StockHistoryFindUniqueArgs extends StockHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockHistory base type for findFirst actions
   */
  export type StockHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter, which StockHistory to fetch.
     * 
    **/
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<StockHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockHistories.
     * 
    **/
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockHistories.
     * 
    **/
    distinct?: Enumerable<StockHistoryScalarFieldEnum>
  }

  /**
   * StockHistory: findFirst
   */
  export interface StockHistoryFindFirstArgs extends StockHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StockHistory findMany
   */
  export type StockHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter, which StockHistories to fetch.
     * 
    **/
    where?: StockHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<StockHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockHistories.
     * 
    **/
    cursor?: StockHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StockHistoryScalarFieldEnum>
  }


  /**
   * StockHistory create
   */
  export type StockHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * The data needed to create a StockHistory.
     * 
    **/
    data: XOR<StockHistoryCreateInput, StockHistoryUncheckedCreateInput>
  }


  /**
   * StockHistory createMany
   */
  export type StockHistoryCreateManyArgs = {
    /**
     * The data used to create many StockHistories.
     * 
    **/
    data: Enumerable<StockHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StockHistory update
   */
  export type StockHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * The data needed to update a StockHistory.
     * 
    **/
    data: XOR<StockHistoryUpdateInput, StockHistoryUncheckedUpdateInput>
    /**
     * Choose, which StockHistory to update.
     * 
    **/
    where: StockHistoryWhereUniqueInput
  }


  /**
   * StockHistory updateMany
   */
  export type StockHistoryUpdateManyArgs = {
    /**
     * The data used to update StockHistories.
     * 
    **/
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StockHistories to update
     * 
    **/
    where?: StockHistoryWhereInput
  }


  /**
   * StockHistory upsert
   */
  export type StockHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * The filter to search for the StockHistory to update in case it exists.
     * 
    **/
    where: StockHistoryWhereUniqueInput
    /**
     * In case the StockHistory found by the `where` argument doesn't exist, create a new StockHistory with this data.
     * 
    **/
    create: XOR<StockHistoryCreateInput, StockHistoryUncheckedCreateInput>
    /**
     * In case the StockHistory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StockHistoryUpdateInput, StockHistoryUncheckedUpdateInput>
  }


  /**
   * StockHistory delete
   */
  export type StockHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
    /**
     * Filter which StockHistory to delete.
     * 
    **/
    where: StockHistoryWhereUniqueInput
  }


  /**
   * StockHistory deleteMany
   */
  export type StockHistoryDeleteManyArgs = {
    /**
     * Filter which StockHistories to delete
     * 
    **/
    where?: StockHistoryWhereInput
  }


  /**
   * StockHistory: findUniqueOrThrow
   */
  export type StockHistoryFindUniqueOrThrowArgs = StockHistoryFindUniqueArgsBase
      

  /**
   * StockHistory: findFirstOrThrow
   */
  export type StockHistoryFindFirstOrThrowArgs = StockHistoryFindFirstArgsBase
      

  /**
   * StockHistory without action
   */
  export type StockHistoryArgs = {
    /**
     * Select specific fields to fetch from the StockHistory
     * 
    **/
    select?: StockHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockHistoryInclude | null
  }



  /**
   * Model Winery
   */


  export type AggregateWinery = {
    _count: WineryCountAggregateOutputType | null
    _avg: WineryAvgAggregateOutputType | null
    _sum: WinerySumAggregateOutputType | null
    _min: WineryMinAggregateOutputType | null
    _max: WineryMaxAggregateOutputType | null
  }

  export type WineryAvgAggregateOutputType = {
    external_id: number | null
  }

  export type WinerySumAggregateOutputType = {
    external_id: number | null
  }

  export type WineryMinAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WineryMaxAggregateOutputType = {
    id: string | null
    external_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WineryCountAggregateOutputType = {
    id: number
    external_id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WineryAvgAggregateInputType = {
    external_id?: true
  }

  export type WinerySumAggregateInputType = {
    external_id?: true
  }

  export type WineryMinAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type WineryMaxAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type WineryCountAggregateInputType = {
    id?: true
    external_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WineryAggregateArgs = {
    /**
     * Filter which Winery to aggregate.
     * 
    **/
    where?: WineryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wineries to fetch.
     * 
    **/
    orderBy?: Enumerable<WineryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WineryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wineries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wineries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wineries
    **/
    _count?: true | WineryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WineryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WinerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WineryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WineryMaxAggregateInputType
  }

  export type GetWineryAggregateType<T extends WineryAggregateArgs> = {
        [P in keyof T & keyof AggregateWinery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWinery[P]>
      : GetScalarType<T[P], AggregateWinery[P]>
  }




  export type WineryGroupByArgs = {
    where?: WineryWhereInput
    orderBy?: Enumerable<WineryOrderByWithAggregationInput>
    by: Array<WineryScalarFieldEnum>
    having?: WineryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WineryCountAggregateInputType | true
    _avg?: WineryAvgAggregateInputType
    _sum?: WinerySumAggregateInputType
    _min?: WineryMinAggregateInputType
    _max?: WineryMaxAggregateInputType
  }


  export type WineryGroupByOutputType = {
    id: string
    external_id: number | null
    name: string
    created_at: Date
    updated_at: Date
    _count: WineryCountAggregateOutputType | null
    _avg: WineryAvgAggregateOutputType | null
    _sum: WinerySumAggregateOutputType | null
    _min: WineryMinAggregateOutputType | null
    _max: WineryMaxAggregateOutputType | null
  }

  type GetWineryGroupByPayload<T extends WineryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WineryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WineryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WineryGroupByOutputType[P]>
            : GetScalarType<T[P], WineryGroupByOutputType[P]>
        }
      >
    >


  export type WinerySelect = {
    id?: boolean
    external_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    items?: boolean | ItemFindManyArgs
    _count?: boolean | WineryCountOutputTypeArgs
  }

  export type WineryInclude = {
    items?: boolean | ItemFindManyArgs
    _count?: boolean | WineryCountOutputTypeArgs
  }

  export type WineryGetPayload<
    S extends boolean | null | undefined | WineryArgs,
    U = keyof S
      > = S extends true
        ? Winery
    : S extends undefined
    ? never
    : S extends WineryArgs | WineryFindManyArgs
    ?'include' extends U
    ? Winery  & {
    [P in TrueKeys<S['include']>]:
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? WineryCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'items' ? Array < ItemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? WineryCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Winery ? Winery[P] : never
  } 
    : Winery
  : Winery


  type WineryCountArgs = Merge<
    Omit<WineryFindManyArgs, 'select' | 'include'> & {
      select?: WineryCountAggregateInputType | true
    }
  >

  export interface WineryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Winery that matches the filter.
     * @param {WineryFindUniqueArgs} args - Arguments to find a Winery
     * @example
     * // Get one Winery
     * const winery = await prisma.winery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WineryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WineryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Winery'> extends True ? CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>> : CheckSelect<T, Prisma__WineryClient<Winery | null, null>, Prisma__WineryClient<WineryGetPayload<T> | null, null>>

    /**
     * Find the first Winery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineryFindFirstArgs} args - Arguments to find a Winery
     * @example
     * // Get one Winery
     * const winery = await prisma.winery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WineryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WineryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Winery'> extends True ? CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>> : CheckSelect<T, Prisma__WineryClient<Winery | null, null>, Prisma__WineryClient<WineryGetPayload<T> | null, null>>

    /**
     * Find zero or more Wineries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wineries
     * const wineries = await prisma.winery.findMany()
     * 
     * // Get first 10 Wineries
     * const wineries = await prisma.winery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wineryWithIdOnly = await prisma.winery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WineryFindManyArgs>(
      args?: SelectSubset<T, WineryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Winery>>, PrismaPromise<Array<WineryGetPayload<T>>>>

    /**
     * Create a Winery.
     * @param {WineryCreateArgs} args - Arguments to create a Winery.
     * @example
     * // Create one Winery
     * const Winery = await prisma.winery.create({
     *   data: {
     *     // ... data to create a Winery
     *   }
     * })
     * 
    **/
    create<T extends WineryCreateArgs>(
      args: SelectSubset<T, WineryCreateArgs>
    ): CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>>

    /**
     * Create many Wineries.
     *     @param {WineryCreateManyArgs} args - Arguments to create many Wineries.
     *     @example
     *     // Create many Wineries
     *     const winery = await prisma.winery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WineryCreateManyArgs>(
      args?: SelectSubset<T, WineryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Winery.
     * @param {WineryDeleteArgs} args - Arguments to delete one Winery.
     * @example
     * // Delete one Winery
     * const Winery = await prisma.winery.delete({
     *   where: {
     *     // ... filter to delete one Winery
     *   }
     * })
     * 
    **/
    delete<T extends WineryDeleteArgs>(
      args: SelectSubset<T, WineryDeleteArgs>
    ): CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>>

    /**
     * Update one Winery.
     * @param {WineryUpdateArgs} args - Arguments to update one Winery.
     * @example
     * // Update one Winery
     * const winery = await prisma.winery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WineryUpdateArgs>(
      args: SelectSubset<T, WineryUpdateArgs>
    ): CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>>

    /**
     * Delete zero or more Wineries.
     * @param {WineryDeleteManyArgs} args - Arguments to filter Wineries to delete.
     * @example
     * // Delete a few Wineries
     * const { count } = await prisma.winery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WineryDeleteManyArgs>(
      args?: SelectSubset<T, WineryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wineries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wineries
     * const winery = await prisma.winery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WineryUpdateManyArgs>(
      args: SelectSubset<T, WineryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Winery.
     * @param {WineryUpsertArgs} args - Arguments to update or create a Winery.
     * @example
     * // Update or create a Winery
     * const winery = await prisma.winery.upsert({
     *   create: {
     *     // ... data to create a Winery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Winery we want to update
     *   }
     * })
    **/
    upsert<T extends WineryUpsertArgs>(
      args: SelectSubset<T, WineryUpsertArgs>
    ): CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>>

    /**
     * Find one Winery that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {WineryFindUniqueOrThrowArgs} args - Arguments to find a Winery
     * @example
     * // Get one Winery
     * const winery = await prisma.winery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WineryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WineryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>>

    /**
     * Find the first Winery that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineryFindFirstOrThrowArgs} args - Arguments to find a Winery
     * @example
     * // Get one Winery
     * const winery = await prisma.winery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WineryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WineryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__WineryClient<Winery>, Prisma__WineryClient<WineryGetPayload<T>>>

    /**
     * Count the number of Wineries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineryCountArgs} args - Arguments to filter Wineries to count.
     * @example
     * // Count the number of Wineries
     * const count = await prisma.winery.count({
     *   where: {
     *     // ... the filter for the Wineries we want to count
     *   }
     * })
    **/
    count<T extends WineryCountArgs>(
      args?: Subset<T, WineryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WineryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Winery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WineryAggregateArgs>(args: Subset<T, WineryAggregateArgs>): PrismaPromise<GetWineryAggregateType<T>>

    /**
     * Group by Winery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WineryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WineryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WineryGroupByArgs['orderBy'] }
        : { orderBy?: WineryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WineryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWineryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Winery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WineryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>| Null>, PrismaPromise<Array<ItemGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Winery base type for findUnique actions
   */
  export type WineryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
    /**
     * Filter, which Winery to fetch.
     * 
    **/
    where: WineryWhereUniqueInput
  }

  /**
   * Winery: findUnique
   */
  export interface WineryFindUniqueArgs extends WineryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Winery base type for findFirst actions
   */
  export type WineryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
    /**
     * Filter, which Winery to fetch.
     * 
    **/
    where?: WineryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wineries to fetch.
     * 
    **/
    orderBy?: Enumerable<WineryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wineries.
     * 
    **/
    cursor?: WineryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wineries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wineries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wineries.
     * 
    **/
    distinct?: Enumerable<WineryScalarFieldEnum>
  }

  /**
   * Winery: findFirst
   */
  export interface WineryFindFirstArgs extends WineryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Winery findMany
   */
  export type WineryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
    /**
     * Filter, which Wineries to fetch.
     * 
    **/
    where?: WineryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wineries to fetch.
     * 
    **/
    orderBy?: Enumerable<WineryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wineries.
     * 
    **/
    cursor?: WineryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wineries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wineries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WineryScalarFieldEnum>
  }


  /**
   * Winery create
   */
  export type WineryCreateArgs = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
    /**
     * The data needed to create a Winery.
     * 
    **/
    data: XOR<WineryCreateInput, WineryUncheckedCreateInput>
  }


  /**
   * Winery createMany
   */
  export type WineryCreateManyArgs = {
    /**
     * The data used to create many Wineries.
     * 
    **/
    data: Enumerable<WineryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Winery update
   */
  export type WineryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
    /**
     * The data needed to update a Winery.
     * 
    **/
    data: XOR<WineryUpdateInput, WineryUncheckedUpdateInput>
    /**
     * Choose, which Winery to update.
     * 
    **/
    where: WineryWhereUniqueInput
  }


  /**
   * Winery updateMany
   */
  export type WineryUpdateManyArgs = {
    /**
     * The data used to update Wineries.
     * 
    **/
    data: XOR<WineryUpdateManyMutationInput, WineryUncheckedUpdateManyInput>
    /**
     * Filter which Wineries to update
     * 
    **/
    where?: WineryWhereInput
  }


  /**
   * Winery upsert
   */
  export type WineryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
    /**
     * The filter to search for the Winery to update in case it exists.
     * 
    **/
    where: WineryWhereUniqueInput
    /**
     * In case the Winery found by the `where` argument doesn't exist, create a new Winery with this data.
     * 
    **/
    create: XOR<WineryCreateInput, WineryUncheckedCreateInput>
    /**
     * In case the Winery was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WineryUpdateInput, WineryUncheckedUpdateInput>
  }


  /**
   * Winery delete
   */
  export type WineryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
    /**
     * Filter which Winery to delete.
     * 
    **/
    where: WineryWhereUniqueInput
  }


  /**
   * Winery deleteMany
   */
  export type WineryDeleteManyArgs = {
    /**
     * Filter which Wineries to delete
     * 
    **/
    where?: WineryWhereInput
  }


  /**
   * Winery: findUniqueOrThrow
   */
  export type WineryFindUniqueOrThrowArgs = WineryFindUniqueArgsBase
      

  /**
   * Winery: findFirstOrThrow
   */
  export type WineryFindFirstOrThrowArgs = WineryFindFirstArgsBase
      

  /**
   * Winery without action
   */
  export type WineryArgs = {
    /**
     * Select specific fields to fetch from the Winery
     * 
    **/
    select?: WinerySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WineryInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountActivitiesScalarFieldEnum: {
    account_id: 'account_id',
    activities_id: 'activities_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AccountActivitiesScalarFieldEnum = (typeof AccountActivitiesScalarFieldEnum)[keyof typeof AccountActivitiesScalarFieldEnum]


  export const AccountConfigurationScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    banner_market_url: 'banner_market_url',
    header_color: 'header_color'
  };

  export type AccountConfigurationScalarFieldEnum = (typeof AccountConfigurationScalarFieldEnum)[keyof typeof AccountConfigurationScalarFieldEnum]


  export const AccountDeliveryScalarFieldEnum: {
    account_id: 'account_id',
    delivery_id: 'delivery_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AccountDeliveryScalarFieldEnum = (typeof AccountDeliveryScalarFieldEnum)[keyof typeof AccountDeliveryScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    email: 'email',
    cpf_cnpj: 'cpf_cnpj',
    market_name: 'market_name',
    phone: 'phone',
    whatsapp: 'whatsapp',
    logo: 'logo',
    person_type: 'person_type',
    site: 'site',
    social_reason: 'social_reason',
    facebook_url: 'facebook_url',
    instagram_url: 'instagram_url',
    banner: 'banner',
    gender: 'gender',
    street: 'street',
    number: 'number',
    complement: 'complement',
    district: 'district',
    city: 'city',
    state: 'state',
    zipcode: 'zipcode',
    plan_id: 'plan_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    domain: 'domain',
    isActive: 'isActive'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountUserScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type AccountUserScalarFieldEnum = (typeof AccountUserScalarFieldEnum)[keyof typeof AccountUserScalarFieldEnum]


  export const ActivitiesScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivitiesScalarFieldEnum = (typeof ActivitiesScalarFieldEnum)[keyof typeof ActivitiesScalarFieldEnum]


  export const CampaignItemScalarFieldEnum: {
    item_id: 'item_id',
    campaign_id: 'campaign_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CampaignItemScalarFieldEnum = (typeof CampaignItemScalarFieldEnum)[keyof typeof CampaignItemScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    description: 'description',
    discount_value: 'discount_value',
    discount_type: 'discount_type',
    start_date: 'start_date',
    expiration_date: 'expiration_date',
    campaign_type_id: 'campaign_type_id',
    account_id: 'account_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignTypeScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug'
  };

  export type CampaignTypeScalarFieldEnum = (typeof CampaignTypeScalarFieldEnum)[keyof typeof CampaignTypeScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug',
    state_id: 'state_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    account_id: 'account_id',
    dicount_type: 'dicount_type',
    discount_value: 'discount_value',
    couponUse_type: 'couponUse_type',
    inital_date: 'inital_date',
    expiration_date: 'expiration_date',
    min_value: 'min_value',
    max_value: 'max_value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    email: 'email',
    mobile_phone: 'mobile_phone',
    phone: 'phone',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    origin_registration: 'origin_registration',
    cpf_cnpj: 'cpf_cnpj',
    note: 'note',
    converted: 'converted'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const DeviceNotificationScalarFieldEnum: {
    device_id: 'device_id',
    notification_id: 'notification_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeviceNotificationScalarFieldEnum = (typeof DeviceNotificationScalarFieldEnum)[keyof typeof DeviceNotificationScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    device_physical_id: 'device_physical_id',
    platform: 'platform',
    version: 'version',
    token_notification: 'token_notification',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const DeviceUserScalarFieldEnum: {
    device_id: 'device_id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeviceUserScalarFieldEnum = (typeof DeviceUserScalarFieldEnum)[keyof typeof DeviceUserScalarFieldEnum]


  export const EmailNotificationScalarFieldEnum: {
    id: 'id',
    notification_id: 'notification_id',
    to: 'to',
    from: 'from',
    from_name: 'from_name',
    cc: 'cc',
    bcc: 'bcc',
    type: 'type',
    subject: 'subject',
    body: 'body',
    url_callback: 'url_callback',
    opened: 'opened',
    clicked: 'clicked',
    failed: 'failed',
    error_description: 'error_description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EmailNotificationScalarFieldEnum = (typeof EmailNotificationScalarFieldEnum)[keyof typeof EmailNotificationScalarFieldEnum]


  export const GrapeScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    created_at: 'created_at',
    updatedAt: 'updatedAt'
  };

  export type GrapeScalarFieldEnum = (typeof GrapeScalarFieldEnum)[keyof typeof GrapeScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    account_id: 'account_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const ItemGrapeScalarFieldEnum: {
    item_id: 'item_id',
    grape_id: 'grape_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ItemGrapeScalarFieldEnum = (typeof ItemGrapeScalarFieldEnum)[keyof typeof ItemGrapeScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    description: 'description',
    type_id: 'type_id',
    country_id: 'country_id',
    region_id: 'region_id',
    winery_id: 'winery_id',
    harvest: 'harvest',
    no_harvest: 'no_harvest',
    wine_type_id: 'wine_type_id',
    alcohol_percentage: 'alcohol_percentage',
    price: 'price',
    promotional_price: 'promotional_price',
    photo: 'photo',
    account_id: 'account_id',
    is_active: 'is_active',
    control_stock: 'control_stock',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemTagScalarFieldEnum: {
    item_id: 'item_id',
    tag_id: 'tag_id',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ItemTagScalarFieldEnum = (typeof ItemTagScalarFieldEnum)[keyof typeof ItemTagScalarFieldEnum]


  export const ItemTypeScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ItemTypeScalarFieldEnum = (typeof ItemTypeScalarFieldEnum)[keyof typeof ItemTypeScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    created_at: 'created_at',
    updated_at: 'updated_at',
    type: 'type'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    order_id: 'order_id',
    item_id: 'item_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    price: 'price',
    quantity: 'quantity'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    code: 'code',
    account_id: 'account_id',
    total: 'total',
    coupon_id: 'coupon_id',
    user_id: 'user_id',
    user_address_id: 'user_address_id',
    is_read: 'is_read',
    order_status_id: 'order_status_id',
    campaign_id: 'campaign_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OrderStatusScalarFieldEnum = (typeof OrderStatusScalarFieldEnum)[keyof typeof OrderStatusScalarFieldEnum]


  export const PaymentCycleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentCycleScalarFieldEnum = (typeof PaymentCycleScalarFieldEnum)[keyof typeof PaymentCycleScalarFieldEnum]


  export const PermisionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PermisionScalarFieldEnum = (typeof PermisionScalarFieldEnum)[keyof typeof PermisionScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    price: 'price',
    max_users: 'max_users',
    max_labels: 'max_labels',
    payment_cycle_id: 'payment_cycle_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PushNotificationScalarFieldEnum: {
    id: 'id',
    notification_id: 'notification_id',
    title: 'title',
    subject: 'subject',
    send: 'send',
    device_id: 'device_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PushNotificationScalarFieldEnum = (typeof PushNotificationScalarFieldEnum)[keyof typeof PushNotificationScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    state_id: 'state_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    role_id: 'role_id',
    permission_id: 'permission_id'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SmsNotificationScalarFieldEnum: {
    id: 'id',
    notification_id: 'notification_id',
    device_id: 'device_id',
    to: 'to',
    subject: 'subject',
    body: 'body',
    send: 'send',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SmsNotificationScalarFieldEnum = (typeof SmsNotificationScalarFieldEnum)[keyof typeof SmsNotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StateScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug',
    country_id: 'country_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const StockHistoryScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    reason: 'reason',
    operation: 'operation',
    quantity: 'quantity',
    date: 'date',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StockHistoryScalarFieldEnum = (typeof StockHistoryScalarFieldEnum)[keyof typeof StockHistoryScalarFieldEnum]


  export const StockItemScalarFieldEnum: {
    item_id: 'item_id',
    account_id: 'account_id',
    quantity: 'quantity',
    min_quantity: 'min_quantity',
    max_quantity: 'max_quantity'
  };

  export type StockItemScalarFieldEnum = (typeof StockItemScalarFieldEnum)[keyof typeof StockItemScalarFieldEnum]


  export const SubRegionScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug',
    region_id: 'region_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubRegionScalarFieldEnum = (typeof SubRegionScalarFieldEnum)[keyof typeof SubRegionScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    plan_id: 'plan_id',
    account_id: 'account_id',
    due: 'due',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    street: 'street',
    number: 'number',
    district: 'district',
    state: 'state',
    complement: 'complement',
    additional_information: 'additional_information',
    city: 'city',
    zip_code: 'zip_code',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    whatsapp: 'whatsapp',
    phone: 'phone',
    cpf_cnpj: 'cpf_cnpj',
    photo: 'photo',
    gender: 'gender',
    birthdate: 'birthdate',
    google_id: 'google_id',
    apple_id: 'apple_id',
    facebook_id: 'facebook_id',
    rd_station_id: 'rd_station_id',
    rd_station_sync: 'rd_station_sync',
    created_at: 'created_at',
    updated_at: 'updated_at',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WineTypeScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    slug: 'slug',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WineTypeScalarFieldEnum = (typeof WineTypeScalarFieldEnum)[keyof typeof WineTypeScalarFieldEnum]


  export const WineryScalarFieldEnum: {
    id: 'id',
    external_id: 'external_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WineryScalarFieldEnum = (typeof WineryScalarFieldEnum)[keyof typeof WineryScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    email?: StringFilter | string
    cpf_cnpj?: StringNullableFilter | string | null
    market_name?: StringFilter | string
    phone?: StringNullableFilter | string | null
    whatsapp?: StringNullableFilter | string | null
    logo?: StringNullableFilter | string | null
    person_type?: EnumPersonTypeFilter | PersonType
    site?: StringNullableFilter | string | null
    social_reason?: StringNullableFilter | string | null
    facebook_url?: StringNullableFilter | string | null
    instagram_url?: StringNullableFilter | string | null
    banner?: StringNullableFilter | string | null
    gender?: EnumGenderTypeFilter | GenderType
    campaign?: CampaignListRelationFilter
    street?: StringFilter | string
    number?: StringFilter | string
    complement?: StringNullableFilter | string | null
    district?: StringFilter | string
    city?: StringFilter | string
    state?: StringFilter | string
    zipcode?: StringFilter | string
    plan_id?: StringNullableFilter | string | null
    plan?: XOR<PlanRelationFilter, PlanWhereInput> | null
    subscription?: SubscriptionListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    order?: OrderListRelationFilter
    account_activities?: AccountActivitiesListRelationFilter
    account_deliveries?: AccountDeliveryListRelationFilter
    account_users?: AccountUserListRelationFilter
    invoices?: InvoiceListRelationFilter
    domain?: StringFilter | string
    stock_items?: StockItemListRelationFilter
    items?: ItemListRelationFilter
    coupons?: CouponListRelationFilter
    account_configuration?: XOR<AccountConfigurationRelationFilter, AccountConfigurationWhereInput> | null
    customers?: CustomerListRelationFilter
    isActive?: BoolFilter | boolean
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    campaign?: CampaignOrderByRelationAggregateInput
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    plan?: PlanOrderByWithRelationInput
    subscription?: SubscriptionOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
    order?: OrderOrderByRelationAggregateInput
    account_activities?: AccountActivitiesOrderByRelationAggregateInput
    account_deliveries?: AccountDeliveryOrderByRelationAggregateInput
    account_users?: AccountUserOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    domain?: SortOrder
    stock_items?: StockItemOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
    coupons?: CouponOrderByRelationAggregateInput
    account_configuration?: AccountConfigurationOrderByWithRelationInput
    customers?: CustomerOrderByRelationAggregateInput
    isActive?: SortOrder
  }

  export type AccountWhereUniqueInput = {
    id?: string
    external_id?: number
    email?: string
    domain?: string
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    cpf_cnpj?: StringNullableWithAggregatesFilter | string | null
    market_name?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    whatsapp?: StringNullableWithAggregatesFilter | string | null
    logo?: StringNullableWithAggregatesFilter | string | null
    person_type?: EnumPersonTypeWithAggregatesFilter | PersonType
    site?: StringNullableWithAggregatesFilter | string | null
    social_reason?: StringNullableWithAggregatesFilter | string | null
    facebook_url?: StringNullableWithAggregatesFilter | string | null
    instagram_url?: StringNullableWithAggregatesFilter | string | null
    banner?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeWithAggregatesFilter | GenderType
    street?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
    district?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    zipcode?: StringWithAggregatesFilter | string
    plan_id?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    domain?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type AccountConfigurationWhereInput = {
    AND?: Enumerable<AccountConfigurationWhereInput>
    OR?: Enumerable<AccountConfigurationWhereInput>
    NOT?: Enumerable<AccountConfigurationWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    banner_market_url?: StringNullableFilter | string | null
    header_color?: StringNullableFilter | string | null
  }

  export type AccountConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type AccountConfigurationWhereUniqueInput = {
    id?: string
    account_id?: string
  }

  export type AccountConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
    _count?: AccountConfigurationCountOrderByAggregateInput
    _max?: AccountConfigurationMaxOrderByAggregateInput
    _min?: AccountConfigurationMinOrderByAggregateInput
  }

  export type AccountConfigurationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountConfigurationScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountConfigurationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountConfigurationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    banner_market_url?: StringNullableWithAggregatesFilter | string | null
    header_color?: StringNullableWithAggregatesFilter | string | null
  }

  export type AccountActivitiesWhereInput = {
    AND?: Enumerable<AccountActivitiesWhereInput>
    OR?: Enumerable<AccountActivitiesWhereInput>
    NOT?: Enumerable<AccountActivitiesWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    activities_id?: StringFilter | string
    activities?: XOR<ActivitiesRelationFilter, ActivitiesWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountActivitiesOrderByWithRelationInput = {
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    activities_id?: SortOrder
    activities?: ActivitiesOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountActivitiesWhereUniqueInput = {
    account_id_activities_id?: AccountActivitiesAccount_idActivities_idCompoundUniqueInput
  }

  export type AccountActivitiesOrderByWithAggregationInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AccountActivitiesCountOrderByAggregateInput
    _max?: AccountActivitiesMaxOrderByAggregateInput
    _min?: AccountActivitiesMinOrderByAggregateInput
  }

  export type AccountActivitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountActivitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountActivitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountActivitiesScalarWhereWithAggregatesInput>
    account_id?: StringWithAggregatesFilter | string
    activities_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ActivitiesWhereInput = {
    AND?: Enumerable<ActivitiesWhereInput>
    OR?: Enumerable<ActivitiesWhereInput>
    NOT?: Enumerable<ActivitiesWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    account_activities?: AccountActivitiesListRelationFilter
  }

  export type ActivitiesOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_activities?: AccountActivitiesOrderByRelationAggregateInput
  }

  export type ActivitiesWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type ActivitiesOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivitiesCountOrderByAggregateInput
    _avg?: ActivitiesAvgOrderByAggregateInput
    _max?: ActivitiesMaxOrderByAggregateInput
    _min?: ActivitiesMinOrderByAggregateInput
    _sum?: ActivitiesSumOrderByAggregateInput
  }

  export type ActivitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivitiesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DeliveryWhereInput = {
    AND?: Enumerable<DeliveryWhereInput>
    OR?: Enumerable<DeliveryWhereInput>
    NOT?: Enumerable<DeliveryWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    account_deliveries?: AccountDeliveryListRelationFilter
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_deliveries?: AccountDeliveryOrderByRelationAggregateInput
  }

  export type DeliveryWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _avg?: DeliveryAvgOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
    _sum?: DeliverySumOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountDeliveryWhereInput = {
    AND?: Enumerable<AccountDeliveryWhereInput>
    OR?: Enumerable<AccountDeliveryWhereInput>
    NOT?: Enumerable<AccountDeliveryWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    delivery_id?: StringFilter | string
    delivery?: XOR<DeliveryRelationFilter, DeliveryWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountDeliveryOrderByWithRelationInput = {
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    delivery_id?: SortOrder
    delivery?: DeliveryOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountDeliveryWhereUniqueInput = {
    account_id_delivery_id?: AccountDeliveryAccount_idDelivery_idCompoundUniqueInput
  }

  export type AccountDeliveryOrderByWithAggregationInput = {
    account_id?: SortOrder
    delivery_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AccountDeliveryCountOrderByAggregateInput
    _max?: AccountDeliveryMaxOrderByAggregateInput
    _min?: AccountDeliveryMinOrderByAggregateInput
  }

  export type AccountDeliveryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountDeliveryScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountDeliveryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountDeliveryScalarWhereWithAggregatesInput>
    account_id?: StringWithAggregatesFilter | string
    delivery_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    whatsapp?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    cpf_cnpj?: StringNullableFilter | string | null
    photo?: StringNullableFilter | string | null
    gender?: EnumGenderTypeFilter | GenderType
    birthdate?: DateTimeNullableFilter | Date | string | null
    google_id?: StringNullableFilter | string | null
    apple_id?: StringNullableFilter | string | null
    facebook_id?: StringNullableFilter | string | null
    rd_station_id?: StringNullableFilter | string | null
    rd_station_sync?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    lastLogin?: DateTimeFilter | Date | string
    device_user?: DeviceUserListRelationFilter
    account_user?: AccountUserListRelationFilter
    orders?: OrderListRelationFilter
    user_addresses?: UserAddressListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    rd_station_id?: SortOrder
    rd_station_sync?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
    device_user?: DeviceUserOrderByRelationAggregateInput
    account_user?: AccountUserOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    user_addresses?: UserAddressOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    cpf_cnpj?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    rd_station_id?: SortOrder
    rd_station_sync?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    whatsapp?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    cpf_cnpj?: StringNullableWithAggregatesFilter | string | null
    photo?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeWithAggregatesFilter | GenderType
    birthdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    google_id?: StringNullableWithAggregatesFilter | string | null
    apple_id?: StringNullableWithAggregatesFilter | string | null
    facebook_id?: StringNullableWithAggregatesFilter | string | null
    rd_station_id?: StringNullableWithAggregatesFilter | string | null
    rd_station_sync?: BoolNullableWithAggregatesFilter | boolean | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    lastLogin?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserAddressWhereInput = {
    AND?: Enumerable<UserAddressWhereInput>
    OR?: Enumerable<UserAddressWhereInput>
    NOT?: Enumerable<UserAddressWhereInput>
    id?: StringFilter | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    name?: StringNullableFilter | string | null
    street?: StringFilter | string
    number?: StringFilter | string
    district?: StringFilter | string
    state?: StringFilter | string
    complement?: StringNullableFilter | string | null
    additional_information?: StringNullableFilter | string | null
    city?: StringFilter | string
    zip_code?: StringFilter | string
    orders?: OrderListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    name?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    additional_information?: SortOrder
    city?: SortOrder
    zip_code?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAddressWhereUniqueInput = {
    id?: string
  }

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    additional_information?: SortOrder
    city?: SortOrder
    zip_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    street?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    district?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
    additional_information?: StringNullableWithAggregatesFilter | string | null
    city?: StringWithAggregatesFilter | string
    zip_code?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountUserWhereInput = {
    AND?: Enumerable<AccountUserWhereInput>
    OR?: Enumerable<AccountUserWhereInput>
    NOT?: Enumerable<AccountUserWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role_id?: StringFilter | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type AccountUserOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    role_id?: SortOrder
    role?: RoleOrderByWithRelationInput
  }

  export type AccountUserWhereUniqueInput = {
    id?: string
    account_id_user_id_id?: AccountUserAccount_idUser_idIdCompoundUniqueInput
  }

  export type AccountUserOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
    _count?: AccountUserCountOrderByAggregateInput
    _max?: AccountUserMaxOrderByAggregateInput
    _min?: AccountUserMinOrderByAggregateInput
  }

  export type AccountUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountUserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    role_id?: StringWithAggregatesFilter | string
  }

  export type PermisionWhereInput = {
    AND?: Enumerable<PermisionWhereInput>
    OR?: Enumerable<PermisionWhereInput>
    NOT?: Enumerable<PermisionWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    RolePermission?: RolePermissionListRelationFilter
  }

  export type PermisionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    RolePermission?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermisionWhereUniqueInput = {
    id?: string
  }

  export type PermisionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PermisionCountOrderByAggregateInput
    _max?: PermisionMaxOrderByAggregateInput
    _min?: PermisionMinOrderByAggregateInput
  }

  export type PermisionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermisionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermisionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermisionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type RolePermissionWhereInput = {
    AND?: Enumerable<RolePermissionWhereInput>
    OR?: Enumerable<RolePermissionWhereInput>
    NOT?: Enumerable<RolePermissionWhereInput>
    role_id?: StringFilter | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission_id?: StringFilter | string
    permission?: XOR<PermisionRelationFilter, PermisionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    role_id?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission_id?: SortOrder
    permission?: PermisionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = {
    role_id_permission_id?: RolePermissionRole_idPermission_idCompoundUniqueInput
  }

  export type RolePermissionOrderByWithAggregationInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    role_id?: StringWithAggregatesFilter | string
    permission_id?: StringWithAggregatesFilter | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    RolePermission?: RolePermissionListRelationFilter
    AccountUser?: AccountUserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    RolePermission?: RolePermissionOrderByRelationAggregateInput
    AccountUser?: AccountUserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type CampaignWhereInput = {
    AND?: Enumerable<CampaignWhereInput>
    OR?: Enumerable<CampaignWhereInput>
    NOT?: Enumerable<CampaignWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    discount_value?: FloatNullableFilter | number | null
    discount_type?: EnumCampaignTypeDiscountNullableFilter | CampaignTypeDiscount | null
    start_date?: DateTimeNullableFilter | Date | string | null
    expiration_date?: DateTimeNullableFilter | Date | string | null
    campaign_type_id?: StringFilter | string
    campaign_type?: XOR<CampaignTypeRelationFilter, CampaignTypeWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    account_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    orders?: OrderListRelationFilter
    campaign_items?: CampaignItemListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discount_value?: SortOrder
    discount_type?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    campaign_type_id?: SortOrder
    campaign_type?: CampaignTypeOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    campaign_items?: CampaignItemOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discount_value?: SortOrder
    discount_type?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    campaign_type_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    discount_value?: FloatNullableWithAggregatesFilter | number | null
    discount_type?: EnumCampaignTypeDiscountNullableWithAggregatesFilter | CampaignTypeDiscount | null
    start_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    expiration_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    campaign_type_id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CampaignTypeWhereInput = {
    AND?: Enumerable<CampaignTypeWhereInput>
    OR?: Enumerable<CampaignTypeWhereInput>
    NOT?: Enumerable<CampaignTypeWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    Campaign?: CampaignListRelationFilter
  }

  export type CampaignTypeOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    Campaign?: CampaignOrderByRelationAggregateInput
  }

  export type CampaignTypeWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type CampaignTypeOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: CampaignTypeCountOrderByAggregateInput
    _avg?: CampaignTypeAvgOrderByAggregateInput
    _max?: CampaignTypeMaxOrderByAggregateInput
    _min?: CampaignTypeMinOrderByAggregateInput
    _sum?: CampaignTypeSumOrderByAggregateInput
  }

  export type CampaignTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
  }

  export type CouponWhereInput = {
    AND?: Enumerable<CouponWhereInput>
    OR?: Enumerable<CouponWhereInput>
    NOT?: Enumerable<CouponWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    dicount_type?: EnumCouponDiscountTypeFilter | CouponDiscountType
    discount_value?: FloatFilter | number
    couponUse_type?: EnumCouponUseTypeFilter | CouponUseType
    inital_date?: DateTimeFilter | Date | string
    expiration_date?: DateTimeNullableFilter | Date | string | null
    min_value?: FloatNullableFilter | number | null
    max_value?: FloatNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    orders?: OrderListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = {
    id?: string
  }

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CouponScalarWhereWithAggregatesInput>
    OR?: Enumerable<CouponScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CouponScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    dicount_type?: EnumCouponDiscountTypeWithAggregatesFilter | CouponDiscountType
    discount_value?: FloatWithAggregatesFilter | number
    couponUse_type?: EnumCouponUseTypeWithAggregatesFilter | CouponUseType
    inital_date?: DateTimeWithAggregatesFilter | Date | string
    expiration_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    min_value?: FloatNullableWithAggregatesFilter | number | null
    max_value?: FloatNullableWithAggregatesFilter | number | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ItemWhereInput = {
    AND?: Enumerable<ItemWhereInput>
    OR?: Enumerable<ItemWhereInput>
    NOT?: Enumerable<ItemWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    type_id?: StringFilter | string
    item_type?: XOR<ItemTypeRelationFilter, ItemTypeWhereInput>
    country_id?: StringNullableFilter | string | null
    country?: XOR<CountryRelationFilter, CountryWhereInput> | null
    region_id?: StringNullableFilter | string | null
    region?: XOR<RegionRelationFilter, RegionWhereInput> | null
    winery_id?: StringNullableFilter | string | null
    winery?: XOR<WineryRelationFilter, WineryWhereInput> | null
    harvest?: StringNullableFilter | string | null
    no_harvest?: BoolFilter | boolean
    wine_type_id?: StringNullableFilter | string | null
    wine_type?: XOR<WineTypeRelationFilter, WineTypeWhereInput> | null
    alcohol_percentage?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    price?: FloatFilter | number
    promotional_price?: FloatNullableFilter | number | null
    photo?: StringNullableFilter | string | null
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    is_active?: BoolFilter | boolean
    control_stock?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    item_grape?: ItemGrapeListRelationFilter
    order_items?: OrderItemListRelationFilter
    campaign_items?: CampaignItemListRelationFilter
    stock_items?: StockItemListRelationFilter
    stock_history?: StockHistoryListRelationFilter
    ItemTag?: ItemTagListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    item_type?: ItemTypeOrderByWithRelationInput
    country_id?: SortOrder
    country?: CountryOrderByWithRelationInput
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    winery_id?: SortOrder
    winery?: WineryOrderByWithRelationInput
    harvest?: SortOrder
    no_harvest?: SortOrder
    wine_type_id?: SortOrder
    wine_type?: WineTypeOrderByWithRelationInput
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    photo?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    is_active?: SortOrder
    control_stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    item_grape?: ItemGrapeOrderByRelationAggregateInput
    order_items?: OrderItemOrderByRelationAggregateInput
    campaign_items?: CampaignItemOrderByRelationAggregateInput
    stock_items?: StockItemOrderByRelationAggregateInput
    stock_history?: StockHistoryOrderByRelationAggregateInput
    ItemTag?: ItemTagOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    winery_id?: SortOrder
    harvest?: SortOrder
    no_harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    photo?: SortOrder
    account_id?: SortOrder
    is_active?: SortOrder
    control_stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    type_id?: StringWithAggregatesFilter | string
    country_id?: StringNullableWithAggregatesFilter | string | null
    region_id?: StringNullableWithAggregatesFilter | string | null
    winery_id?: StringNullableWithAggregatesFilter | string | null
    harvest?: StringNullableWithAggregatesFilter | string | null
    no_harvest?: BoolWithAggregatesFilter | boolean
    wine_type_id?: StringNullableWithAggregatesFilter | string | null
    alcohol_percentage?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    price?: FloatWithAggregatesFilter | number
    promotional_price?: FloatNullableWithAggregatesFilter | number | null
    photo?: StringNullableWithAggregatesFilter | string | null
    account_id?: StringWithAggregatesFilter | string
    is_active?: BoolWithAggregatesFilter | boolean
    control_stock?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ItemTypeWhereInput = {
    AND?: Enumerable<ItemTypeWhereInput>
    OR?: Enumerable<ItemTypeWhereInput>
    NOT?: Enumerable<ItemTypeWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    items?: ItemListRelationFilter
  }

  export type ItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type ItemTypeWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type ItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ItemTypeCountOrderByAggregateInput
    _avg?: ItemTypeAvgOrderByAggregateInput
    _max?: ItemTypeMaxOrderByAggregateInput
    _min?: ItemTypeMinOrderByAggregateInput
    _sum?: ItemTypeSumOrderByAggregateInput
  }

  export type ItemTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TagWhereInput = {
    AND?: Enumerable<TagWhereInput>
    OR?: Enumerable<TagWhereInput>
    NOT?: Enumerable<TagWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    ItemTag?: ItemTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ItemTag?: ItemTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = {
    id?: string
  }

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ItemTagWhereInput = {
    AND?: Enumerable<ItemTagWhereInput>
    OR?: Enumerable<ItemTagWhereInput>
    NOT?: Enumerable<ItemTagWhereInput>
    item_id?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    tag_id?: StringFilter | string
    tag?: XOR<TagRelationFilter, TagWhereInput>
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ItemTagOrderByWithRelationInput = {
    item_id?: SortOrder
    item?: ItemOrderByWithRelationInput
    tag_id?: SortOrder
    tag?: TagOrderByWithRelationInput
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemTagWhereUniqueInput = {
    slug?: string
    item_id_tag_id?: ItemTagItem_idTag_idCompoundUniqueInput
  }

  export type ItemTagOrderByWithAggregationInput = {
    item_id?: SortOrder
    tag_id?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ItemTagCountOrderByAggregateInput
    _max?: ItemTagMaxOrderByAggregateInput
    _min?: ItemTagMinOrderByAggregateInput
  }

  export type ItemTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemTagScalarWhereWithAggregatesInput>
    item_id?: StringWithAggregatesFilter | string
    tag_id?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CampaignItemWhereInput = {
    AND?: Enumerable<CampaignItemWhereInput>
    OR?: Enumerable<CampaignItemWhereInput>
    NOT?: Enumerable<CampaignItemWhereInput>
    item_id?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    campaign_id?: StringFilter | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CampaignItemOrderByWithRelationInput = {
    item_id?: SortOrder
    item?: ItemOrderByWithRelationInput
    campaign_id?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignItemWhereUniqueInput = {
    item_id_campaign_id?: CampaignItemItem_idCampaign_idCompoundUniqueInput
  }

  export type CampaignItemOrderByWithAggregationInput = {
    item_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CampaignItemCountOrderByAggregateInput
    _max?: CampaignItemMaxOrderByAggregateInput
    _min?: CampaignItemMinOrderByAggregateInput
  }

  export type CampaignItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignItemScalarWhereWithAggregatesInput>
    item_id?: StringWithAggregatesFilter | string
    campaign_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ItemGrapeWhereInput = {
    AND?: Enumerable<ItemGrapeWhereInput>
    OR?: Enumerable<ItemGrapeWhereInput>
    NOT?: Enumerable<ItemGrapeWhereInput>
    item_id?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    grape_id?: StringFilter | string
    grape?: XOR<GrapeRelationFilter, GrapeWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ItemGrapeOrderByWithRelationInput = {
    item_id?: SortOrder
    item?: ItemOrderByWithRelationInput
    grape_id?: SortOrder
    grape?: GrapeOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemGrapeWhereUniqueInput = {
    item_id_grape_id?: ItemGrapeItem_idGrape_idCompoundUniqueInput
  }

  export type ItemGrapeOrderByWithAggregationInput = {
    item_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ItemGrapeCountOrderByAggregateInput
    _max?: ItemGrapeMaxOrderByAggregateInput
    _min?: ItemGrapeMinOrderByAggregateInput
  }

  export type ItemGrapeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemGrapeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemGrapeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemGrapeScalarWhereWithAggregatesInput>
    item_id?: StringWithAggregatesFilter | string
    grape_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GrapeWhereInput = {
    AND?: Enumerable<GrapeWhereInput>
    OR?: Enumerable<GrapeWhereInput>
    NOT?: Enumerable<GrapeWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    item_grape?: ItemGrapeListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type GrapeOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    item_grape?: ItemGrapeOrderByRelationAggregateInput
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrapeWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type GrapeOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
    _count?: GrapeCountOrderByAggregateInput
    _avg?: GrapeAvgOrderByAggregateInput
    _max?: GrapeMaxOrderByAggregateInput
    _min?: GrapeMinOrderByAggregateInput
    _sum?: GrapeSumOrderByAggregateInput
  }

  export type GrapeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GrapeScalarWhereWithAggregatesInput>
    OR?: Enumerable<GrapeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GrapeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    value?: StringFilter | string
    states?: StateListRelationFilter
    items?: ItemListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    states?: StateOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CountryWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StateWhereInput = {
    AND?: Enumerable<StateWhereInput>
    OR?: Enumerable<StateWhereInput>
    NOT?: Enumerable<StateWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    country_id?: StringFilter | string
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    regions?: RegionListRelationFilter
    cities?: CityListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StateOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    country?: CountryOrderByWithRelationInput
    regions?: RegionOrderByRelationAggregateInput
    cities?: CityOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type StateOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StateCountOrderByAggregateInput
    _avg?: StateAvgOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
    _sum?: StateSumOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StateScalarWhereWithAggregatesInput>
    OR?: Enumerable<StateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    country_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    state_id?: StringFilter | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    state?: StateOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CityWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    state_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RegionWhereInput = {
    AND?: Enumerable<RegionWhereInput>
    OR?: Enumerable<RegionWhereInput>
    NOT?: Enumerable<RegionWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    state_id?: StringFilter | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    name?: StringFilter | string
    slug?: StringFilter | string
    subregion?: SubRegionListRelationFilter
    items?: ItemListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    state_id?: SortOrder
    state?: StateOrderByWithRelationInput
    name?: SortOrder
    slug?: SortOrder
    subregion?: SubRegionOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    state_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubRegionWhereInput = {
    AND?: Enumerable<SubRegionWhereInput>
    OR?: Enumerable<SubRegionWhereInput>
    NOT?: Enumerable<SubRegionWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    region_id?: StringFilter | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SubRegionOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionWhereUniqueInput = {
    id?: string
    external_id?: number
    name?: string
    slug?: string
  }

  export type SubRegionOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubRegionCountOrderByAggregateInput
    _avg?: SubRegionAvgOrderByAggregateInput
    _max?: SubRegionMaxOrderByAggregateInput
    _min?: SubRegionMinOrderByAggregateInput
    _sum?: SubRegionSumOrderByAggregateInput
  }

  export type SubRegionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubRegionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubRegionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubRegionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    region_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WineTypeWhereInput = {
    AND?: Enumerable<WineTypeWhereInput>
    OR?: Enumerable<WineTypeWhereInput>
    NOT?: Enumerable<WineTypeWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    items?: ItemListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type WineTypeOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    items?: ItemOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type WineTypeOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WineTypeCountOrderByAggregateInput
    _avg?: WineTypeAvgOrderByAggregateInput
    _max?: WineTypeMaxOrderByAggregateInput
    _min?: WineTypeMinOrderByAggregateInput
    _sum?: WineTypeSumOrderByAggregateInput
  }

  export type WineTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WineTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<WineTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WineTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    code?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    total?: FloatFilter | number
    coupon_id?: StringNullableFilter | string | null
    coupon?: XOR<CouponRelationFilter, CouponWhereInput> | null
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    user_address_id?: StringFilter | string
    user_address?: XOR<UserAddressRelationFilter, UserAddressWhereInput>
    is_read?: BoolFilter | boolean
    order_status_id?: StringFilter | string
    order_status?: XOR<OrderStatusRelationFilter, OrderStatusWhereInput>
    campaign_id?: StringNullableFilter | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput> | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    order_items?: OrderItemListRelationFilter
    invoice?: InvoiceListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    total?: SortOrder
    coupon_id?: SortOrder
    coupon?: CouponOrderByWithRelationInput
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    user_address_id?: SortOrder
    user_address?: UserAddressOrderByWithRelationInput
    is_read?: SortOrder
    order_status_id?: SortOrder
    order_status?: OrderStatusOrderByWithRelationInput
    campaign_id?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
    order_items?: OrderItemOrderByRelationAggregateInput
    invoice?: InvoiceOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = {
    id?: string
    external_id?: number
    code?: string
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    user_address_id?: SortOrder
    is_read?: SortOrder
    order_status_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    code?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    total?: FloatWithAggregatesFilter | number
    coupon_id?: StringNullableWithAggregatesFilter | string | null
    user_id?: StringWithAggregatesFilter | string
    user_address_id?: StringWithAggregatesFilter | string
    is_read?: BoolWithAggregatesFilter | boolean
    order_status_id?: StringWithAggregatesFilter | string
    campaign_id?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderStatusWhereInput = {
    AND?: Enumerable<OrderStatusWhereInput>
    OR?: Enumerable<OrderStatusWhereInput>
    NOT?: Enumerable<OrderStatusWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    orders?: OrderListRelationFilter
  }

  export type OrderStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type OrderStatusWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type OrderStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OrderStatusCountOrderByAggregateInput
    _max?: OrderStatusMaxOrderByAggregateInput
    _min?: OrderStatusMinOrderByAggregateInput
  }

  export type OrderStatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderStatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderStatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderStatusScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    email?: StringFilter | string
    mobile_phone?: StringFilter | string
    phone?: StringFilter | string
    is_active?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFilter | CustomerOriginRegistration
    cpf_cnpj?: StringFilter | string
    note?: StringFilter | string
    converted?: BoolFilter | boolean
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    email?: SortOrder
    mobile_phone?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    origin_registration?: SortOrder
    cpf_cnpj?: SortOrder
    note?: SortOrder
    converted?: SortOrder
  }

  export type CustomerWhereUniqueInput = {
    id?: string
  }

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    email?: SortOrder
    mobile_phone?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    origin_registration?: SortOrder
    cpf_cnpj?: SortOrder
    note?: SortOrder
    converted?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    mobile_phone?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    is_active?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    origin_registration?: EnumCustomerOriginRegistrationWithAggregatesFilter | CustomerOriginRegistration
    cpf_cnpj?: StringWithAggregatesFilter | string
    note?: StringWithAggregatesFilter | string
    converted?: BoolWithAggregatesFilter | boolean
  }

  export type OrderItemWhereInput = {
    AND?: Enumerable<OrderItemWhereInput>
    OR?: Enumerable<OrderItemWhereInput>
    NOT?: Enumerable<OrderItemWhereInput>
    order_id?: StringFilter | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    item_id?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    price?: FloatFilter | number
    quantity?: IntFilter | number
  }

  export type OrderItemOrderByWithRelationInput = {
    order_id?: SortOrder
    order?: OrderOrderByWithRelationInput
    item_id?: SortOrder
    item?: ItemOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemWhereUniqueInput = {
    order_id_item_id?: OrderItemOrder_idItem_idCompoundUniqueInput
  }

  export type OrderItemOrderByWithAggregationInput = {
    order_id?: SortOrder
    item_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    order_id?: StringWithAggregatesFilter | string
    item_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    price?: FloatWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
  }

  export type InvoiceWhereInput = {
    AND?: Enumerable<InvoiceWhereInput>
    OR?: Enumerable<InvoiceWhereInput>
    NOT?: Enumerable<InvoiceWhereInput>
    id?: StringFilter | string
    order_id?: StringFilter | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    order?: OrderOrderByWithRelationInput
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceWhereUniqueInput = {
    id?: string
  }

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    order_id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DeviceWhereInput = {
    AND?: Enumerable<DeviceWhereInput>
    OR?: Enumerable<DeviceWhereInput>
    NOT?: Enumerable<DeviceWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    device_physical_id?: StringFilter | string
    platform?: EnumPlatformTypeFilter | PlatformType
    version?: StringFilter | string
    token_notification?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    device_user?: DeviceUserListRelationFilter
    push_notification?: PushNotificationListRelationFilter
    sms_notification?: SmsNotificationListRelationFilter
    device_notification?: DeviceNotificationListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    device_user?: DeviceUserOrderByRelationAggregateInput
    push_notification?: PushNotificationOrderByRelationAggregateInput
    sms_notification?: SmsNotificationOrderByRelationAggregateInput
    device_notification?: DeviceNotificationOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = {
    id?: string
    external_id?: number
    device_physical_id?: string
  }

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    device_physical_id?: StringWithAggregatesFilter | string
    platform?: EnumPlatformTypeWithAggregatesFilter | PlatformType
    version?: StringWithAggregatesFilter | string
    token_notification?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DeviceUserWhereInput = {
    AND?: Enumerable<DeviceUserWhereInput>
    OR?: Enumerable<DeviceUserWhereInput>
    NOT?: Enumerable<DeviceUserWhereInput>
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceUserOrderByWithRelationInput = {
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceUserWhereUniqueInput = {
    device_id_user_id?: DeviceUserDevice_idUser_idCompoundUniqueInput
  }

  export type DeviceUserOrderByWithAggregationInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeviceUserCountOrderByAggregateInput
    _max?: DeviceUserMaxOrderByAggregateInput
    _min?: DeviceUserMinOrderByAggregateInput
  }

  export type DeviceUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeviceUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeviceUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeviceUserScalarWhereWithAggregatesInput>
    device_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NotificationsWhereInput = {
    AND?: Enumerable<NotificationsWhereInput>
    OR?: Enumerable<NotificationsWhereInput>
    NOT?: Enumerable<NotificationsWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    message?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    type?: EnumTypeNotificationFilter | TypeNotification
    sms_notification?: SmsNotificationListRelationFilter
    email_notification?: EmailNotificationListRelationFilter
    push_notification?: PushNotificationListRelationFilter
    device_notification?: DeviceNotificationListRelationFilter
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    sms_notification?: SmsNotificationOrderByRelationAggregateInput
    email_notification?: EmailNotificationOrderByRelationAggregateInput
    push_notification?: PushNotificationOrderByRelationAggregateInput
    device_notification?: DeviceNotificationOrderByRelationAggregateInput
  }

  export type NotificationsWhereUniqueInput = {
    id?: string
  }

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumTypeNotificationWithAggregatesFilter | TypeNotification
  }

  export type EmailNotificationWhereInput = {
    AND?: Enumerable<EmailNotificationWhereInput>
    OR?: Enumerable<EmailNotificationWhereInput>
    NOT?: Enumerable<EmailNotificationWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    to?: StringFilter | string
    from?: StringFilter | string
    from_name?: StringFilter | string
    cc?: StringNullableFilter | string | null
    bcc?: StringNullableFilter | string | null
    type?: EnumEmailTypeNotificationFilter | EmailTypeNotification
    subject?: StringFilter | string
    body?: StringFilter | string
    url_callback?: StringFilter | string
    opened?: StringNullableFilter | string | null
    clicked?: StringNullableFilter | string | null
    failed?: StringNullableFilter | string | null
    error_description?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type EmailNotificationOrderByWithRelationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmailNotificationWhereUniqueInput = {
    id?: string
  }

  export type EmailNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: EmailNotificationCountOrderByAggregateInput
    _max?: EmailNotificationMaxOrderByAggregateInput
    _min?: EmailNotificationMinOrderByAggregateInput
  }

  export type EmailNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmailNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmailNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmailNotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    to?: StringWithAggregatesFilter | string
    from?: StringWithAggregatesFilter | string
    from_name?: StringWithAggregatesFilter | string
    cc?: StringNullableWithAggregatesFilter | string | null
    bcc?: StringNullableWithAggregatesFilter | string | null
    type?: EnumEmailTypeNotificationWithAggregatesFilter | EmailTypeNotification
    subject?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    url_callback?: StringWithAggregatesFilter | string
    opened?: StringNullableWithAggregatesFilter | string | null
    clicked?: StringNullableWithAggregatesFilter | string | null
    failed?: StringNullableWithAggregatesFilter | string | null
    error_description?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SmsNotificationWhereInput = {
    AND?: Enumerable<SmsNotificationWhereInput>
    OR?: Enumerable<SmsNotificationWhereInput>
    NOT?: Enumerable<SmsNotificationWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    to?: StringFilter | string
    subject?: StringFilter | string
    body?: StringFilter | string
    send?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SmsNotificationOrderByWithRelationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SmsNotificationWhereUniqueInput = {
    id?: string
  }

  export type SmsNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SmsNotificationCountOrderByAggregateInput
    _max?: SmsNotificationMaxOrderByAggregateInput
    _min?: SmsNotificationMinOrderByAggregateInput
  }

  export type SmsNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SmsNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<SmsNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SmsNotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    device_id?: StringWithAggregatesFilter | string
    to?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    send?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PushNotificationWhereInput = {
    AND?: Enumerable<PushNotificationWhereInput>
    OR?: Enumerable<PushNotificationWhereInput>
    NOT?: Enumerable<PushNotificationWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    title?: StringFilter | string
    subject?: StringFilter | string
    send?: StringNullableFilter | string | null
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PushNotificationOrderByWithRelationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationWhereUniqueInput = {
    id?: string
  }

  export type PushNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PushNotificationCountOrderByAggregateInput
    _max?: PushNotificationMaxOrderByAggregateInput
    _min?: PushNotificationMinOrderByAggregateInput
  }

  export type PushNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PushNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<PushNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PushNotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    send?: StringNullableWithAggregatesFilter | string | null
    device_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DeviceNotificationWhereInput = {
    AND?: Enumerable<DeviceNotificationWhereInput>
    OR?: Enumerable<DeviceNotificationWhereInput>
    NOT?: Enumerable<DeviceNotificationWhereInput>
    device_id?: StringFilter | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    notification_id?: StringFilter | string
    notification?: XOR<NotificationsRelationFilter, NotificationsWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceNotificationOrderByWithRelationInput = {
    device_id?: SortOrder
    device?: DeviceOrderByWithRelationInput
    notification_id?: SortOrder
    notification?: NotificationsOrderByWithRelationInput
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationWhereUniqueInput = {
    device_id_notification_id?: DeviceNotificationDevice_idNotification_idCompoundUniqueInput
  }

  export type DeviceNotificationOrderByWithAggregationInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeviceNotificationCountOrderByAggregateInput
    _max?: DeviceNotificationMaxOrderByAggregateInput
    _min?: DeviceNotificationMinOrderByAggregateInput
  }

  export type DeviceNotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeviceNotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeviceNotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeviceNotificationScalarWhereWithAggregatesInput>
    device_id?: StringWithAggregatesFilter | string
    notification_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PlanWhereInput = {
    AND?: Enumerable<PlanWhereInput>
    OR?: Enumerable<PlanWhereInput>
    NOT?: Enumerable<PlanWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    description?: StringFilter | string
    slug?: StringFilter | string
    price?: FloatFilter | number
    max_users?: IntFilter | number
    max_labels?: IntFilter | number
    payment_cycle_id?: StringFilter | string
    payment_cycle?: XOR<PaymentCycleRelationFilter, PaymentCycleWhereInput>
    account?: AccountListRelationFilter
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    subscription?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    payment_cycle?: PaymentCycleOrderByWithRelationInput
    account?: AccountOrderByRelationAggregateInput
    created_at?: SortOrder
    updated_at?: SortOrder
    subscription?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlanScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlanScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    max_users?: IntWithAggregatesFilter | number
    max_labels?: IntWithAggregatesFilter | number
    payment_cycle_id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PaymentCycleWhereInput = {
    AND?: Enumerable<PaymentCycleWhereInput>
    OR?: Enumerable<PaymentCycleWhereInput>
    NOT?: Enumerable<PaymentCycleWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    plans?: PlanListRelationFilter
  }

  export type PaymentCycleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plans?: PlanOrderByRelationAggregateInput
  }

  export type PaymentCycleWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type PaymentCycleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PaymentCycleCountOrderByAggregateInput
    _max?: PaymentCycleMaxOrderByAggregateInput
    _min?: PaymentCycleMinOrderByAggregateInput
  }

  export type PaymentCycleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentCycleScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentCycleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentCycleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: Enumerable<SubscriptionWhereInput>
    OR?: Enumerable<SubscriptionWhereInput>
    NOT?: Enumerable<SubscriptionWhereInput>
    id?: StringFilter | string
    plan_id?: StringFilter | string
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    due?: DateTimeFilter | Date | string
    price?: FloatFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    plan?: PlanOrderByWithRelationInput
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionWhereUniqueInput = {
    id?: string
  }

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    plan_id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    due?: DateTimeWithAggregatesFilter | Date | string
    price?: FloatWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StockItemWhereInput = {
    AND?: Enumerable<StockItemWhereInput>
    OR?: Enumerable<StockItemWhereInput>
    NOT?: Enumerable<StockItemWhereInput>
    item_id?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    account_id?: StringFilter | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    quantity?: IntFilter | number
    min_quantity?: IntFilter | number
    max_quantity?: IntFilter | number
  }

  export type StockItemOrderByWithRelationInput = {
    item_id?: SortOrder
    item?: ItemOrderByWithRelationInput
    account_id?: SortOrder
    account?: AccountOrderByWithRelationInput
    quantity?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockItemWhereUniqueInput = {
    item_id_account_id?: StockItemItem_idAccount_idCompoundUniqueInput
  }

  export type StockItemOrderByWithAggregationInput = {
    item_id?: SortOrder
    account_id?: SortOrder
    quantity?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
    _count?: StockItemCountOrderByAggregateInput
    _avg?: StockItemAvgOrderByAggregateInput
    _max?: StockItemMaxOrderByAggregateInput
    _min?: StockItemMinOrderByAggregateInput
    _sum?: StockItemSumOrderByAggregateInput
  }

  export type StockItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StockItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<StockItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StockItemScalarWhereWithAggregatesInput>
    item_id?: StringWithAggregatesFilter | string
    account_id?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    min_quantity?: IntWithAggregatesFilter | number
    max_quantity?: IntWithAggregatesFilter | number
  }

  export type StockHistoryWhereInput = {
    AND?: Enumerable<StockHistoryWhereInput>
    OR?: Enumerable<StockHistoryWhereInput>
    NOT?: Enumerable<StockHistoryWhereInput>
    id?: StringFilter | string
    item_id?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    reason?: StringNullableFilter | string | null
    operation?: EnumStockHistoryTypeFilter | StockHistoryType
    quantity?: IntFilter | number
    date?: DateTimeFilter | Date | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StockHistoryOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    item?: ItemOrderByWithRelationInput
    reason?: SortOrder
    operation?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistoryWhereUniqueInput = {
    id?: string
  }

  export type StockHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    reason?: SortOrder
    operation?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StockHistoryCountOrderByAggregateInput
    _avg?: StockHistoryAvgOrderByAggregateInput
    _max?: StockHistoryMaxOrderByAggregateInput
    _min?: StockHistoryMinOrderByAggregateInput
    _sum?: StockHistorySumOrderByAggregateInput
  }

  export type StockHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StockHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<StockHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StockHistoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    item_id?: StringWithAggregatesFilter | string
    reason?: StringNullableWithAggregatesFilter | string | null
    operation?: EnumStockHistoryTypeWithAggregatesFilter | StockHistoryType
    quantity?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WineryWhereInput = {
    AND?: Enumerable<WineryWhereInput>
    OR?: Enumerable<WineryWhereInput>
    NOT?: Enumerable<WineryWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    items?: ItemListRelationFilter
  }

  export type WineryOrderByWithRelationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type WineryWhereUniqueInput = {
    id?: string
    external_id?: number
  }

  export type WineryOrderByWithAggregationInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WineryCountOrderByAggregateInput
    _avg?: WineryAvgOrderByAggregateInput
    _max?: WineryMaxOrderByAggregateInput
    _min?: WineryMinOrderByAggregateInput
    _sum?: WinerySumOrderByAggregateInput
  }

  export type WineryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WineryScalarWhereWithAggregatesInput>
    OR?: Enumerable<WineryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WineryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    external_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    domain: string
    isActive?: boolean
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountConfigurationCreateInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_configurationInput
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUncheckedCreateInput = {
    id?: string
    account_id: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_configurationNestedInput
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationCreateManyInput = {
    id?: string
    account_id: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountActivitiesCreateInput = {
    account: AccountCreateNestedOneWithoutAccount_activitiesInput
    activities: ActivitiesCreateNestedOneWithoutAccount_activitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUncheckedCreateInput = {
    account_id: string
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUpdateInput = {
    account?: AccountUpdateOneRequiredWithoutAccount_activitiesNestedInput
    activities?: ActivitiesUpdateOneRequiredWithoutAccount_activitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesCreateManyInput = {
    account_id: string
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateManyInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivitiesCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesCreateNestedManyWithoutActivitiesInput
  }

  export type ActivitiesUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutActivitiesInput
  }

  export type ActivitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutActivitiesNestedInput
  }

  export type ActivitiesCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_deliveries?: AccountDeliveryUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryCreateInput = {
    account: AccountCreateNestedOneWithoutAccount_deliveriesInput
    delivery: DeliveryCreateNestedOneWithoutAccount_deliveriesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryUncheckedCreateInput = {
    account_id: string
    delivery_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryUpdateInput = {
    account?: AccountUpdateOneRequiredWithoutAccount_deliveriesNestedInput
    delivery?: DeliveryUpdateOneRequiredWithoutAccount_deliveriesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryUncheckedUpdateInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    delivery_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryCreateManyInput = {
    account_id: string
    delivery_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryUncheckedUpdateManyInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    delivery_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutUserInput
    account_user?: AccountUserCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    account_user?: AccountUserUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutUser_addressesInput
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    orders?: OrderCreateNestedManyWithoutUser_addressInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressUncheckedCreateInput = {
    id?: string
    user_id: string
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    orders?: OrderUncheckedCreateNestedManyWithoutUser_addressInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUser_addressesNestedInput
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    orders?: OrderUpdateManyWithoutUser_addressNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutUser_addressNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressCreateManyInput = {
    id?: string
    user_id: string
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserCreateInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_usersInput
    user: UserCreateNestedOneWithoutAccount_userInput
    role: RoleCreateNestedOneWithoutAccountUserInput
  }

  export type AccountUserUncheckedCreateInput = {
    id?: string
    account_id: string
    user_id: string
    role_id: string
  }

  export type AccountUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_usersNestedInput
    user?: UserUpdateOneRequiredWithoutAccount_userNestedInput
    role?: RoleUpdateOneRequiredWithoutAccountUserNestedInput
  }

  export type AccountUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserCreateManyInput = {
    id?: string
    account_id: string
    user_id: string
    role_id: string
  }

  export type AccountUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type PermisionCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermisionUncheckedCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermisionCreateManyInput = {
    id?: string
    name: string
  }

  export type PermisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateInput = {
    role: RoleCreateNestedOneWithoutRolePermissionInput
    permission: PermisionCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateInput = {
    role_id: string
    permission_id: string
  }

  export type RolePermissionUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionNestedInput
    permission?: PermisionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    permission_id?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyInput = {
    role_id: string
    permission_id: string
  }

  export type RolePermissionUpdateManyMutationInput = {

  }

  export type RolePermissionUncheckedUpdateManyInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    permission_id?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionCreateNestedManyWithoutRoleInput
    AccountUser?: AccountUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    AccountUser?: AccountUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUpdateManyWithoutRoleNestedInput
    AccountUser?: AccountUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    AccountUser?: AccountUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    account: AccountCreateNestedOneWithoutCampaignInput
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCampaignInput
    campaign_items?: CampaignItemCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCampaignInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCampaignNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTypeCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    Campaign?: CampaignCreateNestedManyWithoutCampaign_typeInput
  }

  export type CampaignTypeUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    Campaign?: CampaignUncheckedCreateNestedManyWithoutCampaign_typeInput
  }

  export type CampaignTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Campaign?: CampaignUpdateManyWithoutCampaign_typeNestedInput
  }

  export type CampaignTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Campaign?: CampaignUncheckedUpdateManyWithoutCampaign_typeNestedInput
  }

  export type CampaignTypeCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
  }

  export type CampaignTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    account: AccountCreateNestedOneWithoutCouponsInput
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    account_id: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutCouponsNestedInput
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    account_id: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    items?: ItemCreateNestedManyWithoutItem_typeInput
  }

  export type ItemTypeUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutItem_typeInput
  }

  export type ItemTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUpdateManyWithoutItem_typeNestedInput
  }

  export type ItemTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutItem_typeNestedInput
  }

  export type ItemTypeCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    ItemTag?: ItemTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ItemTag?: ItemTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ItemTag?: ItemTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagCreateInput = {
    item: ItemCreateNestedOneWithoutItemTagInput
    tag: TagCreateNestedOneWithoutItemTagInput
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagUncheckedCreateInput = {
    item_id: string
    tag_id: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutItemTagNestedInput
    tag?: TagUpdateOneRequiredWithoutItemTagNestedInput
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagUncheckedUpdateInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagCreateManyInput = {
    item_id: string
    tag_id: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagUncheckedUpdateManyInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignItemCreateInput = {
    item: ItemCreateNestedOneWithoutCampaign_itemsInput
    campaign: CampaignCreateNestedOneWithoutCampaign_itemsInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemUncheckedCreateInput = {
    item_id: string
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutCampaign_itemsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_itemsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignItemUncheckedUpdateInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignItemCreateManyInput = {
    item_id: string
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignItemUncheckedUpdateManyInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeCreateInput = {
    item: ItemCreateNestedOneWithoutItem_grapeInput
    grape: GrapeCreateNestedOneWithoutItem_grapeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeUncheckedCreateInput = {
    item_id: string
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutItem_grapeNestedInput
    grape?: GrapeUpdateOneRequiredWithoutItem_grapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeUncheckedUpdateInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeCreateManyInput = {
    item_id: string
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeUncheckedUpdateManyInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    item_grape?: ItemGrapeCreateNestedManyWithoutGrapeInput
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutGrapeInput
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    item_grape?: ItemGrapeUpdateManyWithoutGrapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutGrapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    value: string
    states?: StateCreateNestedManyWithoutCountryInput
    items?: ItemCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    value: string
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
    items?: ItemUncheckedCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUpdateManyWithoutCountryNestedInput
    items?: ItemUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUncheckedUpdateManyWithoutCountryNestedInput
    items?: ItemUncheckedUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    country: CountryCreateNestedOneWithoutStatesInput
    regions?: RegionCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    country_id: string
    regions?: RegionUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    regions?: RegionUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    regions?: RegionUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    country_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    state: StateCreateNestedOneWithoutCitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    state_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    state_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateInput = {
    id?: string
    external_id?: number | null
    state: StateCreateNestedOneWithoutRegionsInput
    name: string
    slug: string
    subregion?: SubRegionCreateNestedManyWithoutRegionInput
    items?: ItemCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    state_id: string
    name: string
    slug: string
    subregion?: SubRegionUncheckedCreateNestedManyWithoutRegionInput
    items?: ItemUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: StateUpdateOneRequiredWithoutRegionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUpdateManyWithoutRegionNestedInput
    items?: ItemUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUncheckedUpdateManyWithoutRegionNestedInput
    items?: ItemUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateManyInput = {
    id?: string
    external_id?: number | null
    state_id: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    region: RegionCreateNestedOneWithoutSubregionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    region_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutSubregionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    region_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    items?: ItemCreateNestedManyWithoutWine_typeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    items?: ItemUncheckedCreateNestedManyWithoutWine_typeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutWine_typeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutWine_typeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutOrder_statusInput
  }

  export type OrderStatusUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOrder_statusInput
  }

  export type OrderStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOrder_statusNestedInput
  }

  export type OrderStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOrder_statusNestedInput
  }

  export type OrderStatusCreateManyInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    account: AccountCreateNestedOneWithoutCustomersInput
    email: string
    mobile_phone: string
    phone: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    origin_registration: CustomerOriginRegistration
    cpf_cnpj: string
    note: string
    converted?: boolean
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    account_id: string
    email: string
    mobile_phone: string
    phone: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    origin_registration: CustomerOriginRegistration
    cpf_cnpj: string
    note: string
    converted?: boolean
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutCustomersNestedInput
    email?: StringFieldUpdateOperationsInput | string
    mobile_phone?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFieldUpdateOperationsInput | CustomerOriginRegistration
    cpf_cnpj?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile_phone?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFieldUpdateOperationsInput | CustomerOriginRegistration
    cpf_cnpj?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerCreateManyInput = {
    id?: string
    account_id: string
    email: string
    mobile_phone: string
    phone: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    origin_registration: CustomerOriginRegistration
    cpf_cnpj: string
    note: string
    converted?: boolean
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile_phone?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFieldUpdateOperationsInput | CustomerOriginRegistration
    cpf_cnpj?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile_phone?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFieldUpdateOperationsInput | CustomerOriginRegistration
    cpf_cnpj?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemCreateInput = {
    order: OrderCreateNestedOneWithoutOrder_itemsInput
    item: ItemCreateNestedOneWithoutOrder_itemsInput
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type OrderItemUncheckedCreateInput = {
    order_id: string
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type OrderItemUpdateInput = {
    order?: OrderUpdateOneRequiredWithoutOrder_itemsNestedInput
    item?: ItemUpdateOneRequiredWithoutOrder_itemsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    order_id: string
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type OrderItemUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateInput = {
    id?: string
    order: OrderCreateNestedOneWithoutInvoiceInput
    account: AccountCreateNestedOneWithoutInvoicesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    order_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
    account?: AccountUpdateOneRequiredWithoutInvoicesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    order_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateInput = {
    device: DeviceCreateNestedOneWithoutDevice_userInput
    user: UserCreateNestedOneWithoutDevice_userInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUncheckedCreateInput = {
    device_id: string
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUpdateInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_userNestedInput
    user?: UserUpdateOneRequiredWithoutDevice_userNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateManyInput = {
    device_id: string
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateManyInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsCreateManyInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
  }

  export type NotificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
  }

  export type EmailNotificationCreateInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutEmail_notificationInput
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUncheckedCreateInput = {
    id?: string
    notification_id: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutEmail_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationCreateManyInput = {
    id?: string
    notification_id: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationCreateInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutSms_notificationInput
    device: DeviceCreateNestedOneWithoutSms_notificationInput
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUncheckedCreateInput = {
    id?: string
    notification_id: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutSms_notificationNestedInput
    device?: DeviceUpdateOneRequiredWithoutSms_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationCreateManyInput = {
    id?: string
    notification_id: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationCreateInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutPush_notificationInput
    title: string
    subject: string
    send?: string | null
    device: DeviceCreateNestedOneWithoutPush_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUncheckedCreateInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutPush_notificationNestedInput
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutPush_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationCreateManyInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationCreateInput = {
    device: DeviceCreateNestedOneWithoutDevice_notificationInput
    notification: NotificationsCreateNestedOneWithoutDevice_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUncheckedCreateInput = {
    device_id: string
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUpdateInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_notificationNestedInput
    notification?: NotificationsUpdateOneRequiredWithoutDevice_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationCreateManyInput = {
    device_id: string
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateManyInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle: PaymentCycleCreateNestedOneWithoutPlansInput
    account?: AccountCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    account?: AccountUncheckedCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle?: PaymentCycleUpdateOneRequiredWithoutPlansNestedInput
    account?: AccountUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    account?: AccountUncheckedUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCycleCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    plans?: PlanCreateNestedManyWithoutPayment_cycleInput
  }

  export type PaymentCycleUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    plans?: PlanUncheckedCreateNestedManyWithoutPayment_cycleInput
  }

  export type PaymentCycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUpdateManyWithoutPayment_cycleNestedInput
  }

  export type PaymentCycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plans?: PlanUncheckedUpdateManyWithoutPayment_cycleNestedInput
  }

  export type PaymentCycleCreateManyInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: PlanCreateNestedOneWithoutSubscriptionInput
    account: AccountCreateNestedOneWithoutSubscriptionInput
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    plan_id: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
    account?: AccountUpdateOneRequiredWithoutSubscriptionNestedInput
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    plan_id: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemCreateInput = {
    item: ItemCreateNestedOneWithoutStock_itemsInput
    account: AccountCreateNestedOneWithoutStock_itemsInput
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockItemUncheckedCreateInput = {
    item_id: string
    account_id: string
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockItemUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutStock_itemsNestedInput
    account?: AccountUpdateOneRequiredWithoutStock_itemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockItemUncheckedUpdateInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockItemCreateManyInput = {
    item_id: string
    account_id: string
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockItemUncheckedUpdateManyInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockHistoryCreateInput = {
    id?: string
    item: ItemCreateNestedOneWithoutStock_historyInput
    reason?: string | null
    operation: StockHistoryType
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUncheckedCreateInput = {
    id?: string
    item_id: string
    reason?: string | null
    operation: StockHistoryType
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item?: ItemUpdateOneRequiredWithoutStock_historyNestedInput
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: EnumStockHistoryTypeFieldUpdateOperationsInput | StockHistoryType
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: EnumStockHistoryTypeFieldUpdateOperationsInput | StockHistoryType
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryCreateManyInput = {
    id?: string
    item_id: string
    reason?: string | null
    operation: StockHistoryType
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: EnumStockHistoryTypeFieldUpdateOperationsInput | StockHistoryType
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: EnumStockHistoryTypeFieldUpdateOperationsInput | StockHistoryType
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineryCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    items?: ItemCreateNestedManyWithoutWineryInput
  }

  export type WineryUncheckedCreateInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutWineryInput
  }

  export type WineryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUpdateManyWithoutWineryNestedInput
  }

  export type WineryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutWineryNestedInput
  }

  export type WineryCreateManyInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumPersonTypeFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeFilter | PersonType
  }

  export type EnumGenderTypeFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeFilter | GenderType
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type AccountActivitiesListRelationFilter = {
    every?: AccountActivitiesWhereInput
    some?: AccountActivitiesWhereInput
    none?: AccountActivitiesWhereInput
  }

  export type AccountDeliveryListRelationFilter = {
    every?: AccountDeliveryWhereInput
    some?: AccountDeliveryWhereInput
    none?: AccountDeliveryWhereInput
  }

  export type AccountUserListRelationFilter = {
    every?: AccountUserWhereInput
    some?: AccountUserWhereInput
    none?: AccountUserWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type StockItemListRelationFilter = {
    every?: StockItemWhereInput
    some?: StockItemWhereInput
    none?: StockItemWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type CouponListRelationFilter = {
    every?: CouponWhereInput
    some?: CouponWhereInput
    none?: CouponWhereInput
  }

  export type AccountConfigurationRelationFilter = {
    is?: AccountConfigurationWhereInput | null
    isNot?: AccountConfigurationWhereInput | null
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountActivitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf_cnpj?: SortOrder
    market_name?: SortOrder
    phone?: SortOrder
    whatsapp?: SortOrder
    logo?: SortOrder
    person_type?: SortOrder
    site?: SortOrder
    social_reason?: SortOrder
    facebook_url?: SortOrder
    instagram_url?: SortOrder
    banner?: SortOrder
    gender?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipcode?: SortOrder
    plan_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumPersonTypeWithAggregatesFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeWithAggregatesFilter | PersonType
    _count?: NestedIntFilter
    _min?: NestedEnumPersonTypeFilter
    _max?: NestedEnumPersonTypeFilter
  }

  export type EnumGenderTypeWithAggregatesFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeWithAggregatesFilter | GenderType
    _count?: NestedIntFilter
    _min?: NestedEnumGenderTypeFilter
    _max?: NestedEnumGenderTypeFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type AccountConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type AccountConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banner_market_url?: SortOrder
    header_color?: SortOrder
  }

  export type ActivitiesRelationFilter = {
    is?: ActivitiesWhereInput
    isNot?: ActivitiesWhereInput
  }

  export type AccountActivitiesAccount_idActivities_idCompoundUniqueInput = {
    account_id: string
    activities_id: string
  }

  export type AccountActivitiesCountOrderByAggregateInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountActivitiesMaxOrderByAggregateInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountActivitiesMinOrderByAggregateInput = {
    account_id?: SortOrder
    activities_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitiesCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitiesAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type ActivitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitiesMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivitiesSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliverySumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type DeliveryRelationFilter = {
    is?: DeliveryWhereInput
    isNot?: DeliveryWhereInput
  }

  export type AccountDeliveryAccount_idDelivery_idCompoundUniqueInput = {
    account_id: string
    delivery_id: string
  }

  export type AccountDeliveryCountOrderByAggregateInput = {
    account_id?: SortOrder
    delivery_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountDeliveryMaxOrderByAggregateInput = {
    account_id?: SortOrder
    delivery_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AccountDeliveryMinOrderByAggregateInput = {
    account_id?: SortOrder
    delivery_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type DeviceUserListRelationFilter = {
    every?: DeviceUserWhereInput
    some?: DeviceUserWhereInput
    none?: DeviceUserWhereInput
  }

  export type UserAddressListRelationFilter = {
    every?: UserAddressWhereInput
    some?: UserAddressWhereInput
    none?: UserAddressWhereInput
  }

  export type DeviceUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    rd_station_id?: SortOrder
    rd_station_sync?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    rd_station_id?: SortOrder
    rd_station_sync?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    cpf_cnpj?: SortOrder
    photo?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    google_id?: SortOrder
    apple_id?: SortOrder
    facebook_id?: SortOrder
    rd_station_id?: SortOrder
    rd_station_sync?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lastLogin?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    additional_information?: SortOrder
    city?: SortOrder
    zip_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    additional_information?: SortOrder
    city?: SortOrder
    zip_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    number?: SortOrder
    district?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    additional_information?: SortOrder
    city?: SortOrder
    zip_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type AccountUserAccount_idUser_idIdCompoundUniqueInput = {
    account_id: string
    user_id: string
    id: string
  }

  export type AccountUserCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type AccountUserMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type AccountUserMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermisionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermisionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermisionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermisionRelationFilter = {
    is?: PermisionWhereInput
    isNot?: PermisionWhereInput
  }

  export type RolePermissionRole_idPermission_idCompoundUniqueInput = {
    role_id: string
    permission_id: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type EnumCampaignTypeDiscountNullableFilter = {
    equals?: CampaignTypeDiscount | null
    in?: Enumerable<CampaignTypeDiscount> | null
    notIn?: Enumerable<CampaignTypeDiscount> | null
    not?: NestedEnumCampaignTypeDiscountNullableFilter | CampaignTypeDiscount | null
  }

  export type CampaignTypeRelationFilter = {
    is?: CampaignTypeWhereInput
    isNot?: CampaignTypeWhereInput
  }

  export type CampaignItemListRelationFilter = {
    every?: CampaignItemWhereInput
    some?: CampaignItemWhereInput
    none?: CampaignItemWhereInput
  }

  export type CampaignItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discount_value?: SortOrder
    discount_type?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    campaign_type_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    external_id?: SortOrder
    discount_value?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discount_value?: SortOrder
    discount_type?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    campaign_type_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discount_value?: SortOrder
    discount_type?: SortOrder
    start_date?: SortOrder
    expiration_date?: SortOrder
    campaign_type_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    external_id?: SortOrder
    discount_value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumCampaignTypeDiscountNullableWithAggregatesFilter = {
    equals?: CampaignTypeDiscount | null
    in?: Enumerable<CampaignTypeDiscount> | null
    notIn?: Enumerable<CampaignTypeDiscount> | null
    not?: NestedEnumCampaignTypeDiscountNullableWithAggregatesFilter | CampaignTypeDiscount | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCampaignTypeDiscountNullableFilter
    _max?: NestedEnumCampaignTypeDiscountNullableFilter
  }

  export type CampaignTypeCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CampaignTypeAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type CampaignTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CampaignTypeMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CampaignTypeSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type EnumCouponDiscountTypeFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeFilter | CouponDiscountType
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type EnumCouponUseTypeFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeFilter | CouponUseType
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    discount_value?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    dicount_type?: SortOrder
    discount_value?: SortOrder
    couponUse_type?: SortOrder
    inital_date?: SortOrder
    expiration_date?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    discount_value?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
  }

  export type EnumCouponDiscountTypeWithAggregatesFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeWithAggregatesFilter | CouponDiscountType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponDiscountTypeFilter
    _max?: NestedEnumCouponDiscountTypeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type EnumCouponUseTypeWithAggregatesFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeWithAggregatesFilter | CouponUseType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponUseTypeFilter
    _max?: NestedEnumCouponUseTypeFilter
  }

  export type ItemTypeRelationFilter = {
    is?: ItemTypeWhereInput
    isNot?: ItemTypeWhereInput
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type WineryRelationFilter = {
    is?: WineryWhereInput | null
    isNot?: WineryWhereInput | null
  }

  export type WineTypeRelationFilter = {
    is?: WineTypeWhereInput | null
    isNot?: WineTypeWhereInput | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemGrapeListRelationFilter = {
    every?: ItemGrapeWhereInput
    some?: ItemGrapeWhereInput
    none?: ItemGrapeWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type StockHistoryListRelationFilter = {
    every?: StockHistoryWhereInput
    some?: StockHistoryWhereInput
    none?: StockHistoryWhereInput
  }

  export type ItemTagListRelationFilter = {
    every?: ItemTagWhereInput
    some?: ItemTagWhereInput
    none?: ItemTagWhereInput
  }

  export type ItemGrapeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    winery_id?: SortOrder
    harvest?: SortOrder
    no_harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    photo?: SortOrder
    account_id?: SortOrder
    is_active?: SortOrder
    control_stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    external_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    winery_id?: SortOrder
    harvest?: SortOrder
    no_harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    photo?: SortOrder
    account_id?: SortOrder
    is_active?: SortOrder
    control_stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    country_id?: SortOrder
    region_id?: SortOrder
    winery_id?: SortOrder
    harvest?: SortOrder
    no_harvest?: SortOrder
    wine_type_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
    photo?: SortOrder
    account_id?: SortOrder
    is_active?: SortOrder
    control_stock?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    external_id?: SortOrder
    alcohol_percentage?: SortOrder
    price?: SortOrder
    promotional_price?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type ItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemTypeAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type ItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemTypeSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ItemTagItem_idTag_idCompoundUniqueInput = {
    item_id: string
    tag_id: string
  }

  export type ItemTagCountOrderByAggregateInput = {
    item_id?: SortOrder
    tag_id?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemTagMaxOrderByAggregateInput = {
    item_id?: SortOrder
    tag_id?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemTagMinOrderByAggregateInput = {
    item_id?: SortOrder
    tag_id?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type CampaignItemItem_idCampaign_idCompoundUniqueInput = {
    item_id: string
    campaign_id: string
  }

  export type CampaignItemCountOrderByAggregateInput = {
    item_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignItemMaxOrderByAggregateInput = {
    item_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CampaignItemMinOrderByAggregateInput = {
    item_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GrapeRelationFilter = {
    is?: GrapeWhereInput
    isNot?: GrapeWhereInput
  }

  export type ItemGrapeItem_idGrape_idCompoundUniqueInput = {
    item_id: string
    grape_id: string
  }

  export type ItemGrapeCountOrderByAggregateInput = {
    item_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemGrapeMaxOrderByAggregateInput = {
    item_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ItemGrapeMinOrderByAggregateInput = {
    item_id?: SortOrder
    grape_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GrapeCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrapeAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type GrapeMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrapeMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type GrapeSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type StateListRelationFilter = {
    every?: StateWhereInput
    some?: StateWhereInput
    none?: StateWhereInput
  }

  export type StateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type RegionListRelationFilter = {
    every?: RegionWhereInput
    some?: RegionWhereInput
    none?: RegionWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type RegionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StateSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type SubRegionListRelationFilter = {
    every?: SubRegionWhereInput
    some?: SubRegionWhereInput
    none?: SubRegionWhereInput
  }

  export type SubRegionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    state_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type SubRegionCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type SubRegionMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubRegionSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type WineTypeCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type WineTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineTypeSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type CouponRelationFilter = {
    is?: CouponWhereInput | null
    isNot?: CouponWhereInput | null
  }

  export type UserAddressRelationFilter = {
    is?: UserAddressWhereInput
    isNot?: UserAddressWhereInput
  }

  export type OrderStatusRelationFilter = {
    is?: OrderStatusWhereInput
    isNot?: OrderStatusWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    user_address_id?: SortOrder
    is_read?: SortOrder
    order_status_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    external_id?: SortOrder
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    user_address_id?: SortOrder
    is_read?: SortOrder
    order_status_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    code?: SortOrder
    account_id?: SortOrder
    total?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    user_address_id?: SortOrder
    is_read?: SortOrder
    order_status_id?: SortOrder
    campaign_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    external_id?: SortOrder
    total?: SortOrder
  }

  export type OrderStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumCustomerOriginRegistrationFilter = {
    equals?: CustomerOriginRegistration
    in?: Enumerable<CustomerOriginRegistration>
    notIn?: Enumerable<CustomerOriginRegistration>
    not?: NestedEnumCustomerOriginRegistrationFilter | CustomerOriginRegistration
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    email?: SortOrder
    mobile_phone?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    origin_registration?: SortOrder
    cpf_cnpj?: SortOrder
    note?: SortOrder
    converted?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    email?: SortOrder
    mobile_phone?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    origin_registration?: SortOrder
    cpf_cnpj?: SortOrder
    note?: SortOrder
    converted?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    email?: SortOrder
    mobile_phone?: SortOrder
    phone?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    origin_registration?: SortOrder
    cpf_cnpj?: SortOrder
    note?: SortOrder
    converted?: SortOrder
  }

  export type EnumCustomerOriginRegistrationWithAggregatesFilter = {
    equals?: CustomerOriginRegistration
    in?: Enumerable<CustomerOriginRegistration>
    notIn?: Enumerable<CustomerOriginRegistration>
    not?: NestedEnumCustomerOriginRegistrationWithAggregatesFilter | CustomerOriginRegistration
    _count?: NestedIntFilter
    _min?: NestedEnumCustomerOriginRegistrationFilter
    _max?: NestedEnumCustomerOriginRegistrationFilter
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type OrderItemOrder_idItem_idCompoundUniqueInput = {
    order_id: string
    item_id: string
  }

  export type OrderItemCountOrderByAggregateInput = {
    order_id?: SortOrder
    item_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    order_id?: SortOrder
    item_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    order_id?: SortOrder
    item_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumPlatformTypeFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeFilter | PlatformType
  }

  export type PushNotificationListRelationFilter = {
    every?: PushNotificationWhereInput
    some?: PushNotificationWhereInput
    none?: PushNotificationWhereInput
  }

  export type SmsNotificationListRelationFilter = {
    every?: SmsNotificationWhereInput
    some?: SmsNotificationWhereInput
    none?: SmsNotificationWhereInput
  }

  export type DeviceNotificationListRelationFilter = {
    every?: DeviceNotificationWhereInput
    some?: DeviceNotificationWhereInput
    none?: DeviceNotificationWhereInput
  }

  export type PushNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SmsNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    device_physical_id?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    token_notification?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type EnumPlatformTypeWithAggregatesFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeWithAggregatesFilter | PlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumPlatformTypeFilter
    _max?: NestedEnumPlatformTypeFilter
  }

  export type DeviceRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type DeviceUserDevice_idUser_idCompoundUniqueInput = {
    device_id: string
    user_id: string
  }

  export type DeviceUserCountOrderByAggregateInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceUserMaxOrderByAggregateInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceUserMinOrderByAggregateInput = {
    device_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumTypeNotificationFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationFilter | TypeNotification
  }

  export type EmailNotificationListRelationFilter = {
    every?: EmailNotificationWhereInput
    some?: EmailNotificationWhereInput
    none?: EmailNotificationWhereInput
  }

  export type EmailNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    type?: SortOrder
  }

  export type EnumTypeNotificationWithAggregatesFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationWithAggregatesFilter | TypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumTypeNotificationFilter
    _max?: NestedEnumTypeNotificationFilter
  }

  export type NotificationsRelationFilter = {
    is?: NotificationsWhereInput
    isNot?: NotificationsWhereInput
  }

  export type EnumEmailTypeNotificationFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationFilter | EmailTypeNotification
  }

  export type EmailNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmailNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmailNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    to?: SortOrder
    from?: SortOrder
    from_name?: SortOrder
    cc?: SortOrder
    bcc?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    url_callback?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    failed?: SortOrder
    error_description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumEmailTypeNotificationWithAggregatesFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationWithAggregatesFilter | EmailTypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumEmailTypeNotificationFilter
    _max?: NestedEnumEmailTypeNotificationFilter
  }

  export type SmsNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SmsNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SmsNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    device_id?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    send?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PushNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    send?: SortOrder
    device_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationDevice_idNotification_idCompoundUniqueInput = {
    device_id: string
    notification_id: string
  }

  export type DeviceNotificationCountOrderByAggregateInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationMaxOrderByAggregateInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeviceNotificationMinOrderByAggregateInput = {
    device_id?: SortOrder
    notification_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentCycleRelationFilter = {
    is?: PaymentCycleWhereInput
    isNot?: PaymentCycleWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    external_id?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
    payment_cycle_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    external_id?: SortOrder
    price?: SortOrder
    max_users?: SortOrder
    max_labels?: SortOrder
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCycleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentCycleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentCycleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
    account_id?: SortOrder
    due?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type StockItemItem_idAccount_idCompoundUniqueInput = {
    item_id: string
    account_id: string
  }

  export type StockItemCountOrderByAggregateInput = {
    item_id?: SortOrder
    account_id?: SortOrder
    quantity?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockItemMaxOrderByAggregateInput = {
    item_id?: SortOrder
    account_id?: SortOrder
    quantity?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockItemMinOrderByAggregateInput = {
    item_id?: SortOrder
    account_id?: SortOrder
    quantity?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type StockItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    min_quantity?: SortOrder
    max_quantity?: SortOrder
  }

  export type EnumStockHistoryTypeFilter = {
    equals?: StockHistoryType
    in?: Enumerable<StockHistoryType>
    notIn?: Enumerable<StockHistoryType>
    not?: NestedEnumStockHistoryTypeFilter | StockHistoryType
  }

  export type StockHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    reason?: SortOrder
    operation?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    reason?: SortOrder
    operation?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    reason?: SortOrder
    operation?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockHistorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumStockHistoryTypeWithAggregatesFilter = {
    equals?: StockHistoryType
    in?: Enumerable<StockHistoryType>
    notIn?: Enumerable<StockHistoryType>
    not?: NestedEnumStockHistoryTypeWithAggregatesFilter | StockHistoryType
    _count?: NestedIntFilter
    _min?: NestedEnumStockHistoryTypeFilter
    _max?: NestedEnumStockHistoryTypeFilter
  }

  export type WineryCountOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineryAvgOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type WineryMaxOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WineryMinOrderByAggregateInput = {
    id?: SortOrder
    external_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WinerySumOrderByAggregateInput = {
    external_id?: SortOrder
  }

  export type CampaignCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type PlanCreateNestedOneWithoutAccountInput = {
    create?: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
    connectOrCreate?: PlanCreateOrConnectWithoutAccountInput
    connect?: PlanWhereUniqueInput
  }

  export type SubscriptionCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AccountActivitiesCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountDeliveryCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutAccountInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutAccountInput>
    createMany?: AccountDeliveryCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
  }

  export type AccountUserCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type InvoiceCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountInput>
    createMany?: InvoiceCreateManyAccountInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type StockItemCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutAccountInput>, Enumerable<StockItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutAccountInput>
    createMany?: StockItemCreateManyAccountInputEnvelope
    connect?: Enumerable<StockItemWhereUniqueInput>
  }

  export type ItemCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<ItemCreateWithoutAccountInput>, Enumerable<ItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutAccountInput>
    createMany?: ItemCreateManyAccountInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type CouponCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CouponCreateWithoutAccountInput>, Enumerable<CouponUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CouponCreateOrConnectWithoutAccountInput>
    createMany?: CouponCreateManyAccountInputEnvelope
    connect?: Enumerable<CouponWhereUniqueInput>
  }

  export type AccountConfigurationCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    connect?: AccountConfigurationWhereUniqueInput
  }

  export type CustomerCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutAccountInput>, Enumerable<CustomerUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutAccountInput>
    createMany?: CustomerCreateManyAccountInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutAccountInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutAccountInput>
    createMany?: AccountDeliveryCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
  }

  export type AccountUserUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountInput>
    createMany?: InvoiceCreateManyAccountInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type StockItemUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutAccountInput>, Enumerable<StockItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutAccountInput>
    createMany?: StockItemCreateManyAccountInputEnvelope
    connect?: Enumerable<StockItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<ItemCreateWithoutAccountInput>, Enumerable<ItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutAccountInput>
    createMany?: ItemCreateManyAccountInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type CouponUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CouponCreateWithoutAccountInput>, Enumerable<CouponUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CouponCreateOrConnectWithoutAccountInput>
    createMany?: CouponCreateManyAccountInputEnvelope
    connect?: Enumerable<CouponWhereUniqueInput>
  }

  export type AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    connect?: AccountConfigurationWhereUniqueInput
  }

  export type CustomerUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutAccountInput>, Enumerable<CustomerUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutAccountInput>
    createMany?: CustomerCreateManyAccountInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPersonTypeFieldUpdateOperationsInput = {
    set?: PersonType
  }

  export type EnumGenderTypeFieldUpdateOperationsInput = {
    set?: GenderType
  }

  export type CampaignUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type PlanUpdateOneWithoutAccountNestedInput = {
    create?: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
    connectOrCreate?: PlanCreateOrConnectWithoutAccountInput
    upsert?: PlanUpsertWithoutAccountInput
    disconnect?: boolean
    delete?: boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<PlanUpdateWithoutAccountInput, PlanUncheckedUpdateWithoutAccountInput>
  }

  export type SubscriptionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrderUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AccountActivitiesUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type AccountDeliveryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutAccountInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountDeliveryUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountDeliveryCreateManyAccountInputEnvelope
    set?: Enumerable<AccountDeliveryWhereUniqueInput>
    disconnect?: Enumerable<AccountDeliveryWhereUniqueInput>
    delete?: Enumerable<AccountDeliveryWhereUniqueInput>
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
    update?: Enumerable<AccountDeliveryUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountDeliveryUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountDeliveryScalarWhereInput>
  }

  export type AccountUserUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type InvoiceUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: InvoiceCreateManyAccountInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type StockItemUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutAccountInput>, Enumerable<StockItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<StockItemUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: StockItemCreateManyAccountInputEnvelope
    set?: Enumerable<StockItemWhereUniqueInput>
    disconnect?: Enumerable<StockItemWhereUniqueInput>
    delete?: Enumerable<StockItemWhereUniqueInput>
    connect?: Enumerable<StockItemWhereUniqueInput>
    update?: Enumerable<StockItemUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<StockItemUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<StockItemScalarWhereInput>
  }

  export type ItemUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutAccountInput>, Enumerable<ItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: ItemCreateManyAccountInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type CouponUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CouponCreateWithoutAccountInput>, Enumerable<CouponUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CouponCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CouponUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CouponCreateManyAccountInputEnvelope
    set?: Enumerable<CouponWhereUniqueInput>
    disconnect?: Enumerable<CouponWhereUniqueInput>
    delete?: Enumerable<CouponWhereUniqueInput>
    connect?: Enumerable<CouponWhereUniqueInput>
    update?: Enumerable<CouponUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CouponUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CouponScalarWhereInput>
  }

  export type AccountConfigurationUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    upsert?: AccountConfigurationUpsertWithoutAccountInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountConfigurationWhereUniqueInput
    update?: XOR<AccountConfigurationUpdateWithoutAccountInput, AccountConfigurationUncheckedUpdateWithoutAccountInput>
  }

  export type CustomerUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutAccountInput>, Enumerable<CustomerUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CustomerCreateManyAccountInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CampaignUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutAccountInput>, Enumerable<CampaignUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CampaignCreateManyAccountInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutAccountInput>, Enumerable<SubscriptionUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: SubscriptionCreateManyAccountInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAccountInput>, Enumerable<OrderUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: OrderCreateManyAccountInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutAccountInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountActivitiesCreateManyAccountInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutAccountInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountDeliveryUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountDeliveryCreateManyAccountInputEnvelope
    set?: Enumerable<AccountDeliveryWhereUniqueInput>
    disconnect?: Enumerable<AccountDeliveryWhereUniqueInput>
    delete?: Enumerable<AccountDeliveryWhereUniqueInput>
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
    update?: Enumerable<AccountDeliveryUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountDeliveryUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountDeliveryScalarWhereInput>
  }

  export type AccountUserUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutAccountInput>, Enumerable<AccountUserUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: AccountUserCreateManyAccountInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutAccountInput>, Enumerable<InvoiceUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: InvoiceCreateManyAccountInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type StockItemUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutAccountInput>, Enumerable<StockItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<StockItemUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: StockItemCreateManyAccountInputEnvelope
    set?: Enumerable<StockItemWhereUniqueInput>
    disconnect?: Enumerable<StockItemWhereUniqueInput>
    delete?: Enumerable<StockItemWhereUniqueInput>
    connect?: Enumerable<StockItemWhereUniqueInput>
    update?: Enumerable<StockItemUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<StockItemUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<StockItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutAccountInput>, Enumerable<ItemUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: ItemCreateManyAccountInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type CouponUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CouponCreateWithoutAccountInput>, Enumerable<CouponUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CouponCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CouponUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CouponCreateManyAccountInputEnvelope
    set?: Enumerable<CouponWhereUniqueInput>
    disconnect?: Enumerable<CouponWhereUniqueInput>
    delete?: Enumerable<CouponWhereUniqueInput>
    connect?: Enumerable<CouponWhereUniqueInput>
    update?: Enumerable<CouponUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CouponUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CouponScalarWhereInput>
  }

  export type AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
    connectOrCreate?: AccountConfigurationCreateOrConnectWithoutAccountInput
    upsert?: AccountConfigurationUpsertWithoutAccountInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountConfigurationWhereUniqueInput
    update?: XOR<AccountConfigurationUpdateWithoutAccountInput, AccountConfigurationUncheckedUpdateWithoutAccountInput>
  }

  export type CustomerUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutAccountInput>, Enumerable<CustomerUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: CustomerCreateManyAccountInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutAccount_configurationInput = {
    create?: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_configurationInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_configurationNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_configurationInput
    upsert?: AccountUpsertWithoutAccount_configurationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_configurationInput, AccountUncheckedUpdateWithoutAccount_configurationInput>
  }

  export type AccountCreateNestedOneWithoutAccount_activitiesInput = {
    create?: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_activitiesInput
    connect?: AccountWhereUniqueInput
  }

  export type ActivitiesCreateNestedOneWithoutAccount_activitiesInput = {
    create?: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: ActivitiesCreateOrConnectWithoutAccount_activitiesInput
    connect?: ActivitiesWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_activitiesNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_activitiesInput
    upsert?: AccountUpsertWithoutAccount_activitiesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_activitiesInput, AccountUncheckedUpdateWithoutAccount_activitiesInput>
  }

  export type ActivitiesUpdateOneRequiredWithoutAccount_activitiesNestedInput = {
    create?: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
    connectOrCreate?: ActivitiesCreateOrConnectWithoutAccount_activitiesInput
    upsert?: ActivitiesUpsertWithoutAccount_activitiesInput
    connect?: ActivitiesWhereUniqueInput
    update?: XOR<ActivitiesUpdateWithoutAccount_activitiesInput, ActivitiesUncheckedUpdateWithoutAccount_activitiesInput>
  }

  export type AccountActivitiesCreateNestedManyWithoutActivitiesInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountActivitiesUncheckedCreateNestedManyWithoutActivitiesInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
  }

  export type AccountActivitiesUpdateManyWithoutActivitiesNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutActivitiesInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutActivitiesInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type AccountActivitiesUncheckedUpdateManyWithoutActivitiesNestedInput = {
    create?: XOR<Enumerable<AccountActivitiesCreateWithoutActivitiesInput>, Enumerable<AccountActivitiesUncheckedCreateWithoutActivitiesInput>>
    connectOrCreate?: Enumerable<AccountActivitiesCreateOrConnectWithoutActivitiesInput>
    upsert?: Enumerable<AccountActivitiesUpsertWithWhereUniqueWithoutActivitiesInput>
    createMany?: AccountActivitiesCreateManyActivitiesInputEnvelope
    set?: Enumerable<AccountActivitiesWhereUniqueInput>
    disconnect?: Enumerable<AccountActivitiesWhereUniqueInput>
    delete?: Enumerable<AccountActivitiesWhereUniqueInput>
    connect?: Enumerable<AccountActivitiesWhereUniqueInput>
    update?: Enumerable<AccountActivitiesUpdateWithWhereUniqueWithoutActivitiesInput>
    updateMany?: Enumerable<AccountActivitiesUpdateManyWithWhereWithoutActivitiesInput>
    deleteMany?: Enumerable<AccountActivitiesScalarWhereInput>
  }

  export type AccountDeliveryCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutDeliveryInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutDeliveryInput>
    createMany?: AccountDeliveryCreateManyDeliveryInputEnvelope
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
  }

  export type AccountDeliveryUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutDeliveryInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutDeliveryInput>
    createMany?: AccountDeliveryCreateManyDeliveryInputEnvelope
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
  }

  export type AccountDeliveryUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutDeliveryInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutDeliveryInput>
    upsert?: Enumerable<AccountDeliveryUpsertWithWhereUniqueWithoutDeliveryInput>
    createMany?: AccountDeliveryCreateManyDeliveryInputEnvelope
    set?: Enumerable<AccountDeliveryWhereUniqueInput>
    disconnect?: Enumerable<AccountDeliveryWhereUniqueInput>
    delete?: Enumerable<AccountDeliveryWhereUniqueInput>
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
    update?: Enumerable<AccountDeliveryUpdateWithWhereUniqueWithoutDeliveryInput>
    updateMany?: Enumerable<AccountDeliveryUpdateManyWithWhereWithoutDeliveryInput>
    deleteMany?: Enumerable<AccountDeliveryScalarWhereInput>
  }

  export type AccountDeliveryUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<Enumerable<AccountDeliveryCreateWithoutDeliveryInput>, Enumerable<AccountDeliveryUncheckedCreateWithoutDeliveryInput>>
    connectOrCreate?: Enumerable<AccountDeliveryCreateOrConnectWithoutDeliveryInput>
    upsert?: Enumerable<AccountDeliveryUpsertWithWhereUniqueWithoutDeliveryInput>
    createMany?: AccountDeliveryCreateManyDeliveryInputEnvelope
    set?: Enumerable<AccountDeliveryWhereUniqueInput>
    disconnect?: Enumerable<AccountDeliveryWhereUniqueInput>
    delete?: Enumerable<AccountDeliveryWhereUniqueInput>
    connect?: Enumerable<AccountDeliveryWhereUniqueInput>
    update?: Enumerable<AccountDeliveryUpdateWithWhereUniqueWithoutDeliveryInput>
    updateMany?: Enumerable<AccountDeliveryUpdateManyWithWhereWithoutDeliveryInput>
    deleteMany?: Enumerable<AccountDeliveryScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutAccount_deliveriesInput = {
    create?: XOR<AccountCreateWithoutAccount_deliveriesInput, AccountUncheckedCreateWithoutAccount_deliveriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_deliveriesInput
    connect?: AccountWhereUniqueInput
  }

  export type DeliveryCreateNestedOneWithoutAccount_deliveriesInput = {
    create?: XOR<DeliveryCreateWithoutAccount_deliveriesInput, DeliveryUncheckedCreateWithoutAccount_deliveriesInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutAccount_deliveriesInput
    connect?: DeliveryWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_deliveriesNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_deliveriesInput, AccountUncheckedCreateWithoutAccount_deliveriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_deliveriesInput
    upsert?: AccountUpsertWithoutAccount_deliveriesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_deliveriesInput, AccountUncheckedUpdateWithoutAccount_deliveriesInput>
  }

  export type DeliveryUpdateOneRequiredWithoutAccount_deliveriesNestedInput = {
    create?: XOR<DeliveryCreateWithoutAccount_deliveriesInput, DeliveryUncheckedCreateWithoutAccount_deliveriesInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutAccount_deliveriesInput
    upsert?: DeliveryUpsertWithoutAccount_deliveriesInput
    connect?: DeliveryWhereUniqueInput
    update?: XOR<DeliveryUpdateWithoutAccount_deliveriesInput, DeliveryUncheckedUpdateWithoutAccount_deliveriesInput>
  }

  export type DeviceUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type AccountUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type UserAddressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type DeviceUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type AccountUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type UserAddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DeviceUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type AccountUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type UserAddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type DeviceUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutUserInput>, Enumerable<DeviceUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DeviceUserCreateManyUserInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type AccountUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutUserInput>, Enumerable<AccountUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountUserCreateManyUserInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type UserAddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUser_addressesInput = {
    create?: XOR<UserCreateWithoutUser_addressesInput, UserUncheckedCreateWithoutUser_addressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_addressesInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutUser_addressInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUser_addressInput>, Enumerable<OrderUncheckedCreateWithoutUser_addressInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUser_addressInput>
    createMany?: OrderCreateManyUser_addressInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutUser_addressInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUser_addressInput>, Enumerable<OrderUncheckedCreateWithoutUser_addressInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUser_addressInput>
    createMany?: OrderCreateManyUser_addressInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutUser_addressesNestedInput = {
    create?: XOR<UserCreateWithoutUser_addressesInput, UserUncheckedCreateWithoutUser_addressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_addressesInput
    upsert?: UserUpsertWithoutUser_addressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_addressesInput, UserUncheckedUpdateWithoutUser_addressesInput>
  }

  export type OrderUpdateManyWithoutUser_addressNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUser_addressInput>, Enumerable<OrderUncheckedCreateWithoutUser_addressInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUser_addressInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUser_addressInput>
    createMany?: OrderCreateManyUser_addressInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUser_addressInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUser_addressInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutUser_addressNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUser_addressInput>, Enumerable<OrderUncheckedCreateWithoutUser_addressInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUser_addressInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUser_addressInput>
    createMany?: OrderCreateManyUser_addressInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUser_addressInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUser_addressInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutAccount_usersInput = {
    create?: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_usersInput
    connect?: AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAccount_userInput = {
    create?: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccount_userInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutAccountUserInput = {
    create?: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAccountUserInput
    connect?: RoleWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_usersNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_usersInput
    upsert?: AccountUpsertWithoutAccount_usersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_usersInput, AccountUncheckedUpdateWithoutAccount_usersInput>
  }

  export type UserUpdateOneRequiredWithoutAccount_userNestedInput = {
    create?: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccount_userInput
    upsert?: UserUpsertWithoutAccount_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccount_userInput, UserUncheckedUpdateWithoutAccount_userInput>
  }

  export type RoleUpdateOneRequiredWithoutAccountUserNestedInput = {
    create?: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutAccountUserInput
    upsert?: RoleUpsertWithoutAccountUserInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutAccountUserInput, RoleUncheckedUpdateWithoutAccountUserInput>
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type RoleCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionInput
    connect?: RoleWhereUniqueInput
  }

  export type PermisionCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermisionCreateOrConnectWithoutRolePermissionInput
    connect?: PermisionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionInput
    upsert?: RoleUpsertWithoutRolePermissionInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutRolePermissionInput, RoleUncheckedUpdateWithoutRolePermissionInput>
  }

  export type PermisionUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermisionCreateOrConnectWithoutRolePermissionInput
    upsert?: PermisionUpsertWithoutRolePermissionInput
    connect?: PermisionWhereUniqueInput
    update?: XOR<PermisionUpdateWithoutRolePermissionInput, PermisionUncheckedUpdateWithoutRolePermissionInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type AccountUserCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type AccountUserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    connect?: Enumerable<AccountUserWhereUniqueInput>
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type AccountUserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutRoleInput>, Enumerable<RolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type AccountUserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<AccountUserCreateWithoutRoleInput>, Enumerable<AccountUserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<AccountUserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<AccountUserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: AccountUserCreateManyRoleInputEnvelope
    set?: Enumerable<AccountUserWhereUniqueInput>
    disconnect?: Enumerable<AccountUserWhereUniqueInput>
    delete?: Enumerable<AccountUserWhereUniqueInput>
    connect?: Enumerable<AccountUserWhereUniqueInput>
    update?: Enumerable<AccountUserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<AccountUserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<AccountUserScalarWhereInput>
  }

  export type CampaignTypeCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutCampaignInput
    connect?: CampaignTypeWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutCampaignInput = {
    create?: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCampaignInput
    connect?: AccountWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCampaignInput>, Enumerable<OrderUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCampaignInput>
    createMany?: OrderCreateManyCampaignInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type CampaignItemCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutCampaignInput>, Enumerable<CampaignItemUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignItemCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignItemWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCampaignInput>, Enumerable<OrderUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCampaignInput>
    createMany?: OrderCreateManyCampaignInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type CampaignItemUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutCampaignInput>, Enumerable<CampaignItemUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignItemCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignItemWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput = {
    set?: CampaignTypeDiscount | null
  }

  export type CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutCampaignInput
    upsert?: CampaignTypeUpsertWithoutCampaignInput
    connect?: CampaignTypeWhereUniqueInput
    update?: XOR<CampaignTypeUpdateWithoutCampaignInput, CampaignTypeUncheckedUpdateWithoutCampaignInput>
  }

  export type AccountUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCampaignInput
    upsert?: AccountUpsertWithoutCampaignInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutCampaignInput, AccountUncheckedUpdateWithoutCampaignInput>
  }

  export type OrderUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCampaignInput>, Enumerable<OrderUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: OrderCreateManyCampaignInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type CampaignItemUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutCampaignInput>, Enumerable<CampaignItemUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignItemUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignItemCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignItemWhereUniqueInput>
    disconnect?: Enumerable<CampaignItemWhereUniqueInput>
    delete?: Enumerable<CampaignItemWhereUniqueInput>
    connect?: Enumerable<CampaignItemWhereUniqueInput>
    update?: Enumerable<CampaignItemUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignItemUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignItemScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCampaignInput>, Enumerable<OrderUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: OrderCreateManyCampaignInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type CampaignItemUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutCampaignInput>, Enumerable<CampaignItemUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignItemUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignItemCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignItemWhereUniqueInput>
    disconnect?: Enumerable<CampaignItemWhereUniqueInput>
    delete?: Enumerable<CampaignItemWhereUniqueInput>
    connect?: Enumerable<CampaignItemWhereUniqueInput>
    update?: Enumerable<CampaignItemUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignItemUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignItemScalarWhereInput>
  }

  export type CampaignCreateNestedManyWithoutCampaign_typeInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutCampaign_typeInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignUpdateManyWithoutCampaign_typeNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutCampaign_typeInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutCampaign_typeInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutCampaign_typeNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaign_typeInput>, Enumerable<CampaignUncheckedCreateWithoutCampaign_typeInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaign_typeInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutCampaign_typeInput>
    createMany?: CampaignCreateManyCampaign_typeInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutCampaign_typeInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutCampaign_typeInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutCouponsInput = {
    create?: XOR<AccountCreateWithoutCouponsInput, AccountUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCouponsInput
    connect?: AccountWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCouponInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCouponInput>, Enumerable<OrderUncheckedCreateWithoutCouponInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCouponInput>
    createMany?: OrderCreateManyCouponInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCouponInput>, Enumerable<OrderUncheckedCreateWithoutCouponInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCouponInput>
    createMany?: OrderCreateManyCouponInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type AccountUpdateOneRequiredWithoutCouponsNestedInput = {
    create?: XOR<AccountCreateWithoutCouponsInput, AccountUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCouponsInput
    upsert?: AccountUpsertWithoutCouponsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutCouponsInput, AccountUncheckedUpdateWithoutCouponsInput>
  }

  export type EnumCouponDiscountTypeFieldUpdateOperationsInput = {
    set?: CouponDiscountType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCouponUseTypeFieldUpdateOperationsInput = {
    set?: CouponUseType
  }

  export type OrderUpdateManyWithoutCouponNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCouponInput>, Enumerable<OrderUncheckedCreateWithoutCouponInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCouponInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCouponInput>
    createMany?: OrderCreateManyCouponInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCouponInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCouponInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCouponInput>, Enumerable<OrderUncheckedCreateWithoutCouponInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCouponInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCouponInput>
    createMany?: OrderCreateManyCouponInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCouponInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCouponInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ItemTypeCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutItemsInput = {
    create?: XOR<CountryCreateWithoutItemsInput, CountryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutItemsInput
    connect?: CountryWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutItemsInput = {
    create?: XOR<RegionCreateWithoutItemsInput, RegionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutItemsInput
    connect?: RegionWhereUniqueInput
  }

  export type WineryCreateNestedOneWithoutItemsInput = {
    create?: XOR<WineryCreateWithoutItemsInput, WineryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WineryCreateOrConnectWithoutItemsInput
    connect?: WineryWhereUniqueInput
  }

  export type WineTypeCreateNestedOneWithoutItemsInput = {
    create?: XOR<WineTypeCreateWithoutItemsInput, WineTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WineTypeCreateOrConnectWithoutItemsInput
    connect?: WineTypeWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutItemsInput = {
    create?: XOR<AccountCreateWithoutItemsInput, AccountUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutItemsInput
    connect?: AccountWhereUniqueInput
  }

  export type ItemGrapeCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutItemInput>, Enumerable<ItemGrapeUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutItemInput>
    createMany?: ItemGrapeCreateManyItemInputEnvelope
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
  }

  export type OrderItemCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type CampaignItemCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutItemInput>, Enumerable<CampaignItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutItemInput>
    createMany?: CampaignItemCreateManyItemInputEnvelope
    connect?: Enumerable<CampaignItemWhereUniqueInput>
  }

  export type StockItemCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutItemInput>, Enumerable<StockItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutItemInput>
    createMany?: StockItemCreateManyItemInputEnvelope
    connect?: Enumerable<StockItemWhereUniqueInput>
  }

  export type StockHistoryCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutItemInput>, Enumerable<StockHistoryUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutItemInput>
    createMany?: StockHistoryCreateManyItemInputEnvelope
    connect?: Enumerable<StockHistoryWhereUniqueInput>
  }

  export type ItemTagCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutItemInput>, Enumerable<ItemTagUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutItemInput>
    createMany?: ItemTagCreateManyItemInputEnvelope
    connect?: Enumerable<ItemTagWhereUniqueInput>
  }

  export type ItemGrapeUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutItemInput>, Enumerable<ItemGrapeUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutItemInput>
    createMany?: ItemGrapeCreateManyItemInputEnvelope
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type CampaignItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutItemInput>, Enumerable<CampaignItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutItemInput>
    createMany?: CampaignItemCreateManyItemInputEnvelope
    connect?: Enumerable<CampaignItemWhereUniqueInput>
  }

  export type StockItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutItemInput>, Enumerable<StockItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutItemInput>
    createMany?: StockItemCreateManyItemInputEnvelope
    connect?: Enumerable<StockItemWhereUniqueInput>
  }

  export type StockHistoryUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutItemInput>, Enumerable<StockHistoryUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutItemInput>
    createMany?: StockHistoryCreateManyItemInputEnvelope
    connect?: Enumerable<StockHistoryWhereUniqueInput>
  }

  export type ItemTagUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutItemInput>, Enumerable<ItemTagUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutItemInput>
    createMany?: ItemTagCreateManyItemInputEnvelope
    connect?: Enumerable<ItemTagWhereUniqueInput>
  }

  export type ItemTypeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutItemsInput
    upsert?: ItemTypeUpsertWithoutItemsInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
  }

  export type CountryUpdateOneWithoutItemsNestedInput = {
    create?: XOR<CountryCreateWithoutItemsInput, CountryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutItemsInput
    upsert?: CountryUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutItemsInput, CountryUncheckedUpdateWithoutItemsInput>
  }

  export type RegionUpdateOneWithoutItemsNestedInput = {
    create?: XOR<RegionCreateWithoutItemsInput, RegionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutItemsInput
    upsert?: RegionUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<RegionUpdateWithoutItemsInput, RegionUncheckedUpdateWithoutItemsInput>
  }

  export type WineryUpdateOneWithoutItemsNestedInput = {
    create?: XOR<WineryCreateWithoutItemsInput, WineryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WineryCreateOrConnectWithoutItemsInput
    upsert?: WineryUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WineryWhereUniqueInput
    update?: XOR<WineryUpdateWithoutItemsInput, WineryUncheckedUpdateWithoutItemsInput>
  }

  export type WineTypeUpdateOneWithoutItemsNestedInput = {
    create?: XOR<WineTypeCreateWithoutItemsInput, WineTypeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WineTypeCreateOrConnectWithoutItemsInput
    upsert?: WineTypeUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WineTypeWhereUniqueInput
    update?: XOR<WineTypeUpdateWithoutItemsInput, WineTypeUncheckedUpdateWithoutItemsInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AccountUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AccountCreateWithoutItemsInput, AccountUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutItemsInput
    upsert?: AccountUpsertWithoutItemsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutItemsInput, AccountUncheckedUpdateWithoutItemsInput>
  }

  export type ItemGrapeUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutItemInput>, Enumerable<ItemGrapeUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<ItemGrapeUpsertWithWhereUniqueWithoutItemInput>
    createMany?: ItemGrapeCreateManyItemInputEnvelope
    set?: Enumerable<ItemGrapeWhereUniqueInput>
    disconnect?: Enumerable<ItemGrapeWhereUniqueInput>
    delete?: Enumerable<ItemGrapeWhereUniqueInput>
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
    update?: Enumerable<ItemGrapeUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<ItemGrapeUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<ItemGrapeScalarWhereInput>
  }

  export type OrderItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type CampaignItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutItemInput>, Enumerable<CampaignItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<CampaignItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: CampaignItemCreateManyItemInputEnvelope
    set?: Enumerable<CampaignItemWhereUniqueInput>
    disconnect?: Enumerable<CampaignItemWhereUniqueInput>
    delete?: Enumerable<CampaignItemWhereUniqueInput>
    connect?: Enumerable<CampaignItemWhereUniqueInput>
    update?: Enumerable<CampaignItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<CampaignItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<CampaignItemScalarWhereInput>
  }

  export type StockItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutItemInput>, Enumerable<StockItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<StockItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: StockItemCreateManyItemInputEnvelope
    set?: Enumerable<StockItemWhereUniqueInput>
    disconnect?: Enumerable<StockItemWhereUniqueInput>
    delete?: Enumerable<StockItemWhereUniqueInput>
    connect?: Enumerable<StockItemWhereUniqueInput>
    update?: Enumerable<StockItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<StockItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<StockItemScalarWhereInput>
  }

  export type StockHistoryUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutItemInput>, Enumerable<StockHistoryUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<StockHistoryUpsertWithWhereUniqueWithoutItemInput>
    createMany?: StockHistoryCreateManyItemInputEnvelope
    set?: Enumerable<StockHistoryWhereUniqueInput>
    disconnect?: Enumerable<StockHistoryWhereUniqueInput>
    delete?: Enumerable<StockHistoryWhereUniqueInput>
    connect?: Enumerable<StockHistoryWhereUniqueInput>
    update?: Enumerable<StockHistoryUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<StockHistoryUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<StockHistoryScalarWhereInput>
  }

  export type ItemTagUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutItemInput>, Enumerable<ItemTagUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<ItemTagUpsertWithWhereUniqueWithoutItemInput>
    createMany?: ItemTagCreateManyItemInputEnvelope
    set?: Enumerable<ItemTagWhereUniqueInput>
    disconnect?: Enumerable<ItemTagWhereUniqueInput>
    delete?: Enumerable<ItemTagWhereUniqueInput>
    connect?: Enumerable<ItemTagWhereUniqueInput>
    update?: Enumerable<ItemTagUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<ItemTagUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<ItemTagScalarWhereInput>
  }

  export type ItemGrapeUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutItemInput>, Enumerable<ItemGrapeUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<ItemGrapeUpsertWithWhereUniqueWithoutItemInput>
    createMany?: ItemGrapeCreateManyItemInputEnvelope
    set?: Enumerable<ItemGrapeWhereUniqueInput>
    disconnect?: Enumerable<ItemGrapeWhereUniqueInput>
    delete?: Enumerable<ItemGrapeWhereUniqueInput>
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
    update?: Enumerable<ItemGrapeUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<ItemGrapeUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<ItemGrapeScalarWhereInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type CampaignItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<CampaignItemCreateWithoutItemInput>, Enumerable<CampaignItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<CampaignItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<CampaignItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: CampaignItemCreateManyItemInputEnvelope
    set?: Enumerable<CampaignItemWhereUniqueInput>
    disconnect?: Enumerable<CampaignItemWhereUniqueInput>
    delete?: Enumerable<CampaignItemWhereUniqueInput>
    connect?: Enumerable<CampaignItemWhereUniqueInput>
    update?: Enumerable<CampaignItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<CampaignItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<CampaignItemScalarWhereInput>
  }

  export type StockItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<StockItemCreateWithoutItemInput>, Enumerable<StockItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<StockItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: StockItemCreateManyItemInputEnvelope
    set?: Enumerable<StockItemWhereUniqueInput>
    disconnect?: Enumerable<StockItemWhereUniqueInput>
    delete?: Enumerable<StockItemWhereUniqueInput>
    connect?: Enumerable<StockItemWhereUniqueInput>
    update?: Enumerable<StockItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<StockItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<StockItemScalarWhereInput>
  }

  export type StockHistoryUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<StockHistoryCreateWithoutItemInput>, Enumerable<StockHistoryUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<StockHistoryCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<StockHistoryUpsertWithWhereUniqueWithoutItemInput>
    createMany?: StockHistoryCreateManyItemInputEnvelope
    set?: Enumerable<StockHistoryWhereUniqueInput>
    disconnect?: Enumerable<StockHistoryWhereUniqueInput>
    delete?: Enumerable<StockHistoryWhereUniqueInput>
    connect?: Enumerable<StockHistoryWhereUniqueInput>
    update?: Enumerable<StockHistoryUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<StockHistoryUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<StockHistoryScalarWhereInput>
  }

  export type ItemTagUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutItemInput>, Enumerable<ItemTagUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<ItemTagUpsertWithWhereUniqueWithoutItemInput>
    createMany?: ItemTagCreateManyItemInputEnvelope
    set?: Enumerable<ItemTagWhereUniqueInput>
    disconnect?: Enumerable<ItemTagWhereUniqueInput>
    delete?: Enumerable<ItemTagWhereUniqueInput>
    connect?: Enumerable<ItemTagWhereUniqueInput>
    update?: Enumerable<ItemTagUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<ItemTagUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<ItemTagScalarWhereInput>
  }

  export type ItemCreateNestedManyWithoutItem_typeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItem_typeInput>, Enumerable<ItemUncheckedCreateWithoutItem_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItem_typeInput>
    createMany?: ItemCreateManyItem_typeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutItem_typeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItem_typeInput>, Enumerable<ItemUncheckedCreateWithoutItem_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItem_typeInput>
    createMany?: ItemCreateManyItem_typeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUpdateManyWithoutItem_typeNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItem_typeInput>, Enumerable<ItemUncheckedCreateWithoutItem_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItem_typeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutItem_typeInput>
    createMany?: ItemCreateManyItem_typeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutItem_typeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutItem_typeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutItem_typeNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItem_typeInput>, Enumerable<ItemUncheckedCreateWithoutItem_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItem_typeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutItem_typeInput>
    createMany?: ItemCreateManyItem_typeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutItem_typeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutItem_typeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemTagCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutTagInput>, Enumerable<ItemTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutTagInput>
    createMany?: ItemTagCreateManyTagInputEnvelope
    connect?: Enumerable<ItemTagWhereUniqueInput>
  }

  export type ItemTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutTagInput>, Enumerable<ItemTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutTagInput>
    createMany?: ItemTagCreateManyTagInputEnvelope
    connect?: Enumerable<ItemTagWhereUniqueInput>
  }

  export type ItemTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutTagInput>, Enumerable<ItemTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ItemTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ItemTagCreateManyTagInputEnvelope
    set?: Enumerable<ItemTagWhereUniqueInput>
    disconnect?: Enumerable<ItemTagWhereUniqueInput>
    delete?: Enumerable<ItemTagWhereUniqueInput>
    connect?: Enumerable<ItemTagWhereUniqueInput>
    update?: Enumerable<ItemTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ItemTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ItemTagScalarWhereInput>
  }

  export type ItemTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ItemTagCreateWithoutTagInput>, Enumerable<ItemTagUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ItemTagCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ItemTagUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ItemTagCreateManyTagInputEnvelope
    set?: Enumerable<ItemTagWhereUniqueInput>
    disconnect?: Enumerable<ItemTagWhereUniqueInput>
    delete?: Enumerable<ItemTagWhereUniqueInput>
    connect?: Enumerable<ItemTagWhereUniqueInput>
    update?: Enumerable<ItemTagUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ItemTagUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ItemTagScalarWhereInput>
  }

  export type ItemCreateNestedOneWithoutItemTagInput = {
    create?: XOR<ItemCreateWithoutItemTagInput, ItemUncheckedCreateWithoutItemTagInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemTagInput
    connect?: ItemWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutItemTagInput = {
    create?: XOR<TagCreateWithoutItemTagInput, TagUncheckedCreateWithoutItemTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutItemTagInput
    connect?: TagWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutItemTagNestedInput = {
    create?: XOR<ItemCreateWithoutItemTagInput, ItemUncheckedCreateWithoutItemTagInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemTagInput
    upsert?: ItemUpsertWithoutItemTagInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutItemTagInput, ItemUncheckedUpdateWithoutItemTagInput>
  }

  export type TagUpdateOneRequiredWithoutItemTagNestedInput = {
    create?: XOR<TagCreateWithoutItemTagInput, TagUncheckedCreateWithoutItemTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutItemTagInput
    upsert?: TagUpsertWithoutItemTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<TagUpdateWithoutItemTagInput, TagUncheckedUpdateWithoutItemTagInput>
  }

  export type ItemCreateNestedOneWithoutCampaign_itemsInput = {
    create?: XOR<ItemCreateWithoutCampaign_itemsInput, ItemUncheckedCreateWithoutCampaign_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCampaign_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutCampaign_itemsInput = {
    create?: XOR<CampaignCreateWithoutCampaign_itemsInput, CampaignUncheckedCreateWithoutCampaign_itemsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_itemsInput
    connect?: CampaignWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutCampaign_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutCampaign_itemsInput, ItemUncheckedCreateWithoutCampaign_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCampaign_itemsInput
    upsert?: ItemUpsertWithoutCampaign_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutCampaign_itemsInput, ItemUncheckedUpdateWithoutCampaign_itemsInput>
  }

  export type CampaignUpdateOneRequiredWithoutCampaign_itemsNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaign_itemsInput, CampaignUncheckedCreateWithoutCampaign_itemsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_itemsInput
    upsert?: CampaignUpsertWithoutCampaign_itemsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutCampaign_itemsInput, CampaignUncheckedUpdateWithoutCampaign_itemsInput>
  }

  export type ItemCreateNestedOneWithoutItem_grapeInput = {
    create?: XOR<ItemCreateWithoutItem_grapeInput, ItemUncheckedCreateWithoutItem_grapeInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_grapeInput
    connect?: ItemWhereUniqueInput
  }

  export type GrapeCreateNestedOneWithoutItem_grapeInput = {
    create?: XOR<GrapeCreateWithoutItem_grapeInput, GrapeUncheckedCreateWithoutItem_grapeInput>
    connectOrCreate?: GrapeCreateOrConnectWithoutItem_grapeInput
    connect?: GrapeWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutItem_grapeNestedInput = {
    create?: XOR<ItemCreateWithoutItem_grapeInput, ItemUncheckedCreateWithoutItem_grapeInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItem_grapeInput
    upsert?: ItemUpsertWithoutItem_grapeInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutItem_grapeInput, ItemUncheckedUpdateWithoutItem_grapeInput>
  }

  export type GrapeUpdateOneRequiredWithoutItem_grapeNestedInput = {
    create?: XOR<GrapeCreateWithoutItem_grapeInput, GrapeUncheckedCreateWithoutItem_grapeInput>
    connectOrCreate?: GrapeCreateOrConnectWithoutItem_grapeInput
    upsert?: GrapeUpsertWithoutItem_grapeInput
    connect?: GrapeWhereUniqueInput
    update?: XOR<GrapeUpdateWithoutItem_grapeInput, GrapeUncheckedUpdateWithoutItem_grapeInput>
  }

  export type ItemGrapeCreateNestedManyWithoutGrapeInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutGrapeInput>, Enumerable<ItemGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutGrapeInput>
    createMany?: ItemGrapeCreateManyGrapeInputEnvelope
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
  }

  export type ItemGrapeUncheckedCreateNestedManyWithoutGrapeInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutGrapeInput>, Enumerable<ItemGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutGrapeInput>
    createMany?: ItemGrapeCreateManyGrapeInputEnvelope
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
  }

  export type ItemGrapeUpdateManyWithoutGrapeNestedInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutGrapeInput>, Enumerable<ItemGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutGrapeInput>
    upsert?: Enumerable<ItemGrapeUpsertWithWhereUniqueWithoutGrapeInput>
    createMany?: ItemGrapeCreateManyGrapeInputEnvelope
    set?: Enumerable<ItemGrapeWhereUniqueInput>
    disconnect?: Enumerable<ItemGrapeWhereUniqueInput>
    delete?: Enumerable<ItemGrapeWhereUniqueInput>
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
    update?: Enumerable<ItemGrapeUpdateWithWhereUniqueWithoutGrapeInput>
    updateMany?: Enumerable<ItemGrapeUpdateManyWithWhereWithoutGrapeInput>
    deleteMany?: Enumerable<ItemGrapeScalarWhereInput>
  }

  export type ItemGrapeUncheckedUpdateManyWithoutGrapeNestedInput = {
    create?: XOR<Enumerable<ItemGrapeCreateWithoutGrapeInput>, Enumerable<ItemGrapeUncheckedCreateWithoutGrapeInput>>
    connectOrCreate?: Enumerable<ItemGrapeCreateOrConnectWithoutGrapeInput>
    upsert?: Enumerable<ItemGrapeUpsertWithWhereUniqueWithoutGrapeInput>
    createMany?: ItemGrapeCreateManyGrapeInputEnvelope
    set?: Enumerable<ItemGrapeWhereUniqueInput>
    disconnect?: Enumerable<ItemGrapeWhereUniqueInput>
    delete?: Enumerable<ItemGrapeWhereUniqueInput>
    connect?: Enumerable<ItemGrapeWhereUniqueInput>
    update?: Enumerable<ItemGrapeUpdateWithWhereUniqueWithoutGrapeInput>
    updateMany?: Enumerable<ItemGrapeUpdateManyWithWhereWithoutGrapeInput>
    deleteMany?: Enumerable<ItemGrapeScalarWhereInput>
  }

  export type StateCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type ItemCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCountryInput>, Enumerable<ItemUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCountryInput>
    createMany?: ItemCreateManyCountryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type StateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCountryInput>, Enumerable<ItemUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCountryInput>
    createMany?: ItemCreateManyCountryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type StateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type ItemUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCountryInput>, Enumerable<ItemUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: ItemCreateManyCountryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type StateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCountryInput>, Enumerable<ItemUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: ItemCreateManyCountryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type CountryCreateNestedOneWithoutStatesInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    connect?: CountryWhereUniqueInput
  }

  export type RegionCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    connect?: Enumerable<RegionWhereUniqueInput>
  }

  export type CityCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type RegionUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    connect?: Enumerable<RegionWhereUniqueInput>
  }

  export type CityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CountryUpdateOneRequiredWithoutStatesNestedInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    upsert?: CountryUpsertWithoutStatesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
  }

  export type RegionUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<RegionUpsertWithWhereUniqueWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    set?: Enumerable<RegionWhereUniqueInput>
    disconnect?: Enumerable<RegionWhereUniqueInput>
    delete?: Enumerable<RegionWhereUniqueInput>
    connect?: Enumerable<RegionWhereUniqueInput>
    update?: Enumerable<RegionUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<RegionUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<RegionScalarWhereInput>
  }

  export type CityUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type RegionUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<RegionCreateWithoutStateInput>, Enumerable<RegionUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<RegionCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<RegionUpsertWithWhereUniqueWithoutStateInput>
    createMany?: RegionCreateManyStateInputEnvelope
    set?: Enumerable<RegionWhereUniqueInput>
    disconnect?: Enumerable<RegionWhereUniqueInput>
    delete?: Enumerable<RegionWhereUniqueInput>
    connect?: Enumerable<RegionWhereUniqueInput>
    update?: Enumerable<RegionUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<RegionUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<RegionScalarWhereInput>
  }

  export type CityUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type StateCreateNestedOneWithoutCitiesInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    connect?: StateWhereUniqueInput
  }

  export type StateUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    upsert?: StateUpsertWithoutCitiesInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type StateCreateNestedOneWithoutRegionsInput = {
    create?: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: StateCreateOrConnectWithoutRegionsInput
    connect?: StateWhereUniqueInput
  }

  export type SubRegionCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    connect?: Enumerable<SubRegionWhereUniqueInput>
  }

  export type ItemCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<ItemCreateWithoutRegionInput>, Enumerable<ItemUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutRegionInput>
    createMany?: ItemCreateManyRegionInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type SubRegionUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    connect?: Enumerable<SubRegionWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<ItemCreateWithoutRegionInput>, Enumerable<ItemUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutRegionInput>
    createMany?: ItemCreateManyRegionInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type StateUpdateOneRequiredWithoutRegionsNestedInput = {
    create?: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: StateCreateOrConnectWithoutRegionsInput
    upsert?: StateUpsertWithoutRegionsInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutRegionsInput, StateUncheckedUpdateWithoutRegionsInput>
  }

  export type SubRegionUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<SubRegionUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    set?: Enumerable<SubRegionWhereUniqueInput>
    disconnect?: Enumerable<SubRegionWhereUniqueInput>
    delete?: Enumerable<SubRegionWhereUniqueInput>
    connect?: Enumerable<SubRegionWhereUniqueInput>
    update?: Enumerable<SubRegionUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<SubRegionUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<SubRegionScalarWhereInput>
  }

  export type ItemUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutRegionInput>, Enumerable<ItemUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: ItemCreateManyRegionInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type SubRegionUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<SubRegionCreateWithoutRegionInput>, Enumerable<SubRegionUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<SubRegionCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<SubRegionUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: SubRegionCreateManyRegionInputEnvelope
    set?: Enumerable<SubRegionWhereUniqueInput>
    disconnect?: Enumerable<SubRegionWhereUniqueInput>
    delete?: Enumerable<SubRegionWhereUniqueInput>
    connect?: Enumerable<SubRegionWhereUniqueInput>
    update?: Enumerable<SubRegionUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<SubRegionUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<SubRegionScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutRegionInput>, Enumerable<ItemUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: ItemCreateManyRegionInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type RegionCreateNestedOneWithoutSubregionInput = {
    create?: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
    connectOrCreate?: RegionCreateOrConnectWithoutSubregionInput
    connect?: RegionWhereUniqueInput
  }

  export type RegionUpdateOneRequiredWithoutSubregionNestedInput = {
    create?: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
    connectOrCreate?: RegionCreateOrConnectWithoutSubregionInput
    upsert?: RegionUpsertWithoutSubregionInput
    connect?: RegionWhereUniqueInput
    update?: XOR<RegionUpdateWithoutSubregionInput, RegionUncheckedUpdateWithoutSubregionInput>
  }

  export type ItemCreateNestedManyWithoutWine_typeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWine_typeInput>, Enumerable<ItemUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWine_typeInput>
    createMany?: ItemCreateManyWine_typeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutWine_typeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWine_typeInput>, Enumerable<ItemUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWine_typeInput>
    createMany?: ItemCreateManyWine_typeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUpdateManyWithoutWine_typeNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWine_typeInput>, Enumerable<ItemUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWine_typeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutWine_typeInput>
    createMany?: ItemCreateManyWine_typeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutWine_typeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutWine_typeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutWine_typeNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWine_typeInput>, Enumerable<ItemUncheckedCreateWithoutWine_typeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWine_typeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutWine_typeInput>
    createMany?: ItemCreateManyWine_typeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutWine_typeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutWine_typeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutOrderInput = {
    create?: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOrderInput
    connect?: AccountWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CouponCreateWithoutOrdersInput, CouponUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CouponCreateOrConnectWithoutOrdersInput
    connect?: CouponWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserAddressCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserAddressCreateWithoutOrdersInput, UserAddressUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutOrdersInput
    connect?: UserAddressWhereUniqueInput
  }

  export type OrderStatusCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CampaignCreateWithoutOrdersInput, CampaignUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOrdersInput
    connect?: CampaignWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type InvoiceCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type AccountUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOrderInput
    upsert?: AccountUpsertWithoutOrderInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutOrderInput, AccountUncheckedUpdateWithoutOrderInput>
  }

  export type CouponUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CouponCreateWithoutOrdersInput, CouponUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CouponCreateOrConnectWithoutOrdersInput
    upsert?: CouponUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<CouponUpdateWithoutOrdersInput, CouponUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserAddressUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserAddressCreateWithoutOrdersInput, UserAddressUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutOrdersInput
    upsert?: UserAddressUpsertWithoutOrdersInput
    connect?: UserAddressWhereUniqueInput
    update?: XOR<UserAddressUpdateWithoutOrdersInput, UserAddressUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    upsert?: OrderStatusUpsertWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
    update?: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
  }

  export type CampaignUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CampaignCreateWithoutOrdersInput, CampaignUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOrdersInput
    upsert?: CampaignUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutOrdersInput, CampaignUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type InvoiceUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    connect?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutOrderInput>, Enumerable<InvoiceUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type OrderCreateNestedManyWithoutOrder_statusInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrder_statusInput>, Enumerable<OrderUncheckedCreateWithoutOrder_statusInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrder_statusInput>
    createMany?: OrderCreateManyOrder_statusInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutOrder_statusInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrder_statusInput>, Enumerable<OrderUncheckedCreateWithoutOrder_statusInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrder_statusInput>
    createMany?: OrderCreateManyOrder_statusInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUpdateManyWithoutOrder_statusNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrder_statusInput>, Enumerable<OrderUncheckedCreateWithoutOrder_statusInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrder_statusInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutOrder_statusInput>
    createMany?: OrderCreateManyOrder_statusInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutOrder_statusInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutOrder_statusInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutOrder_statusNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutOrder_statusInput>, Enumerable<OrderUncheckedCreateWithoutOrder_statusInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutOrder_statusInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutOrder_statusInput>
    createMany?: OrderCreateManyOrder_statusInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutOrder_statusInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutOrder_statusInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutCustomersInput = {
    create?: XOR<AccountCreateWithoutCustomersInput, AccountUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCustomersInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<AccountCreateWithoutCustomersInput, AccountUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCustomersInput
    upsert?: AccountUpsertWithoutCustomersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutCustomersInput, AccountUncheckedUpdateWithoutCustomersInput>
  }

  export type EnumCustomerOriginRegistrationFieldUpdateOperationsInput = {
    set?: CustomerOriginRegistration
  }

  export type OrderCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<OrderCreateWithoutOrder_itemsInput, OrderUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrder_itemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<ItemCreateWithoutOrder_itemsInput, ItemUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutOrder_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrder_itemsInput, OrderUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrder_itemsInput
    upsert?: OrderUpsertWithoutOrder_itemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutOrder_itemsInput, OrderUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type ItemUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutOrder_itemsInput, ItemUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutOrder_itemsInput
    upsert?: ItemUpsertWithoutOrder_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutOrder_itemsInput, ItemUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInvoicesInput
    connect?: AccountWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    upsert?: OrderUpsertWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type AccountUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInvoicesInput
    upsert?: AccountUpsertWithoutInvoicesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutInvoicesInput, AccountUncheckedUpdateWithoutInvoicesInput>
  }

  export type DeviceUserCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type PushNotificationCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type SmsNotificationCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type DeviceNotificationCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type DeviceUserUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceUserWhereUniqueInput>
  }

  export type PushNotificationUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type EnumPlatformTypeFieldUpdateOperationsInput = {
    set?: PlatformType
  }

  export type DeviceUserUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type PushNotificationUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type SmsNotificationUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type DeviceNotificationUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceUserCreateWithoutDeviceInput>, Enumerable<DeviceUserUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceUserCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceUserUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceUserCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceUserWhereUniqueInput>
    disconnect?: Enumerable<DeviceUserWhereUniqueInput>
    delete?: Enumerable<DeviceUserWhereUniqueInput>
    connect?: Enumerable<DeviceUserWhereUniqueInput>
    update?: Enumerable<DeviceUserUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceUserUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceUserScalarWhereInput>
  }

  export type PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutDeviceInput>, Enumerable<PushNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: PushNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutDeviceInput>, Enumerable<SmsNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: SmsNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutDeviceInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutDeviceInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutDeviceInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutDeviceInput>
    createMany?: DeviceNotificationCreateManyDeviceInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutDeviceInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutDeviceInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type DeviceCreateNestedOneWithoutDevice_userInput = {
    create?: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_userInput
    connect?: DeviceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDevice_userInput = {
    create?: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevice_userInput
    connect?: UserWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDevice_userNestedInput = {
    create?: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_userInput
    upsert?: DeviceUpsertWithoutDevice_userInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutDevice_userInput, DeviceUncheckedUpdateWithoutDevice_userInput>
  }

  export type UserUpdateOneRequiredWithoutDevice_userNestedInput = {
    create?: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevice_userInput
    upsert?: UserUpsertWithoutDevice_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDevice_userInput, UserUncheckedUpdateWithoutDevice_userInput>
  }

  export type SmsNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type EmailNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
  }

  export type PushNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type DeviceNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
  }

  export type EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
  }

  export type PushNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<PushNotificationWhereUniqueInput>
  }

  export type DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
  }

  export type EnumTypeNotificationFieldUpdateOperationsInput = {
    set?: TypeNotification
  }

  export type SmsNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type EmailNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<EmailNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<EmailNotificationWhereUniqueInput>
    disconnect?: Enumerable<EmailNotificationWhereUniqueInput>
    delete?: Enumerable<EmailNotificationWhereUniqueInput>
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
    update?: Enumerable<EmailNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<EmailNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<EmailNotificationScalarWhereInput>
  }

  export type PushNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type DeviceNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<SmsNotificationCreateWithoutNotificationInput>, Enumerable<SmsNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<SmsNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<SmsNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: SmsNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<SmsNotificationWhereUniqueInput>
    disconnect?: Enumerable<SmsNotificationWhereUniqueInput>
    delete?: Enumerable<SmsNotificationWhereUniqueInput>
    connect?: Enumerable<SmsNotificationWhereUniqueInput>
    update?: Enumerable<SmsNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<SmsNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<SmsNotificationScalarWhereInput>
  }

  export type EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<EmailNotificationCreateWithoutNotificationInput>, Enumerable<EmailNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<EmailNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<EmailNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: EmailNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<EmailNotificationWhereUniqueInput>
    disconnect?: Enumerable<EmailNotificationWhereUniqueInput>
    delete?: Enumerable<EmailNotificationWhereUniqueInput>
    connect?: Enumerable<EmailNotificationWhereUniqueInput>
    update?: Enumerable<EmailNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<EmailNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<EmailNotificationScalarWhereInput>
  }

  export type PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<PushNotificationCreateWithoutNotificationInput>, Enumerable<PushNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<PushNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<PushNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: PushNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<PushNotificationWhereUniqueInput>
    disconnect?: Enumerable<PushNotificationWhereUniqueInput>
    delete?: Enumerable<PushNotificationWhereUniqueInput>
    connect?: Enumerable<PushNotificationWhereUniqueInput>
    update?: Enumerable<PushNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<PushNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<PushNotificationScalarWhereInput>
  }

  export type DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<Enumerable<DeviceNotificationCreateWithoutNotificationInput>, Enumerable<DeviceNotificationUncheckedCreateWithoutNotificationInput>>
    connectOrCreate?: Enumerable<DeviceNotificationCreateOrConnectWithoutNotificationInput>
    upsert?: Enumerable<DeviceNotificationUpsertWithWhereUniqueWithoutNotificationInput>
    createMany?: DeviceNotificationCreateManyNotificationInputEnvelope
    set?: Enumerable<DeviceNotificationWhereUniqueInput>
    disconnect?: Enumerable<DeviceNotificationWhereUniqueInput>
    delete?: Enumerable<DeviceNotificationWhereUniqueInput>
    connect?: Enumerable<DeviceNotificationWhereUniqueInput>
    update?: Enumerable<DeviceNotificationUpdateWithWhereUniqueWithoutNotificationInput>
    updateMany?: Enumerable<DeviceNotificationUpdateManyWithWhereWithoutNotificationInput>
    deleteMany?: Enumerable<DeviceNotificationScalarWhereInput>
  }

  export type NotificationsCreateNestedOneWithoutEmail_notificationInput = {
    create?: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutEmail_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type NotificationsUpdateOneRequiredWithoutEmail_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutEmail_notificationInput
    upsert?: NotificationsUpsertWithoutEmail_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutEmail_notificationInput, NotificationsUncheckedUpdateWithoutEmail_notificationInput>
  }

  export type EnumEmailTypeNotificationFieldUpdateOperationsInput = {
    set?: EmailTypeNotification
  }

  export type NotificationsCreateNestedOneWithoutSms_notificationInput = {
    create?: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutSms_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutSms_notificationInput = {
    create?: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSms_notificationInput
    connect?: DeviceWhereUniqueInput
  }

  export type NotificationsUpdateOneRequiredWithoutSms_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutSms_notificationInput
    upsert?: NotificationsUpsertWithoutSms_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutSms_notificationInput, NotificationsUncheckedUpdateWithoutSms_notificationInput>
  }

  export type DeviceUpdateOneRequiredWithoutSms_notificationNestedInput = {
    create?: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSms_notificationInput
    upsert?: DeviceUpsertWithoutSms_notificationInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutSms_notificationInput, DeviceUncheckedUpdateWithoutSms_notificationInput>
  }

  export type NotificationsCreateNestedOneWithoutPush_notificationInput = {
    create?: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutPush_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutPush_notificationInput = {
    create?: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPush_notificationInput
    connect?: DeviceWhereUniqueInput
  }

  export type NotificationsUpdateOneRequiredWithoutPush_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutPush_notificationInput
    upsert?: NotificationsUpsertWithoutPush_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutPush_notificationInput, NotificationsUncheckedUpdateWithoutPush_notificationInput>
  }

  export type DeviceUpdateOneRequiredWithoutPush_notificationNestedInput = {
    create?: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutPush_notificationInput
    upsert?: DeviceUpsertWithoutPush_notificationInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutPush_notificationInput, DeviceUncheckedUpdateWithoutPush_notificationInput>
  }

  export type DeviceCreateNestedOneWithoutDevice_notificationInput = {
    create?: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_notificationInput
    connect?: DeviceWhereUniqueInput
  }

  export type NotificationsCreateNestedOneWithoutDevice_notificationInput = {
    create?: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutDevice_notificationInput
    connect?: NotificationsWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutDevice_notificationNestedInput = {
    create?: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDevice_notificationInput
    upsert?: DeviceUpsertWithoutDevice_notificationInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<DeviceUpdateWithoutDevice_notificationInput, DeviceUncheckedUpdateWithoutDevice_notificationInput>
  }

  export type NotificationsUpdateOneRequiredWithoutDevice_notificationNestedInput = {
    create?: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
    connectOrCreate?: NotificationsCreateOrConnectWithoutDevice_notificationInput
    upsert?: NotificationsUpsertWithoutDevice_notificationInput
    connect?: NotificationsWhereUniqueInput
    update?: XOR<NotificationsUpdateWithoutDevice_notificationInput, NotificationsUncheckedUpdateWithoutDevice_notificationInput>
  }

  export type PaymentCycleCreateNestedOneWithoutPlansInput = {
    create?: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
    connectOrCreate?: PaymentCycleCreateOrConnectWithoutPlansInput
    connect?: PaymentCycleWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type PaymentCycleUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
    connectOrCreate?: PaymentCycleCreateOrConnectWithoutPlansInput
    upsert?: PaymentCycleUpsertWithoutPlansInput
    connect?: PaymentCycleWhereUniqueInput
    update?: XOR<PaymentCycleUpdateWithoutPlansInput, PaymentCycleUncheckedUpdateWithoutPlansInput>
  }

  export type AccountUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutPlanInput>, Enumerable<AccountUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: AccountCreateManyPlanInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutPlanInput>, Enumerable<SubscriptionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type PlanCreateNestedManyWithoutPayment_cycleInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    connect?: Enumerable<PlanWhereUniqueInput>
  }

  export type PlanUncheckedCreateNestedManyWithoutPayment_cycleInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    connect?: Enumerable<PlanWhereUniqueInput>
  }

  export type PlanUpdateManyWithoutPayment_cycleNestedInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    upsert?: Enumerable<PlanUpsertWithWhereUniqueWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    set?: Enumerable<PlanWhereUniqueInput>
    disconnect?: Enumerable<PlanWhereUniqueInput>
    delete?: Enumerable<PlanWhereUniqueInput>
    connect?: Enumerable<PlanWhereUniqueInput>
    update?: Enumerable<PlanUpdateWithWhereUniqueWithoutPayment_cycleInput>
    updateMany?: Enumerable<PlanUpdateManyWithWhereWithoutPayment_cycleInput>
    deleteMany?: Enumerable<PlanScalarWhereInput>
  }

  export type PlanUncheckedUpdateManyWithoutPayment_cycleNestedInput = {
    create?: XOR<Enumerable<PlanCreateWithoutPayment_cycleInput>, Enumerable<PlanUncheckedCreateWithoutPayment_cycleInput>>
    connectOrCreate?: Enumerable<PlanCreateOrConnectWithoutPayment_cycleInput>
    upsert?: Enumerable<PlanUpsertWithWhereUniqueWithoutPayment_cycleInput>
    createMany?: PlanCreateManyPayment_cycleInputEnvelope
    set?: Enumerable<PlanWhereUniqueInput>
    disconnect?: Enumerable<PlanWhereUniqueInput>
    delete?: Enumerable<PlanWhereUniqueInput>
    connect?: Enumerable<PlanWhereUniqueInput>
    update?: Enumerable<PlanUpdateWithWhereUniqueWithoutPayment_cycleInput>
    updateMany?: Enumerable<PlanUpdateManyWithWhereWithoutPayment_cycleInput>
    deleteMany?: Enumerable<PlanScalarWhereInput>
  }

  export type PlanCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionInput
    connect?: PlanWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSubscriptionInput
    connect?: AccountWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionInput
    upsert?: PlanUpsertWithoutSubscriptionInput
    connect?: PlanWhereUniqueInput
    update?: XOR<PlanUpdateWithoutSubscriptionInput, PlanUncheckedUpdateWithoutSubscriptionInput>
  }

  export type AccountUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSubscriptionInput
    upsert?: AccountUpsertWithoutSubscriptionInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutSubscriptionInput, AccountUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ItemCreateNestedOneWithoutStock_itemsInput = {
    create?: XOR<ItemCreateWithoutStock_itemsInput, ItemUncheckedCreateWithoutStock_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStock_itemsInput
    connect?: ItemWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutStock_itemsInput = {
    create?: XOR<AccountCreateWithoutStock_itemsInput, AccountUncheckedCreateWithoutStock_itemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutStock_itemsInput
    connect?: AccountWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutStock_itemsNestedInput = {
    create?: XOR<ItemCreateWithoutStock_itemsInput, ItemUncheckedCreateWithoutStock_itemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStock_itemsInput
    upsert?: ItemUpsertWithoutStock_itemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutStock_itemsInput, ItemUncheckedUpdateWithoutStock_itemsInput>
  }

  export type AccountUpdateOneRequiredWithoutStock_itemsNestedInput = {
    create?: XOR<AccountCreateWithoutStock_itemsInput, AccountUncheckedCreateWithoutStock_itemsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutStock_itemsInput
    upsert?: AccountUpsertWithoutStock_itemsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutStock_itemsInput, AccountUncheckedUpdateWithoutStock_itemsInput>
  }

  export type ItemCreateNestedOneWithoutStock_historyInput = {
    create?: XOR<ItemCreateWithoutStock_historyInput, ItemUncheckedCreateWithoutStock_historyInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStock_historyInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutStock_historyNestedInput = {
    create?: XOR<ItemCreateWithoutStock_historyInput, ItemUncheckedCreateWithoutStock_historyInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStock_historyInput
    upsert?: ItemUpsertWithoutStock_historyInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutStock_historyInput, ItemUncheckedUpdateWithoutStock_historyInput>
  }

  export type EnumStockHistoryTypeFieldUpdateOperationsInput = {
    set?: StockHistoryType
  }

  export type ItemCreateNestedManyWithoutWineryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWineryInput>, Enumerable<ItemUncheckedCreateWithoutWineryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWineryInput>
    createMany?: ItemCreateManyWineryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutWineryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWineryInput>, Enumerable<ItemUncheckedCreateWithoutWineryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWineryInput>
    createMany?: ItemCreateManyWineryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUpdateManyWithoutWineryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWineryInput>, Enumerable<ItemUncheckedCreateWithoutWineryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWineryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutWineryInput>
    createMany?: ItemCreateManyWineryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutWineryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutWineryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutWineryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutWineryInput>, Enumerable<ItemUncheckedCreateWithoutWineryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutWineryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutWineryInput>
    createMany?: ItemCreateManyWineryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutWineryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutWineryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumPersonTypeFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeFilter | PersonType
  }

  export type NestedEnumGenderTypeFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeFilter | GenderType
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumPersonTypeWithAggregatesFilter = {
    equals?: PersonType
    in?: Enumerable<PersonType>
    notIn?: Enumerable<PersonType>
    not?: NestedEnumPersonTypeWithAggregatesFilter | PersonType
    _count?: NestedIntFilter
    _min?: NestedEnumPersonTypeFilter
    _max?: NestedEnumPersonTypeFilter
  }

  export type NestedEnumGenderTypeWithAggregatesFilter = {
    equals?: GenderType
    in?: Enumerable<GenderType>
    notIn?: Enumerable<GenderType>
    not?: NestedEnumGenderTypeWithAggregatesFilter | GenderType
    _count?: NestedIntFilter
    _min?: NestedEnumGenderTypeFilter
    _max?: NestedEnumGenderTypeFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedEnumCampaignTypeDiscountNullableFilter = {
    equals?: CampaignTypeDiscount | null
    in?: Enumerable<CampaignTypeDiscount> | null
    notIn?: Enumerable<CampaignTypeDiscount> | null
    not?: NestedEnumCampaignTypeDiscountNullableFilter | CampaignTypeDiscount | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumCampaignTypeDiscountNullableWithAggregatesFilter = {
    equals?: CampaignTypeDiscount | null
    in?: Enumerable<CampaignTypeDiscount> | null
    notIn?: Enumerable<CampaignTypeDiscount> | null
    not?: NestedEnumCampaignTypeDiscountNullableWithAggregatesFilter | CampaignTypeDiscount | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCampaignTypeDiscountNullableFilter
    _max?: NestedEnumCampaignTypeDiscountNullableFilter
  }

  export type NestedEnumCouponDiscountTypeFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeFilter | CouponDiscountType
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumCouponUseTypeFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeFilter | CouponUseType
  }

  export type NestedEnumCouponDiscountTypeWithAggregatesFilter = {
    equals?: CouponDiscountType
    in?: Enumerable<CouponDiscountType>
    notIn?: Enumerable<CouponDiscountType>
    not?: NestedEnumCouponDiscountTypeWithAggregatesFilter | CouponDiscountType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponDiscountTypeFilter
    _max?: NestedEnumCouponDiscountTypeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumCouponUseTypeWithAggregatesFilter = {
    equals?: CouponUseType
    in?: Enumerable<CouponUseType>
    notIn?: Enumerable<CouponUseType>
    not?: NestedEnumCouponUseTypeWithAggregatesFilter | CouponUseType
    _count?: NestedIntFilter
    _min?: NestedEnumCouponUseTypeFilter
    _max?: NestedEnumCouponUseTypeFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedEnumCustomerOriginRegistrationFilter = {
    equals?: CustomerOriginRegistration
    in?: Enumerable<CustomerOriginRegistration>
    notIn?: Enumerable<CustomerOriginRegistration>
    not?: NestedEnumCustomerOriginRegistrationFilter | CustomerOriginRegistration
  }

  export type NestedEnumCustomerOriginRegistrationWithAggregatesFilter = {
    equals?: CustomerOriginRegistration
    in?: Enumerable<CustomerOriginRegistration>
    notIn?: Enumerable<CustomerOriginRegistration>
    not?: NestedEnumCustomerOriginRegistrationWithAggregatesFilter | CustomerOriginRegistration
    _count?: NestedIntFilter
    _min?: NestedEnumCustomerOriginRegistrationFilter
    _max?: NestedEnumCustomerOriginRegistrationFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedEnumPlatformTypeFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeFilter | PlatformType
  }

  export type NestedEnumPlatformTypeWithAggregatesFilter = {
    equals?: PlatformType
    in?: Enumerable<PlatformType>
    notIn?: Enumerable<PlatformType>
    not?: NestedEnumPlatformTypeWithAggregatesFilter | PlatformType
    _count?: NestedIntFilter
    _min?: NestedEnumPlatformTypeFilter
    _max?: NestedEnumPlatformTypeFilter
  }

  export type NestedEnumTypeNotificationFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationFilter | TypeNotification
  }

  export type NestedEnumTypeNotificationWithAggregatesFilter = {
    equals?: TypeNotification
    in?: Enumerable<TypeNotification>
    notIn?: Enumerable<TypeNotification>
    not?: NestedEnumTypeNotificationWithAggregatesFilter | TypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumTypeNotificationFilter
    _max?: NestedEnumTypeNotificationFilter
  }

  export type NestedEnumEmailTypeNotificationFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationFilter | EmailTypeNotification
  }

  export type NestedEnumEmailTypeNotificationWithAggregatesFilter = {
    equals?: EmailTypeNotification
    in?: Enumerable<EmailTypeNotification>
    notIn?: Enumerable<EmailTypeNotification>
    not?: NestedEnumEmailTypeNotificationWithAggregatesFilter | EmailTypeNotification
    _count?: NestedIntFilter
    _min?: NestedEnumEmailTypeNotificationFilter
    _max?: NestedEnumEmailTypeNotificationFilter
  }

  export type NestedEnumStockHistoryTypeFilter = {
    equals?: StockHistoryType
    in?: Enumerable<StockHistoryType>
    notIn?: Enumerable<StockHistoryType>
    not?: NestedEnumStockHistoryTypeFilter | StockHistoryType
  }

  export type NestedEnumStockHistoryTypeWithAggregatesFilter = {
    equals?: StockHistoryType
    in?: Enumerable<StockHistoryType>
    notIn?: Enumerable<StockHistoryType>
    not?: NestedEnumStockHistoryTypeWithAggregatesFilter | StockHistoryType
    _count?: NestedIntFilter
    _min?: NestedEnumStockHistoryTypeFilter
    _max?: NestedEnumStockHistoryTypeFilter
  }

  export type CampaignCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCampaignInput
    campaign_items?: CampaignItemCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type_id: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCampaignInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAccountInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAccountInput, CampaignUncheckedCreateWithoutAccountInput>
  }

  export type CampaignCreateManyAccountInputEnvelope = {
    data: Enumerable<CampaignCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle: PaymentCycleCreateNestedOneWithoutPlansInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutAccountInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
  }

  export type SubscriptionCreateWithoutAccountInput = {
    id?: string
    plan: PlanCreateNestedOneWithoutSubscriptionInput
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutAccountInput = {
    id?: string
    plan_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutAccountInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutAccountInput, SubscriptionUncheckedCreateWithoutAccountInput>
  }

  export type SubscriptionCreateManyAccountInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    code: string
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    code: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAccountInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
  }

  export type OrderCreateManyAccountInputEnvelope = {
    data: Enumerable<OrderCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type AccountActivitiesCreateWithoutAccountInput = {
    activities: ActivitiesCreateNestedOneWithoutAccount_activitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUncheckedCreateWithoutAccountInput = {
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesCreateOrConnectWithoutAccountInput = {
    where: AccountActivitiesWhereUniqueInput
    create: XOR<AccountActivitiesCreateWithoutAccountInput, AccountActivitiesUncheckedCreateWithoutAccountInput>
  }

  export type AccountActivitiesCreateManyAccountInputEnvelope = {
    data: Enumerable<AccountActivitiesCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type AccountDeliveryCreateWithoutAccountInput = {
    delivery: DeliveryCreateNestedOneWithoutAccount_deliveriesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryUncheckedCreateWithoutAccountInput = {
    delivery_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryCreateOrConnectWithoutAccountInput = {
    where: AccountDeliveryWhereUniqueInput
    create: XOR<AccountDeliveryCreateWithoutAccountInput, AccountDeliveryUncheckedCreateWithoutAccountInput>
  }

  export type AccountDeliveryCreateManyAccountInputEnvelope = {
    data: Enumerable<AccountDeliveryCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type AccountUserCreateWithoutAccountInput = {
    id?: string
    user: UserCreateNestedOneWithoutAccount_userInput
    role: RoleCreateNestedOneWithoutAccountUserInput
  }

  export type AccountUserUncheckedCreateWithoutAccountInput = {
    id?: string
    user_id: string
    role_id: string
  }

  export type AccountUserCreateOrConnectWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput>
  }

  export type AccountUserCreateManyAccountInputEnvelope = {
    data: Enumerable<AccountUserCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutAccountInput = {
    id?: string
    order: OrderCreateNestedOneWithoutInvoiceInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutAccountInput = {
    id?: string
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutAccountInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput>
  }

  export type InvoiceCreateManyAccountInputEnvelope = {
    data: Enumerable<InvoiceCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type StockItemCreateWithoutAccountInput = {
    item: ItemCreateNestedOneWithoutStock_itemsInput
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockItemUncheckedCreateWithoutAccountInput = {
    item_id: string
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockItemCreateOrConnectWithoutAccountInput = {
    where: StockItemWhereUniqueInput
    create: XOR<StockItemCreateWithoutAccountInput, StockItemUncheckedCreateWithoutAccountInput>
  }

  export type StockItemCreateManyAccountInputEnvelope = {
    data: Enumerable<StockItemCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutAccountInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutAccountInput, ItemUncheckedCreateWithoutAccountInput>
  }

  export type ItemCreateManyAccountInputEnvelope = {
    data: Enumerable<ItemCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutAccountInput = {
    id?: string
    code: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutAccountInput = {
    id?: string
    code: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutAccountInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutAccountInput, CouponUncheckedCreateWithoutAccountInput>
  }

  export type CouponCreateManyAccountInputEnvelope = {
    data: Enumerable<CouponCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type AccountConfigurationCreateWithoutAccountInput = {
    id?: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationUncheckedCreateWithoutAccountInput = {
    id?: string
    banner_market_url?: string | null
    header_color?: string | null
  }

  export type AccountConfigurationCreateOrConnectWithoutAccountInput = {
    where: AccountConfigurationWhereUniqueInput
    create: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
  }

  export type CustomerCreateWithoutAccountInput = {
    id?: string
    email: string
    mobile_phone: string
    phone: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    origin_registration: CustomerOriginRegistration
    cpf_cnpj: string
    note: string
    converted?: boolean
  }

  export type CustomerUncheckedCreateWithoutAccountInput = {
    id?: string
    email: string
    mobile_phone: string
    phone: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    origin_registration: CustomerOriginRegistration
    cpf_cnpj: string
    note: string
    converted?: boolean
  }

  export type CustomerCreateOrConnectWithoutAccountInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
  }

  export type CustomerCreateManyAccountInputEnvelope = {
    data: Enumerable<CustomerCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutAccountInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutAccountInput, CampaignUncheckedUpdateWithoutAccountInput>
    create: XOR<CampaignCreateWithoutAccountInput, CampaignUncheckedCreateWithoutAccountInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutAccountInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutAccountInput, CampaignUncheckedUpdateWithoutAccountInput>
  }

  export type CampaignUpdateManyWithWhereWithoutAccountInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: Enumerable<CampaignScalarWhereInput>
    OR?: Enumerable<CampaignScalarWhereInput>
    NOT?: Enumerable<CampaignScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    discount_value?: FloatNullableFilter | number | null
    discount_type?: EnumCampaignTypeDiscountNullableFilter | CampaignTypeDiscount | null
    start_date?: DateTimeNullableFilter | Date | string | null
    expiration_date?: DateTimeNullableFilter | Date | string | null
    campaign_type_id?: StringFilter | string
    account_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PlanUpsertWithoutAccountInput = {
    update: XOR<PlanUpdateWithoutAccountInput, PlanUncheckedUpdateWithoutAccountInput>
    create: XOR<PlanCreateWithoutAccountInput, PlanUncheckedCreateWithoutAccountInput>
  }

  export type PlanUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle?: PaymentCycleUpdateOneRequiredWithoutPlansNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutAccountInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutAccountInput, SubscriptionUncheckedUpdateWithoutAccountInput>
    create: XOR<SubscriptionCreateWithoutAccountInput, SubscriptionUncheckedCreateWithoutAccountInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutAccountInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutAccountInput, SubscriptionUncheckedUpdateWithoutAccountInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutAccountInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: Enumerable<SubscriptionScalarWhereInput>
    OR?: Enumerable<SubscriptionScalarWhereInput>
    NOT?: Enumerable<SubscriptionScalarWhereInput>
    id?: StringFilter | string
    plan_id?: StringFilter | string
    account_id?: StringFilter | string
    due?: DateTimeFilter | Date | string
    price?: FloatFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutAccountInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutAccountInput, OrderUncheckedUpdateWithoutAccountInput>
    create: XOR<OrderCreateWithoutAccountInput, OrderUncheckedCreateWithoutAccountInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutAccountInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutAccountInput, OrderUncheckedUpdateWithoutAccountInput>
  }

  export type OrderUpdateManyWithWhereWithoutAccountInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    code?: StringFilter | string
    account_id?: StringFilter | string
    total?: FloatFilter | number
    coupon_id?: StringNullableFilter | string | null
    user_id?: StringFilter | string
    user_address_id?: StringFilter | string
    is_read?: BoolFilter | boolean
    order_status_id?: StringFilter | string
    campaign_id?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountActivitiesUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountActivitiesWhereUniqueInput
    update: XOR<AccountActivitiesUpdateWithoutAccountInput, AccountActivitiesUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountActivitiesCreateWithoutAccountInput, AccountActivitiesUncheckedCreateWithoutAccountInput>
  }

  export type AccountActivitiesUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountActivitiesWhereUniqueInput
    data: XOR<AccountActivitiesUpdateWithoutAccountInput, AccountActivitiesUncheckedUpdateWithoutAccountInput>
  }

  export type AccountActivitiesUpdateManyWithWhereWithoutAccountInput = {
    where: AccountActivitiesScalarWhereInput
    data: XOR<AccountActivitiesUpdateManyMutationInput, AccountActivitiesUncheckedUpdateManyWithoutAccount_activitiesInput>
  }

  export type AccountActivitiesScalarWhereInput = {
    AND?: Enumerable<AccountActivitiesScalarWhereInput>
    OR?: Enumerable<AccountActivitiesScalarWhereInput>
    NOT?: Enumerable<AccountActivitiesScalarWhereInput>
    account_id?: StringFilter | string
    activities_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountDeliveryUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountDeliveryWhereUniqueInput
    update: XOR<AccountDeliveryUpdateWithoutAccountInput, AccountDeliveryUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountDeliveryCreateWithoutAccountInput, AccountDeliveryUncheckedCreateWithoutAccountInput>
  }

  export type AccountDeliveryUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountDeliveryWhereUniqueInput
    data: XOR<AccountDeliveryUpdateWithoutAccountInput, AccountDeliveryUncheckedUpdateWithoutAccountInput>
  }

  export type AccountDeliveryUpdateManyWithWhereWithoutAccountInput = {
    where: AccountDeliveryScalarWhereInput
    data: XOR<AccountDeliveryUpdateManyMutationInput, AccountDeliveryUncheckedUpdateManyWithoutAccount_deliveriesInput>
  }

  export type AccountDeliveryScalarWhereInput = {
    AND?: Enumerable<AccountDeliveryScalarWhereInput>
    OR?: Enumerable<AccountDeliveryScalarWhereInput>
    NOT?: Enumerable<AccountDeliveryScalarWhereInput>
    account_id?: StringFilter | string
    delivery_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountUserUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutAccountInput, AccountUserUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutAccountInput, AccountUserUncheckedUpdateWithoutAccountInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutAccountInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutAccount_usersInput>
  }

  export type AccountUserScalarWhereInput = {
    AND?: Enumerable<AccountUserScalarWhereInput>
    OR?: Enumerable<AccountUserScalarWhereInput>
    NOT?: Enumerable<AccountUserScalarWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    user_id?: StringFilter | string
    role_id?: StringFilter | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutAccountInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutAccountInput, InvoiceUncheckedUpdateWithoutAccountInput>
    create: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutAccountInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutAccountInput, InvoiceUncheckedUpdateWithoutAccountInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutAccountInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: Enumerable<InvoiceScalarWhereInput>
    OR?: Enumerable<InvoiceScalarWhereInput>
    NOT?: Enumerable<InvoiceScalarWhereInput>
    id?: StringFilter | string
    order_id?: StringFilter | string
    account_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StockItemUpsertWithWhereUniqueWithoutAccountInput = {
    where: StockItemWhereUniqueInput
    update: XOR<StockItemUpdateWithoutAccountInput, StockItemUncheckedUpdateWithoutAccountInput>
    create: XOR<StockItemCreateWithoutAccountInput, StockItemUncheckedCreateWithoutAccountInput>
  }

  export type StockItemUpdateWithWhereUniqueWithoutAccountInput = {
    where: StockItemWhereUniqueInput
    data: XOR<StockItemUpdateWithoutAccountInput, StockItemUncheckedUpdateWithoutAccountInput>
  }

  export type StockItemUpdateManyWithWhereWithoutAccountInput = {
    where: StockItemScalarWhereInput
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyWithoutStock_itemsInput>
  }

  export type StockItemScalarWhereInput = {
    AND?: Enumerable<StockItemScalarWhereInput>
    OR?: Enumerable<StockItemScalarWhereInput>
    NOT?: Enumerable<StockItemScalarWhereInput>
    item_id?: StringFilter | string
    account_id?: StringFilter | string
    quantity?: IntFilter | number
    min_quantity?: IntFilter | number
    max_quantity?: IntFilter | number
  }

  export type ItemUpsertWithWhereUniqueWithoutAccountInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutAccountInput, ItemUncheckedUpdateWithoutAccountInput>
    create: XOR<ItemCreateWithoutAccountInput, ItemUncheckedCreateWithoutAccountInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutAccountInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutAccountInput, ItemUncheckedUpdateWithoutAccountInput>
  }

  export type ItemUpdateManyWithWhereWithoutAccountInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type ItemScalarWhereInput = {
    AND?: Enumerable<ItemScalarWhereInput>
    OR?: Enumerable<ItemScalarWhereInput>
    NOT?: Enumerable<ItemScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    type_id?: StringFilter | string
    country_id?: StringNullableFilter | string | null
    region_id?: StringNullableFilter | string | null
    winery_id?: StringNullableFilter | string | null
    harvest?: StringNullableFilter | string | null
    no_harvest?: BoolFilter | boolean
    wine_type_id?: StringNullableFilter | string | null
    alcohol_percentage?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    price?: FloatFilter | number
    promotional_price?: FloatNullableFilter | number | null
    photo?: StringNullableFilter | string | null
    account_id?: StringFilter | string
    is_active?: BoolFilter | boolean
    control_stock?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CouponUpsertWithWhereUniqueWithoutAccountInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutAccountInput, CouponUncheckedUpdateWithoutAccountInput>
    create: XOR<CouponCreateWithoutAccountInput, CouponUncheckedCreateWithoutAccountInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutAccountInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutAccountInput, CouponUncheckedUpdateWithoutAccountInput>
  }

  export type CouponUpdateManyWithWhereWithoutAccountInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutCouponsInput>
  }

  export type CouponScalarWhereInput = {
    AND?: Enumerable<CouponScalarWhereInput>
    OR?: Enumerable<CouponScalarWhereInput>
    NOT?: Enumerable<CouponScalarWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    account_id?: StringFilter | string
    dicount_type?: EnumCouponDiscountTypeFilter | CouponDiscountType
    discount_value?: FloatFilter | number
    couponUse_type?: EnumCouponUseTypeFilter | CouponUseType
    inital_date?: DateTimeFilter | Date | string
    expiration_date?: DateTimeNullableFilter | Date | string | null
    min_value?: FloatNullableFilter | number | null
    max_value?: FloatNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountConfigurationUpsertWithoutAccountInput = {
    update: XOR<AccountConfigurationUpdateWithoutAccountInput, AccountConfigurationUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountConfigurationCreateWithoutAccountInput, AccountConfigurationUncheckedCreateWithoutAccountInput>
  }

  export type AccountConfigurationUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountConfigurationUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner_market_url?: NullableStringFieldUpdateOperationsInput | string | null
    header_color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUpsertWithWhereUniqueWithoutAccountInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutAccountInput, CustomerUncheckedUpdateWithoutAccountInput>
    create: XOR<CustomerCreateWithoutAccountInput, CustomerUncheckedCreateWithoutAccountInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutAccountInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutAccountInput, CustomerUncheckedUpdateWithoutAccountInput>
  }

  export type CustomerUpdateManyWithWhereWithoutAccountInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: Enumerable<CustomerScalarWhereInput>
    OR?: Enumerable<CustomerScalarWhereInput>
    NOT?: Enumerable<CustomerScalarWhereInput>
    id?: StringFilter | string
    account_id?: StringFilter | string
    email?: StringFilter | string
    mobile_phone?: StringFilter | string
    phone?: StringFilter | string
    is_active?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFilter | CustomerOriginRegistration
    cpf_cnpj?: StringFilter | string
    note?: StringFilter | string
    converted?: BoolFilter | boolean
  }

  export type AccountCreateWithoutAccount_configurationInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutAccount_configurationInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutAccount_configurationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
  }

  export type AccountUpsertWithoutAccount_configurationInput = {
    update: XOR<AccountUpdateWithoutAccount_configurationInput, AccountUncheckedUpdateWithoutAccount_configurationInput>
    create: XOR<AccountCreateWithoutAccount_configurationInput, AccountUncheckedCreateWithoutAccount_configurationInput>
  }

  export type AccountUpdateWithoutAccount_configurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutAccount_configurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateWithoutAccount_activitiesInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutAccount_activitiesInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutAccount_activitiesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type ActivitiesCreateWithoutAccount_activitiesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivitiesUncheckedCreateWithoutAccount_activitiesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivitiesCreateOrConnectWithoutAccount_activitiesInput = {
    where: ActivitiesWhereUniqueInput
    create: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type AccountUpsertWithoutAccount_activitiesInput = {
    update: XOR<AccountUpdateWithoutAccount_activitiesInput, AccountUncheckedUpdateWithoutAccount_activitiesInput>
    create: XOR<AccountCreateWithoutAccount_activitiesInput, AccountUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type AccountUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivitiesUpsertWithoutAccount_activitiesInput = {
    update: XOR<ActivitiesUpdateWithoutAccount_activitiesInput, ActivitiesUncheckedUpdateWithoutAccount_activitiesInput>
    create: XOR<ActivitiesCreateWithoutAccount_activitiesInput, ActivitiesUncheckedCreateWithoutAccount_activitiesInput>
  }

  export type ActivitiesUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivitiesUncheckedUpdateWithoutAccount_activitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesCreateWithoutActivitiesInput = {
    account: AccountCreateNestedOneWithoutAccount_activitiesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUncheckedCreateWithoutActivitiesInput = {
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesCreateOrConnectWithoutActivitiesInput = {
    where: AccountActivitiesWhereUniqueInput
    create: XOR<AccountActivitiesCreateWithoutActivitiesInput, AccountActivitiesUncheckedCreateWithoutActivitiesInput>
  }

  export type AccountActivitiesCreateManyActivitiesInputEnvelope = {
    data: Enumerable<AccountActivitiesCreateManyActivitiesInput>
    skipDuplicates?: boolean
  }

  export type AccountActivitiesUpsertWithWhereUniqueWithoutActivitiesInput = {
    where: AccountActivitiesWhereUniqueInput
    update: XOR<AccountActivitiesUpdateWithoutActivitiesInput, AccountActivitiesUncheckedUpdateWithoutActivitiesInput>
    create: XOR<AccountActivitiesCreateWithoutActivitiesInput, AccountActivitiesUncheckedCreateWithoutActivitiesInput>
  }

  export type AccountActivitiesUpdateWithWhereUniqueWithoutActivitiesInput = {
    where: AccountActivitiesWhereUniqueInput
    data: XOR<AccountActivitiesUpdateWithoutActivitiesInput, AccountActivitiesUncheckedUpdateWithoutActivitiesInput>
  }

  export type AccountActivitiesUpdateManyWithWhereWithoutActivitiesInput = {
    where: AccountActivitiesScalarWhereInput
    data: XOR<AccountActivitiesUpdateManyMutationInput, AccountActivitiesUncheckedUpdateManyWithoutAccount_activitiesInput>
  }

  export type AccountDeliveryCreateWithoutDeliveryInput = {
    account: AccountCreateNestedOneWithoutAccount_deliveriesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryUncheckedCreateWithoutDeliveryInput = {
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryCreateOrConnectWithoutDeliveryInput = {
    where: AccountDeliveryWhereUniqueInput
    create: XOR<AccountDeliveryCreateWithoutDeliveryInput, AccountDeliveryUncheckedCreateWithoutDeliveryInput>
  }

  export type AccountDeliveryCreateManyDeliveryInputEnvelope = {
    data: Enumerable<AccountDeliveryCreateManyDeliveryInput>
    skipDuplicates?: boolean
  }

  export type AccountDeliveryUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: AccountDeliveryWhereUniqueInput
    update: XOR<AccountDeliveryUpdateWithoutDeliveryInput, AccountDeliveryUncheckedUpdateWithoutDeliveryInput>
    create: XOR<AccountDeliveryCreateWithoutDeliveryInput, AccountDeliveryUncheckedCreateWithoutDeliveryInput>
  }

  export type AccountDeliveryUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: AccountDeliveryWhereUniqueInput
    data: XOR<AccountDeliveryUpdateWithoutDeliveryInput, AccountDeliveryUncheckedUpdateWithoutDeliveryInput>
  }

  export type AccountDeliveryUpdateManyWithWhereWithoutDeliveryInput = {
    where: AccountDeliveryScalarWhereInput
    data: XOR<AccountDeliveryUpdateManyMutationInput, AccountDeliveryUncheckedUpdateManyWithoutAccount_deliveriesInput>
  }

  export type AccountCreateWithoutAccount_deliveriesInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutAccount_deliveriesInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutAccount_deliveriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_deliveriesInput, AccountUncheckedCreateWithoutAccount_deliveriesInput>
  }

  export type DeliveryCreateWithoutAccount_deliveriesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryUncheckedCreateWithoutAccount_deliveriesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryCreateOrConnectWithoutAccount_deliveriesInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutAccount_deliveriesInput, DeliveryUncheckedCreateWithoutAccount_deliveriesInput>
  }

  export type AccountUpsertWithoutAccount_deliveriesInput = {
    update: XOR<AccountUpdateWithoutAccount_deliveriesInput, AccountUncheckedUpdateWithoutAccount_deliveriesInput>
    create: XOR<AccountCreateWithoutAccount_deliveriesInput, AccountUncheckedCreateWithoutAccount_deliveriesInput>
  }

  export type AccountUpdateWithoutAccount_deliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutAccount_deliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeliveryUpsertWithoutAccount_deliveriesInput = {
    update: XOR<DeliveryUpdateWithoutAccount_deliveriesInput, DeliveryUncheckedUpdateWithoutAccount_deliveriesInput>
    create: XOR<DeliveryCreateWithoutAccount_deliveriesInput, DeliveryUncheckedCreateWithoutAccount_deliveriesInput>
  }

  export type DeliveryUpdateWithoutAccount_deliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateWithoutAccount_deliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateWithoutUserInput = {
    device: DeviceCreateNestedOneWithoutDevice_userInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUncheckedCreateWithoutUserInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserCreateOrConnectWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    create: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput>
  }

  export type DeviceUserCreateManyUserInputEnvelope = {
    data: Enumerable<DeviceUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountUserCreateWithoutUserInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_usersInput
    role: RoleCreateNestedOneWithoutAccountUserInput
  }

  export type AccountUserUncheckedCreateWithoutUserInput = {
    id?: string
    account_id: string
    role_id: string
  }

  export type AccountUserCreateOrConnectWithoutUserInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutUserInput, AccountUserUncheckedCreateWithoutUserInput>
  }

  export type AccountUserCreateManyUserInputEnvelope = {
    data: Enumerable<AccountUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: Enumerable<OrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutUserInput = {
    id?: string
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    orders?: OrderCreateNestedManyWithoutUser_addressInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    orders?: OrderUncheckedCreateNestedManyWithoutUser_addressInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressCreateManyUserInputEnvelope = {
    data: Enumerable<UserAddressCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DeviceUserUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    update: XOR<DeviceUserUpdateWithoutUserInput, DeviceUserUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceUserCreateWithoutUserInput, DeviceUserUncheckedCreateWithoutUserInput>
  }

  export type DeviceUserUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceUserWhereUniqueInput
    data: XOR<DeviceUserUpdateWithoutUserInput, DeviceUserUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUserUpdateManyWithWhereWithoutUserInput = {
    where: DeviceUserScalarWhereInput
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyWithoutDevice_userInput>
  }

  export type DeviceUserScalarWhereInput = {
    AND?: Enumerable<DeviceUserScalarWhereInput>
    OR?: Enumerable<DeviceUserScalarWhereInput>
    NOT?: Enumerable<DeviceUserScalarWhereInput>
    device_id?: StringFilter | string
    user_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type AccountUserUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutUserInput, AccountUserUncheckedUpdateWithoutUserInput>
    create: XOR<AccountUserCreateWithoutUserInput, AccountUserUncheckedCreateWithoutUserInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutUserInput, AccountUserUncheckedUpdateWithoutUserInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutUserInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutAccount_userInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type UserAddressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutUserInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUser_addressesInput>
  }

  export type UserAddressScalarWhereInput = {
    AND?: Enumerable<UserAddressScalarWhereInput>
    OR?: Enumerable<UserAddressScalarWhereInput>
    NOT?: Enumerable<UserAddressScalarWhereInput>
    id?: StringFilter | string
    user_id?: StringFilter | string
    name?: StringNullableFilter | string | null
    street?: StringFilter | string
    number?: StringFilter | string
    district?: StringFilter | string
    state?: StringFilter | string
    complement?: StringNullableFilter | string | null
    additional_information?: StringNullableFilter | string | null
    city?: StringFilter | string
    zip_code?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutUser_addressesInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutUserInput
    account_user?: AccountUserCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_addressesInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    account_user?: AccountUserUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_addressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_addressesInput, UserUncheckedCreateWithoutUser_addressesInput>
  }

  export type OrderCreateWithoutUser_addressInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUser_addressInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUser_addressInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUser_addressInput, OrderUncheckedCreateWithoutUser_addressInput>
  }

  export type OrderCreateManyUser_addressInputEnvelope = {
    data: Enumerable<OrderCreateManyUser_addressInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUser_addressesInput = {
    update: XOR<UserUpdateWithoutUser_addressesInput, UserUncheckedUpdateWithoutUser_addressesInput>
    create: XOR<UserCreateWithoutUser_addressesInput, UserUncheckedCreateWithoutUser_addressesInput>
  }

  export type UserUpdateWithoutUser_addressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_addressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutUser_addressInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUser_addressInput, OrderUncheckedUpdateWithoutUser_addressInput>
    create: XOR<OrderCreateWithoutUser_addressInput, OrderUncheckedCreateWithoutUser_addressInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUser_addressInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUser_addressInput, OrderUncheckedUpdateWithoutUser_addressInput>
  }

  export type OrderUpdateManyWithWhereWithoutUser_addressInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type AccountCreateWithoutAccount_usersInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutAccount_usersInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutAccount_usersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
  }

  export type UserCreateWithoutAccount_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccount_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccount_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
  }

  export type RoleCreateWithoutAccountUserInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutAccountUserInput = {
    id?: string
    name: string
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutAccountUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
  }

  export type AccountUpsertWithoutAccount_usersInput = {
    update: XOR<AccountUpdateWithoutAccount_usersInput, AccountUncheckedUpdateWithoutAccount_usersInput>
    create: XOR<AccountCreateWithoutAccount_usersInput, AccountUncheckedCreateWithoutAccount_usersInput>
  }

  export type AccountUpdateWithoutAccount_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutAccount_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutAccount_userInput = {
    update: XOR<UserUpdateWithoutAccount_userInput, UserUncheckedUpdateWithoutAccount_userInput>
    create: XOR<UserCreateWithoutAccount_userInput, UserUncheckedCreateWithoutAccount_userInput>
  }

  export type UserUpdateWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutAccountUserInput = {
    update: XOR<RoleUpdateWithoutAccountUserInput, RoleUncheckedUpdateWithoutAccountUserInput>
    create: XOR<RoleCreateWithoutAccountUserInput, RoleUncheckedCreateWithoutAccountUserInput>
  }

  export type RoleUpdateWithoutAccountUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutAccountUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    role: RoleCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    role_id: string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: Enumerable<RolePermissionCreateManyPermissionInput>
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: Enumerable<RolePermissionScalarWhereInput>
    OR?: Enumerable<RolePermissionScalarWhereInput>
    NOT?: Enumerable<RolePermissionScalarWhereInput>
    role_id?: StringFilter | string
    permission_id?: StringFilter | string
  }

  export type RoleCreateWithoutRolePermissionInput = {
    id?: string
    name: string
    AccountUser?: AccountUserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionInput = {
    id?: string
    name: string
    AccountUser?: AccountUserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
  }

  export type PermisionCreateWithoutRolePermissionInput = {
    id?: string
    name: string
  }

  export type PermisionUncheckedCreateWithoutRolePermissionInput = {
    id?: string
    name: string
  }

  export type PermisionCreateOrConnectWithoutRolePermissionInput = {
    where: PermisionWhereUniqueInput
    create: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
  }

  export type RoleUpsertWithoutRolePermissionInput = {
    update: XOR<RoleUpdateWithoutRolePermissionInput, RoleUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<RoleCreateWithoutRolePermissionInput, RoleUncheckedCreateWithoutRolePermissionInput>
  }

  export type RoleUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    AccountUser?: AccountUserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    AccountUser?: AccountUserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermisionUpsertWithoutRolePermissionInput = {
    update: XOR<PermisionUpdateWithoutRolePermissionInput, PermisionUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<PermisionCreateWithoutRolePermissionInput, PermisionUncheckedCreateWithoutRolePermissionInput>
  }

  export type PermisionUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermisionUncheckedUpdateWithoutRolePermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateWithoutRoleInput = {
    permission: PermisionCreateNestedOneWithoutRolePermissionInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permission_id: string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: Enumerable<RolePermissionCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type AccountUserCreateWithoutRoleInput = {
    id?: string
    account: AccountCreateNestedOneWithoutAccount_usersInput
    user: UserCreateNestedOneWithoutAccount_userInput
  }

  export type AccountUserUncheckedCreateWithoutRoleInput = {
    id?: string
    account_id: string
    user_id: string
  }

  export type AccountUserCreateOrConnectWithoutRoleInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutRoleInput, AccountUserUncheckedCreateWithoutRoleInput>
  }

  export type AccountUserCreateManyRoleInputEnvelope = {
    data: Enumerable<AccountUserCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type AccountUserUpsertWithWhereUniqueWithoutRoleInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutRoleInput, AccountUserUncheckedUpdateWithoutRoleInput>
    create: XOR<AccountUserCreateWithoutRoleInput, AccountUserUncheckedCreateWithoutRoleInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutRoleInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutRoleInput, AccountUserUncheckedUpdateWithoutRoleInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutRoleInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutAccountUserInput>
  }

  export type CampaignTypeCreateWithoutCampaignInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
  }

  export type CampaignTypeUncheckedCreateWithoutCampaignInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
  }

  export type CampaignTypeCreateOrConnectWithoutCampaignInput = {
    where: CampaignTypeWhereUniqueInput
    create: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
  }

  export type AccountCreateWithoutCampaignInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutCampaignInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutCampaignInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
  }

  export type OrderCreateWithoutCampaignInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCampaignInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCampaignInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCampaignInput, OrderUncheckedCreateWithoutCampaignInput>
  }

  export type OrderCreateManyCampaignInputEnvelope = {
    data: Enumerable<OrderCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type CampaignItemCreateWithoutCampaignInput = {
    item: ItemCreateNestedOneWithoutCampaign_itemsInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemUncheckedCreateWithoutCampaignInput = {
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemCreateOrConnectWithoutCampaignInput = {
    where: CampaignItemWhereUniqueInput
    create: XOR<CampaignItemCreateWithoutCampaignInput, CampaignItemUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignItemCreateManyCampaignInputEnvelope = {
    data: Enumerable<CampaignItemCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type CampaignTypeUpsertWithoutCampaignInput = {
    update: XOR<CampaignTypeUpdateWithoutCampaignInput, CampaignTypeUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignTypeCreateWithoutCampaignInput, CampaignTypeUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTypeUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignTypeUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUpsertWithoutCampaignInput = {
    update: XOR<AccountUpdateWithoutCampaignInput, AccountUncheckedUpdateWithoutCampaignInput>
    create: XOR<AccountCreateWithoutCampaignInput, AccountUncheckedCreateWithoutCampaignInput>
  }

  export type AccountUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutCampaignInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCampaignInput, OrderUncheckedUpdateWithoutCampaignInput>
    create: XOR<OrderCreateWithoutCampaignInput, OrderUncheckedCreateWithoutCampaignInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCampaignInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCampaignInput, OrderUncheckedUpdateWithoutCampaignInput>
  }

  export type OrderUpdateManyWithWhereWithoutCampaignInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type CampaignItemUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignItemWhereUniqueInput
    update: XOR<CampaignItemUpdateWithoutCampaignInput, CampaignItemUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignItemCreateWithoutCampaignInput, CampaignItemUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignItemUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignItemWhereUniqueInput
    data: XOR<CampaignItemUpdateWithoutCampaignInput, CampaignItemUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignItemUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignItemScalarWhereInput
    data: XOR<CampaignItemUpdateManyMutationInput, CampaignItemUncheckedUpdateManyWithoutCampaign_itemsInput>
  }

  export type CampaignItemScalarWhereInput = {
    AND?: Enumerable<CampaignItemScalarWhereInput>
    OR?: Enumerable<CampaignItemScalarWhereInput>
    NOT?: Enumerable<CampaignItemScalarWhereInput>
    item_id?: StringFilter | string
    campaign_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CampaignCreateWithoutCampaign_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    account: AccountCreateNestedOneWithoutCampaignInput
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCampaignInput
    campaign_items?: CampaignItemCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaign_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCampaignInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaign_typeInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaign_typeInput, CampaignUncheckedCreateWithoutCampaign_typeInput>
  }

  export type CampaignCreateManyCampaign_typeInputEnvelope = {
    data: Enumerable<CampaignCreateManyCampaign_typeInput>
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutCampaign_typeInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCampaign_typeInput, CampaignUncheckedUpdateWithoutCampaign_typeInput>
    create: XOR<CampaignCreateWithoutCampaign_typeInput, CampaignUncheckedCreateWithoutCampaign_typeInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCampaign_typeInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCampaign_typeInput, CampaignUncheckedUpdateWithoutCampaign_typeInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCampaign_typeInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type AccountCreateWithoutCouponsInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutCouponsInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutCouponsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCouponsInput, AccountUncheckedCreateWithoutCouponsInput>
  }

  export type OrderCreateWithoutCouponInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    user: UserCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCouponInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCouponInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>
  }

  export type OrderCreateManyCouponInputEnvelope = {
    data: Enumerable<OrderCreateManyCouponInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutCouponsInput = {
    update: XOR<AccountUpdateWithoutCouponsInput, AccountUncheckedUpdateWithoutCouponsInput>
    create: XOR<AccountCreateWithoutCouponsInput, AccountUncheckedCreateWithoutCouponsInput>
  }

  export type AccountUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutCouponInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCouponInput, OrderUncheckedUpdateWithoutCouponInput>
    create: XOR<OrderCreateWithoutCouponInput, OrderUncheckedCreateWithoutCouponInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCouponInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCouponInput, OrderUncheckedUpdateWithoutCouponInput>
  }

  export type OrderUpdateManyWithWhereWithoutCouponInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type ItemTypeCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTypeUncheckedCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTypeCreateOrConnectWithoutItemsInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
  }

  export type CountryCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    value: string
    states?: StateCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUncheckedCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    value: string
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryCreateOrConnectWithoutItemsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutItemsInput, CountryUncheckedCreateWithoutItemsInput>
  }

  export type RegionCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    state: StateCreateNestedOneWithoutRegionsInput
    name: string
    slug: string
    subregion?: SubRegionCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    state_id: string
    name: string
    slug: string
    subregion?: SubRegionUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionCreateOrConnectWithoutItemsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutItemsInput, RegionUncheckedCreateWithoutItemsInput>
  }

  export type WineryCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineryUncheckedCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineryCreateOrConnectWithoutItemsInput = {
    where: WineryWhereUniqueInput
    create: XOR<WineryCreateWithoutItemsInput, WineryUncheckedCreateWithoutItemsInput>
  }

  export type WineTypeCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeUncheckedCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WineTypeCreateOrConnectWithoutItemsInput = {
    where: WineTypeWhereUniqueInput
    create: XOR<WineTypeCreateWithoutItemsInput, WineTypeUncheckedCreateWithoutItemsInput>
  }

  export type AccountCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutItemsInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutItemsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutItemsInput, AccountUncheckedCreateWithoutItemsInput>
  }

  export type ItemGrapeCreateWithoutItemInput = {
    grape: GrapeCreateNestedOneWithoutItem_grapeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeUncheckedCreateWithoutItemInput = {
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeCreateOrConnectWithoutItemInput = {
    where: ItemGrapeWhereUniqueInput
    create: XOR<ItemGrapeCreateWithoutItemInput, ItemGrapeUncheckedCreateWithoutItemInput>
  }

  export type ItemGrapeCreateManyItemInputEnvelope = {
    data: Enumerable<ItemGrapeCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutItemInput = {
    order: OrderCreateNestedOneWithoutOrder_itemsInput
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type OrderItemUncheckedCreateWithoutItemInput = {
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type OrderItemCreateOrConnectWithoutItemInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutItemInput, OrderItemUncheckedCreateWithoutItemInput>
  }

  export type OrderItemCreateManyItemInputEnvelope = {
    data: Enumerable<OrderItemCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type CampaignItemCreateWithoutItemInput = {
    campaign: CampaignCreateNestedOneWithoutCampaign_itemsInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemUncheckedCreateWithoutItemInput = {
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemCreateOrConnectWithoutItemInput = {
    where: CampaignItemWhereUniqueInput
    create: XOR<CampaignItemCreateWithoutItemInput, CampaignItemUncheckedCreateWithoutItemInput>
  }

  export type CampaignItemCreateManyItemInputEnvelope = {
    data: Enumerable<CampaignItemCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type StockItemCreateWithoutItemInput = {
    account: AccountCreateNestedOneWithoutStock_itemsInput
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockItemUncheckedCreateWithoutItemInput = {
    account_id: string
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockItemCreateOrConnectWithoutItemInput = {
    where: StockItemWhereUniqueInput
    create: XOR<StockItemCreateWithoutItemInput, StockItemUncheckedCreateWithoutItemInput>
  }

  export type StockItemCreateManyItemInputEnvelope = {
    data: Enumerable<StockItemCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type StockHistoryCreateWithoutItemInput = {
    id?: string
    reason?: string | null
    operation: StockHistoryType
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryUncheckedCreateWithoutItemInput = {
    id?: string
    reason?: string | null
    operation: StockHistoryType
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockHistoryCreateOrConnectWithoutItemInput = {
    where: StockHistoryWhereUniqueInput
    create: XOR<StockHistoryCreateWithoutItemInput, StockHistoryUncheckedCreateWithoutItemInput>
  }

  export type StockHistoryCreateManyItemInputEnvelope = {
    data: Enumerable<StockHistoryCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type ItemTagCreateWithoutItemInput = {
    tag: TagCreateNestedOneWithoutItemTagInput
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagUncheckedCreateWithoutItemInput = {
    tag_id: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagCreateOrConnectWithoutItemInput = {
    where: ItemTagWhereUniqueInput
    create: XOR<ItemTagCreateWithoutItemInput, ItemTagUncheckedCreateWithoutItemInput>
  }

  export type ItemTagCreateManyItemInputEnvelope = {
    data: Enumerable<ItemTagCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type ItemTypeUpsertWithoutItemsInput = {
    update: XOR<ItemTypeUpdateWithoutItemsInput, ItemTypeUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemTypeCreateWithoutItemsInput, ItemTypeUncheckedCreateWithoutItemsInput>
  }

  export type ItemTypeUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUpsertWithoutItemsInput = {
    update: XOR<CountryUpdateWithoutItemsInput, CountryUncheckedUpdateWithoutItemsInput>
    create: XOR<CountryCreateWithoutItemsInput, CountryUncheckedCreateWithoutItemsInput>
  }

  export type CountryUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    states?: StateUncheckedUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpsertWithoutItemsInput = {
    update: XOR<RegionUpdateWithoutItemsInput, RegionUncheckedUpdateWithoutItemsInput>
    create: XOR<RegionCreateWithoutItemsInput, RegionUncheckedCreateWithoutItemsInput>
  }

  export type RegionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: StateUpdateOneRequiredWithoutRegionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineryUpsertWithoutItemsInput = {
    update: XOR<WineryUpdateWithoutItemsInput, WineryUncheckedUpdateWithoutItemsInput>
    create: XOR<WineryCreateWithoutItemsInput, WineryUncheckedCreateWithoutItemsInput>
  }

  export type WineryUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineryUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUpsertWithoutItemsInput = {
    update: XOR<WineTypeUpdateWithoutItemsInput, WineTypeUncheckedUpdateWithoutItemsInput>
    create: XOR<WineTypeCreateWithoutItemsInput, WineTypeUncheckedCreateWithoutItemsInput>
  }

  export type WineTypeUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WineTypeUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithoutItemsInput = {
    update: XOR<AccountUpdateWithoutItemsInput, AccountUncheckedUpdateWithoutItemsInput>
    create: XOR<AccountCreateWithoutItemsInput, AccountUncheckedCreateWithoutItemsInput>
  }

  export type AccountUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemGrapeUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemGrapeWhereUniqueInput
    update: XOR<ItemGrapeUpdateWithoutItemInput, ItemGrapeUncheckedUpdateWithoutItemInput>
    create: XOR<ItemGrapeCreateWithoutItemInput, ItemGrapeUncheckedCreateWithoutItemInput>
  }

  export type ItemGrapeUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemGrapeWhereUniqueInput
    data: XOR<ItemGrapeUpdateWithoutItemInput, ItemGrapeUncheckedUpdateWithoutItemInput>
  }

  export type ItemGrapeUpdateManyWithWhereWithoutItemInput = {
    where: ItemGrapeScalarWhereInput
    data: XOR<ItemGrapeUpdateManyMutationInput, ItemGrapeUncheckedUpdateManyWithoutItem_grapeInput>
  }

  export type ItemGrapeScalarWhereInput = {
    AND?: Enumerable<ItemGrapeScalarWhereInput>
    OR?: Enumerable<ItemGrapeScalarWhereInput>
    NOT?: Enumerable<ItemGrapeScalarWhereInput>
    item_id?: StringFilter | string
    grape_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutItemInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutItemInput, OrderItemUncheckedUpdateWithoutItemInput>
    create: XOR<OrderItemCreateWithoutItemInput, OrderItemUncheckedCreateWithoutItemInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutItemInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutItemInput, OrderItemUncheckedUpdateWithoutItemInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutItemInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrder_itemsInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: Enumerable<OrderItemScalarWhereInput>
    OR?: Enumerable<OrderItemScalarWhereInput>
    NOT?: Enumerable<OrderItemScalarWhereInput>
    order_id?: StringFilter | string
    item_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    price?: FloatFilter | number
    quantity?: IntFilter | number
  }

  export type CampaignItemUpsertWithWhereUniqueWithoutItemInput = {
    where: CampaignItemWhereUniqueInput
    update: XOR<CampaignItemUpdateWithoutItemInput, CampaignItemUncheckedUpdateWithoutItemInput>
    create: XOR<CampaignItemCreateWithoutItemInput, CampaignItemUncheckedCreateWithoutItemInput>
  }

  export type CampaignItemUpdateWithWhereUniqueWithoutItemInput = {
    where: CampaignItemWhereUniqueInput
    data: XOR<CampaignItemUpdateWithoutItemInput, CampaignItemUncheckedUpdateWithoutItemInput>
  }

  export type CampaignItemUpdateManyWithWhereWithoutItemInput = {
    where: CampaignItemScalarWhereInput
    data: XOR<CampaignItemUpdateManyMutationInput, CampaignItemUncheckedUpdateManyWithoutCampaign_itemsInput>
  }

  export type StockItemUpsertWithWhereUniqueWithoutItemInput = {
    where: StockItemWhereUniqueInput
    update: XOR<StockItemUpdateWithoutItemInput, StockItemUncheckedUpdateWithoutItemInput>
    create: XOR<StockItemCreateWithoutItemInput, StockItemUncheckedCreateWithoutItemInput>
  }

  export type StockItemUpdateWithWhereUniqueWithoutItemInput = {
    where: StockItemWhereUniqueInput
    data: XOR<StockItemUpdateWithoutItemInput, StockItemUncheckedUpdateWithoutItemInput>
  }

  export type StockItemUpdateManyWithWhereWithoutItemInput = {
    where: StockItemScalarWhereInput
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyWithoutStock_itemsInput>
  }

  export type StockHistoryUpsertWithWhereUniqueWithoutItemInput = {
    where: StockHistoryWhereUniqueInput
    update: XOR<StockHistoryUpdateWithoutItemInput, StockHistoryUncheckedUpdateWithoutItemInput>
    create: XOR<StockHistoryCreateWithoutItemInput, StockHistoryUncheckedCreateWithoutItemInput>
  }

  export type StockHistoryUpdateWithWhereUniqueWithoutItemInput = {
    where: StockHistoryWhereUniqueInput
    data: XOR<StockHistoryUpdateWithoutItemInput, StockHistoryUncheckedUpdateWithoutItemInput>
  }

  export type StockHistoryUpdateManyWithWhereWithoutItemInput = {
    where: StockHistoryScalarWhereInput
    data: XOR<StockHistoryUpdateManyMutationInput, StockHistoryUncheckedUpdateManyWithoutStock_historyInput>
  }

  export type StockHistoryScalarWhereInput = {
    AND?: Enumerable<StockHistoryScalarWhereInput>
    OR?: Enumerable<StockHistoryScalarWhereInput>
    NOT?: Enumerable<StockHistoryScalarWhereInput>
    id?: StringFilter | string
    item_id?: StringFilter | string
    reason?: StringNullableFilter | string | null
    operation?: EnumStockHistoryTypeFilter | StockHistoryType
    quantity?: IntFilter | number
    date?: DateTimeFilter | Date | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ItemTagUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemTagWhereUniqueInput
    update: XOR<ItemTagUpdateWithoutItemInput, ItemTagUncheckedUpdateWithoutItemInput>
    create: XOR<ItemTagCreateWithoutItemInput, ItemTagUncheckedCreateWithoutItemInput>
  }

  export type ItemTagUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemTagWhereUniqueInput
    data: XOR<ItemTagUpdateWithoutItemInput, ItemTagUncheckedUpdateWithoutItemInput>
  }

  export type ItemTagUpdateManyWithWhereWithoutItemInput = {
    where: ItemTagScalarWhereInput
    data: XOR<ItemTagUpdateManyMutationInput, ItemTagUncheckedUpdateManyWithoutItemTagInput>
  }

  export type ItemTagScalarWhereInput = {
    AND?: Enumerable<ItemTagScalarWhereInput>
    OR?: Enumerable<ItemTagScalarWhereInput>
    NOT?: Enumerable<ItemTagScalarWhereInput>
    item_id?: StringFilter | string
    tag_id?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ItemCreateWithoutItem_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItem_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput>
  }

  export type ItemCreateManyItem_typeInputEnvelope = {
    data: Enumerable<ItemCreateManyItem_typeInput>
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutItem_typeInput, ItemUncheckedUpdateWithoutItem_typeInput>
    create: XOR<ItemCreateWithoutItem_typeInput, ItemUncheckedCreateWithoutItem_typeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutItem_typeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutItem_typeInput, ItemUncheckedUpdateWithoutItem_typeInput>
  }

  export type ItemUpdateManyWithWhereWithoutItem_typeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type ItemTagCreateWithoutTagInput = {
    item: ItemCreateNestedOneWithoutItemTagInput
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagUncheckedCreateWithoutTagInput = {
    item_id: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagCreateOrConnectWithoutTagInput = {
    where: ItemTagWhereUniqueInput
    create: XOR<ItemTagCreateWithoutTagInput, ItemTagUncheckedCreateWithoutTagInput>
  }

  export type ItemTagCreateManyTagInputEnvelope = {
    data: Enumerable<ItemTagCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type ItemTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ItemTagWhereUniqueInput
    update: XOR<ItemTagUpdateWithoutTagInput, ItemTagUncheckedUpdateWithoutTagInput>
    create: XOR<ItemTagCreateWithoutTagInput, ItemTagUncheckedCreateWithoutTagInput>
  }

  export type ItemTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ItemTagWhereUniqueInput
    data: XOR<ItemTagUpdateWithoutTagInput, ItemTagUncheckedUpdateWithoutTagInput>
  }

  export type ItemTagUpdateManyWithWhereWithoutTagInput = {
    where: ItemTagScalarWhereInput
    data: XOR<ItemTagUpdateManyMutationInput, ItemTagUncheckedUpdateManyWithoutItemTagInput>
  }

  export type ItemCreateWithoutItemTagInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItemTagInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItemTagInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemTagInput, ItemUncheckedCreateWithoutItemTagInput>
  }

  export type TagCreateWithoutItemTagInput = {
    id?: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TagUncheckedCreateWithoutItemTagInput = {
    id?: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TagCreateOrConnectWithoutItemTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutItemTagInput, TagUncheckedCreateWithoutItemTagInput>
  }

  export type ItemUpsertWithoutItemTagInput = {
    update: XOR<ItemUpdateWithoutItemTagInput, ItemUncheckedUpdateWithoutItemTagInput>
    create: XOR<ItemCreateWithoutItemTagInput, ItemUncheckedCreateWithoutItemTagInput>
  }

  export type ItemUpdateWithoutItemTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type TagUpsertWithoutItemTagInput = {
    update: XOR<TagUpdateWithoutItemTagInput, TagUncheckedUpdateWithoutItemTagInput>
    create: XOR<TagCreateWithoutItemTagInput, TagUncheckedCreateWithoutItemTagInput>
  }

  export type TagUpdateWithoutItemTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutItemTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateWithoutCampaign_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCampaign_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCampaign_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCampaign_itemsInput, ItemUncheckedCreateWithoutCampaign_itemsInput>
  }

  export type CampaignCreateWithoutCampaign_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    account: AccountCreateNestedOneWithoutCampaignInput
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaign_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaign_itemsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaign_itemsInput, CampaignUncheckedCreateWithoutCampaign_itemsInput>
  }

  export type ItemUpsertWithoutCampaign_itemsInput = {
    update: XOR<ItemUpdateWithoutCampaign_itemsInput, ItemUncheckedUpdateWithoutCampaign_itemsInput>
    create: XOR<ItemCreateWithoutCampaign_itemsInput, ItemUncheckedCreateWithoutCampaign_itemsInput>
  }

  export type ItemUpdateWithoutCampaign_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCampaign_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CampaignUpsertWithoutCampaign_itemsInput = {
    update: XOR<CampaignUpdateWithoutCampaign_itemsInput, CampaignUncheckedUpdateWithoutCampaign_itemsInput>
    create: XOR<CampaignCreateWithoutCampaign_itemsInput, CampaignUncheckedCreateWithoutCampaign_itemsInput>
  }

  export type CampaignUpdateWithoutCampaign_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaign_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ItemCreateWithoutItem_grapeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItem_grapeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItem_grapeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItem_grapeInput, ItemUncheckedCreateWithoutItem_grapeInput>
  }

  export type GrapeCreateWithoutItem_grapeInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeUncheckedCreateWithoutItem_grapeInput = {
    id?: string
    external_id?: number | null
    name: string
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type GrapeCreateOrConnectWithoutItem_grapeInput = {
    where: GrapeWhereUniqueInput
    create: XOR<GrapeCreateWithoutItem_grapeInput, GrapeUncheckedCreateWithoutItem_grapeInput>
  }

  export type ItemUpsertWithoutItem_grapeInput = {
    update: XOR<ItemUpdateWithoutItem_grapeInput, ItemUncheckedUpdateWithoutItem_grapeInput>
    create: XOR<ItemCreateWithoutItem_grapeInput, ItemUncheckedCreateWithoutItem_grapeInput>
  }

  export type ItemUpdateWithoutItem_grapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItem_grapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type GrapeUpsertWithoutItem_grapeInput = {
    update: XOR<GrapeUpdateWithoutItem_grapeInput, GrapeUncheckedUpdateWithoutItem_grapeInput>
    create: XOR<GrapeCreateWithoutItem_grapeInput, GrapeUncheckedCreateWithoutItem_grapeInput>
  }

  export type GrapeUpdateWithoutItem_grapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrapeUncheckedUpdateWithoutItem_grapeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeCreateWithoutGrapeInput = {
    item: ItemCreateNestedOneWithoutItem_grapeInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeUncheckedCreateWithoutGrapeInput = {
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeCreateOrConnectWithoutGrapeInput = {
    where: ItemGrapeWhereUniqueInput
    create: XOR<ItemGrapeCreateWithoutGrapeInput, ItemGrapeUncheckedCreateWithoutGrapeInput>
  }

  export type ItemGrapeCreateManyGrapeInputEnvelope = {
    data: Enumerable<ItemGrapeCreateManyGrapeInput>
    skipDuplicates?: boolean
  }

  export type ItemGrapeUpsertWithWhereUniqueWithoutGrapeInput = {
    where: ItemGrapeWhereUniqueInput
    update: XOR<ItemGrapeUpdateWithoutGrapeInput, ItemGrapeUncheckedUpdateWithoutGrapeInput>
    create: XOR<ItemGrapeCreateWithoutGrapeInput, ItemGrapeUncheckedCreateWithoutGrapeInput>
  }

  export type ItemGrapeUpdateWithWhereUniqueWithoutGrapeInput = {
    where: ItemGrapeWhereUniqueInput
    data: XOR<ItemGrapeUpdateWithoutGrapeInput, ItemGrapeUncheckedUpdateWithoutGrapeInput>
  }

  export type ItemGrapeUpdateManyWithWhereWithoutGrapeInput = {
    where: ItemGrapeScalarWhereInput
    data: XOR<ItemGrapeUpdateManyMutationInput, ItemGrapeUncheckedUpdateManyWithoutItem_grapeInput>
  }

  export type StateCreateWithoutCountryInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    regions?: RegionCreateNestedManyWithoutStateInput
    cities?: CityCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateWithoutCountryInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    regions?: RegionUncheckedCreateNestedManyWithoutStateInput
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateCreateOrConnectWithoutCountryInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateCreateManyCountryInputEnvelope = {
    data: Enumerable<StateCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutCountryInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCountryInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCountryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCountryInput, ItemUncheckedCreateWithoutCountryInput>
  }

  export type ItemCreateManyCountryInputEnvelope = {
    data: Enumerable<ItemCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    update: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateUpdateWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    data: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
  }

  export type StateUpdateManyWithWhereWithoutCountryInput = {
    where: StateScalarWhereInput
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyWithoutStatesInput>
  }

  export type StateScalarWhereInput = {
    AND?: Enumerable<StateScalarWhereInput>
    OR?: Enumerable<StateScalarWhereInput>
    NOT?: Enumerable<StateScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    country_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ItemUpsertWithWhereUniqueWithoutCountryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCountryInput, ItemUncheckedUpdateWithoutCountryInput>
    create: XOR<ItemCreateWithoutCountryInput, ItemUncheckedCreateWithoutCountryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCountryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCountryInput, ItemUncheckedUpdateWithoutCountryInput>
  }

  export type ItemUpdateManyWithWhereWithoutCountryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type CountryCreateWithoutStatesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    value: string
    items?: ItemCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryUncheckedCreateWithoutStatesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    value: string
    items?: ItemUncheckedCreateNestedManyWithoutCountryInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CountryCreateOrConnectWithoutStatesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type RegionCreateWithoutStateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    subregion?: SubRegionCreateNestedManyWithoutRegionInput
    items?: ItemCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateWithoutStateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    subregion?: SubRegionUncheckedCreateNestedManyWithoutRegionInput
    items?: ItemUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionCreateOrConnectWithoutStateInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutStateInput, RegionUncheckedCreateWithoutStateInput>
  }

  export type RegionCreateManyStateInputEnvelope = {
    data: Enumerable<RegionCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutStateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityUncheckedCreateWithoutStateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityCreateOrConnectWithoutStateInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityCreateManyStateInputEnvelope = {
    data: Enumerable<CityCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutStatesInput = {
    update: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type CountryUpdateWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutCountryNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpsertWithWhereUniqueWithoutStateInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutStateInput, RegionUncheckedUpdateWithoutStateInput>
    create: XOR<RegionCreateWithoutStateInput, RegionUncheckedCreateWithoutStateInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutStateInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutStateInput, RegionUncheckedUpdateWithoutStateInput>
  }

  export type RegionUpdateManyWithWhereWithoutStateInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutRegionsInput>
  }

  export type RegionScalarWhereInput = {
    AND?: Enumerable<RegionScalarWhereInput>
    OR?: Enumerable<RegionScalarWhereInput>
    NOT?: Enumerable<RegionScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    state_id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type CityUpsertWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityUpdateWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithWhereWithoutStateInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    state_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type StateCreateWithoutCitiesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    country: CountryCreateNestedOneWithoutStatesInput
    regions?: RegionCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateWithoutCitiesInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    country_id: string
    regions?: RegionUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateCreateOrConnectWithoutCitiesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type StateUpsertWithoutCitiesInput = {
    update: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type StateUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    regions?: RegionUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    regions?: RegionUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateWithoutRegionsInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    country: CountryCreateNestedOneWithoutStatesInput
    cities?: CityCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUncheckedCreateWithoutRegionsInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    country_id: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateCreateOrConnectWithoutRegionsInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
  }

  export type SubRegionCreateWithoutRegionInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUncheckedCreateWithoutRegionInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionCreateOrConnectWithoutRegionInput = {
    where: SubRegionWhereUniqueInput
    create: XOR<SubRegionCreateWithoutRegionInput, SubRegionUncheckedCreateWithoutRegionInput>
  }

  export type SubRegionCreateManyRegionInputEnvelope = {
    data: Enumerable<SubRegionCreateManyRegionInput>
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutRegionInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutRegionInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutRegionInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutRegionInput, ItemUncheckedCreateWithoutRegionInput>
  }

  export type ItemCreateManyRegionInputEnvelope = {
    data: Enumerable<ItemCreateManyRegionInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithoutRegionsInput = {
    update: XOR<StateUpdateWithoutRegionsInput, StateUncheckedUpdateWithoutRegionsInput>
    create: XOR<StateCreateWithoutRegionsInput, StateUncheckedCreateWithoutRegionsInput>
  }

  export type StateUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUpsertWithWhereUniqueWithoutRegionInput = {
    where: SubRegionWhereUniqueInput
    update: XOR<SubRegionUpdateWithoutRegionInput, SubRegionUncheckedUpdateWithoutRegionInput>
    create: XOR<SubRegionCreateWithoutRegionInput, SubRegionUncheckedCreateWithoutRegionInput>
  }

  export type SubRegionUpdateWithWhereUniqueWithoutRegionInput = {
    where: SubRegionWhereUniqueInput
    data: XOR<SubRegionUpdateWithoutRegionInput, SubRegionUncheckedUpdateWithoutRegionInput>
  }

  export type SubRegionUpdateManyWithWhereWithoutRegionInput = {
    where: SubRegionScalarWhereInput
    data: XOR<SubRegionUpdateManyMutationInput, SubRegionUncheckedUpdateManyWithoutSubregionInput>
  }

  export type SubRegionScalarWhereInput = {
    AND?: Enumerable<SubRegionScalarWhereInput>
    OR?: Enumerable<SubRegionScalarWhereInput>
    NOT?: Enumerable<SubRegionScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    slug?: StringFilter | string
    region_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ItemUpsertWithWhereUniqueWithoutRegionInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutRegionInput, ItemUncheckedUpdateWithoutRegionInput>
    create: XOR<ItemCreateWithoutRegionInput, ItemUncheckedCreateWithoutRegionInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutRegionInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutRegionInput, ItemUncheckedUpdateWithoutRegionInput>
  }

  export type ItemUpdateManyWithWhereWithoutRegionInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type RegionCreateWithoutSubregionInput = {
    id?: string
    external_id?: number | null
    state: StateCreateNestedOneWithoutRegionsInput
    name: string
    slug: string
    items?: ItemCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateWithoutSubregionInput = {
    id?: string
    external_id?: number | null
    state_id: string
    name: string
    slug: string
    items?: ItemUncheckedCreateNestedManyWithoutRegionInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionCreateOrConnectWithoutSubregionInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
  }

  export type RegionUpsertWithoutSubregionInput = {
    update: XOR<RegionUpdateWithoutSubregionInput, RegionUncheckedUpdateWithoutSubregionInput>
    create: XOR<RegionCreateWithoutSubregionInput, RegionUncheckedCreateWithoutSubregionInput>
  }

  export type RegionUpdateWithoutSubregionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: StateUpdateOneRequiredWithoutRegionsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutSubregionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    state_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateWithoutWine_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutWine_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutWine_typeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutWine_typeInput, ItemUncheckedCreateWithoutWine_typeInput>
  }

  export type ItemCreateManyWine_typeInputEnvelope = {
    data: Enumerable<ItemCreateManyWine_typeInput>
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutWine_typeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutWine_typeInput, ItemUncheckedUpdateWithoutWine_typeInput>
    create: XOR<ItemCreateWithoutWine_typeInput, ItemUncheckedCreateWithoutWine_typeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutWine_typeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutWine_typeInput, ItemUncheckedUpdateWithoutWine_typeInput>
  }

  export type ItemUpdateManyWithWhereWithoutWine_typeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type AccountCreateWithoutOrderInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutOrderInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutOrderInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
  }

  export type CouponCreateWithoutOrdersInput = {
    id?: string
    code: string
    account: AccountCreateNestedOneWithoutCouponsInput
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponUncheckedCreateWithoutOrdersInput = {
    id?: string
    code: string
    account_id: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponCreateOrConnectWithoutOrdersInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutOrdersInput, CouponUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutUserInput
    account_user?: AccountUserCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutUserInput
    account_user?: AccountUserUncheckedCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserAddressCreateWithoutOrdersInput = {
    id?: string
    user: UserCreateNestedOneWithoutUser_addressesInput
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressUncheckedCreateWithoutOrdersInput = {
    id?: string
    user_id: string
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressCreateOrConnectWithoutOrdersInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutOrdersInput, UserAddressUncheckedCreateWithoutOrdersInput>
  }

  export type OrderStatusCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderStatusUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderStatusCreateOrConnectWithoutOrdersInput = {
    where: OrderStatusWhereUniqueInput
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
  }

  export type CampaignCreateWithoutOrdersInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type: CampaignTypeCreateNestedOneWithoutCampaignInput
    account: AccountCreateNestedOneWithoutCampaignInput
    created_at?: Date | string
    updated_at?: Date | string
    campaign_items?: CampaignItemCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOrdersInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type_id: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOrdersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOrdersInput, CampaignUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    item: ItemCreateNestedOneWithoutOrder_itemsInput
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<OrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    account: AccountCreateNestedOneWithoutInvoicesInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceCreateManyOrderInputEnvelope = {
    data: Enumerable<InvoiceCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutOrderInput = {
    update: XOR<AccountUpdateWithoutOrderInput, AccountUncheckedUpdateWithoutOrderInput>
    create: XOR<AccountCreateWithoutOrderInput, AccountUncheckedCreateWithoutOrderInput>
  }

  export type AccountUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CouponUpsertWithoutOrdersInput = {
    update: XOR<CouponUpdateWithoutOrdersInput, CouponUncheckedUpdateWithoutOrdersInput>
    create: XOR<CouponCreateWithoutOrdersInput, CouponUncheckedCreateWithoutOrdersInput>
  }

  export type CouponUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutCouponsNestedInput
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutUserNestedInput
    account_user?: AccountUserUncheckedUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAddressUpsertWithoutOrdersInput = {
    update: XOR<UserAddressUpdateWithoutOrdersInput, UserAddressUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserAddressCreateWithoutOrdersInput, UserAddressUncheckedCreateWithoutOrdersInput>
  }

  export type UserAddressUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUser_addressesNestedInput
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusUpsertWithoutOrdersInput = {
    update: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
  }

  export type OrderStatusUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpsertWithoutOrdersInput = {
    update: XOR<CampaignUpdateWithoutOrdersInput, CampaignUncheckedUpdateWithoutOrdersInput>
    create: XOR<CampaignCreateWithoutOrdersInput, CampaignUncheckedCreateWithoutOrdersInput>
  }

  export type CampaignUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_items?: CampaignItemUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrder_itemsInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type OrderCreateWithoutOrder_statusInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrder_statusInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrder_statusInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrder_statusInput, OrderUncheckedCreateWithoutOrder_statusInput>
  }

  export type OrderCreateManyOrder_statusInputEnvelope = {
    data: Enumerable<OrderCreateManyOrder_statusInput>
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutOrder_statusInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrder_statusInput, OrderUncheckedUpdateWithoutOrder_statusInput>
    create: XOR<OrderCreateWithoutOrder_statusInput, OrderUncheckedCreateWithoutOrder_statusInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrder_statusInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrder_statusInput, OrderUncheckedUpdateWithoutOrder_statusInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrder_statusInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type AccountCreateWithoutCustomersInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutCustomersInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutCustomersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCustomersInput, AccountUncheckedCreateWithoutCustomersInput>
  }

  export type AccountUpsertWithoutCustomersInput = {
    update: XOR<AccountUpdateWithoutCustomersInput, AccountUncheckedUpdateWithoutCustomersInput>
    create: XOR<AccountCreateWithoutCustomersInput, AccountUncheckedCreateWithoutCustomersInput>
  }

  export type AccountUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderCreateWithoutOrder_itemsInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    invoice?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrder_itemsInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    invoice?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrder_itemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrder_itemsInput, OrderUncheckedCreateWithoutOrder_itemsInput>
  }

  export type ItemCreateWithoutOrder_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutOrder_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutOrder_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutOrder_itemsInput, ItemUncheckedCreateWithoutOrder_itemsInput>
  }

  export type OrderUpsertWithoutOrder_itemsInput = {
    update: XOR<OrderUpdateWithoutOrder_itemsInput, OrderUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<OrderCreateWithoutOrder_itemsInput, OrderUncheckedCreateWithoutOrder_itemsInput>
  }

  export type OrderUpdateWithoutOrder_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrder_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ItemUpsertWithoutOrder_itemsInput = {
    update: XOR<ItemUpdateWithoutOrder_itemsInput, ItemUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<ItemCreateWithoutOrder_itemsInput, ItemUncheckedCreateWithoutOrder_itemsInput>
  }

  export type ItemUpdateWithoutOrder_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutOrder_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type OrderCreateWithoutInvoiceInput = {
    id?: string
    external_id?: number | null
    code: string
    account: AccountCreateNestedOneWithoutOrderInput
    total: number
    coupon?: CouponCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    user_address: UserAddressCreateNestedOneWithoutOrdersInput
    is_read?: boolean
    order_status: OrderStatusCreateNestedOneWithoutOrdersInput
    campaign?: CampaignCreateNestedOneWithoutOrdersInput
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order_items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type AccountCreateWithoutInvoicesInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutInvoicesInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutInvoicesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
  }

  export type OrderUpsertWithoutInvoiceInput = {
    update: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type OrderUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AccountUpsertWithoutInvoicesInput = {
    update: XOR<AccountUpdateWithoutInvoicesInput, AccountUncheckedUpdateWithoutInvoicesInput>
    create: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
  }

  export type AccountUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeviceUserCreateWithoutDeviceInput = {
    user: UserCreateNestedOneWithoutDevice_userInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUncheckedCreateWithoutDeviceInput = {
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserCreateOrConnectWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserCreateManyDeviceInputEnvelope = {
    data: Enumerable<DeviceUserCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type PushNotificationCreateWithoutDeviceInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutPush_notificationInput
    title: string
    subject: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUncheckedCreateWithoutDeviceInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateOrConnectWithoutDeviceInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutDeviceInput, PushNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type PushNotificationCreateManyDeviceInputEnvelope = {
    data: Enumerable<PushNotificationCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type SmsNotificationCreateWithoutDeviceInput = {
    id?: string
    notification: NotificationsCreateNestedOneWithoutSms_notificationInput
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUncheckedCreateWithoutDeviceInput = {
    id?: string
    notification_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationCreateOrConnectWithoutDeviceInput = {
    where: SmsNotificationWhereUniqueInput
    create: XOR<SmsNotificationCreateWithoutDeviceInput, SmsNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type SmsNotificationCreateManyDeviceInputEnvelope = {
    data: Enumerable<SmsNotificationCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type DeviceNotificationCreateWithoutDeviceInput = {
    notification: NotificationsCreateNestedOneWithoutDevice_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUncheckedCreateWithoutDeviceInput = {
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateOrConnectWithoutDeviceInput = {
    where: DeviceNotificationWhereUniqueInput
    create: XOR<DeviceNotificationCreateWithoutDeviceInput, DeviceNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceNotificationCreateManyDeviceInputEnvelope = {
    data: Enumerable<DeviceNotificationCreateManyDeviceInput>
    skipDuplicates?: boolean
  }

  export type DeviceUserUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    update: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceUserCreateWithoutDeviceInput, DeviceUserUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceUserUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceUserWhereUniqueInput
    data: XOR<DeviceUserUpdateWithoutDeviceInput, DeviceUserUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceUserUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceUserScalarWhereInput
    data: XOR<DeviceUserUpdateManyMutationInput, DeviceUserUncheckedUpdateManyWithoutDevice_userInput>
  }

  export type PushNotificationUpsertWithWhereUniqueWithoutDeviceInput = {
    where: PushNotificationWhereUniqueInput
    update: XOR<PushNotificationUpdateWithoutDeviceInput, PushNotificationUncheckedUpdateWithoutDeviceInput>
    create: XOR<PushNotificationCreateWithoutDeviceInput, PushNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type PushNotificationUpdateWithWhereUniqueWithoutDeviceInput = {
    where: PushNotificationWhereUniqueInput
    data: XOR<PushNotificationUpdateWithoutDeviceInput, PushNotificationUncheckedUpdateWithoutDeviceInput>
  }

  export type PushNotificationUpdateManyWithWhereWithoutDeviceInput = {
    where: PushNotificationScalarWhereInput
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyWithoutPush_notificationInput>
  }

  export type PushNotificationScalarWhereInput = {
    AND?: Enumerable<PushNotificationScalarWhereInput>
    OR?: Enumerable<PushNotificationScalarWhereInput>
    NOT?: Enumerable<PushNotificationScalarWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    title?: StringFilter | string
    subject?: StringFilter | string
    send?: StringNullableFilter | string | null
    device_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type SmsNotificationUpsertWithWhereUniqueWithoutDeviceInput = {
    where: SmsNotificationWhereUniqueInput
    update: XOR<SmsNotificationUpdateWithoutDeviceInput, SmsNotificationUncheckedUpdateWithoutDeviceInput>
    create: XOR<SmsNotificationCreateWithoutDeviceInput, SmsNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type SmsNotificationUpdateWithWhereUniqueWithoutDeviceInput = {
    where: SmsNotificationWhereUniqueInput
    data: XOR<SmsNotificationUpdateWithoutDeviceInput, SmsNotificationUncheckedUpdateWithoutDeviceInput>
  }

  export type SmsNotificationUpdateManyWithWhereWithoutDeviceInput = {
    where: SmsNotificationScalarWhereInput
    data: XOR<SmsNotificationUpdateManyMutationInput, SmsNotificationUncheckedUpdateManyWithoutSms_notificationInput>
  }

  export type SmsNotificationScalarWhereInput = {
    AND?: Enumerable<SmsNotificationScalarWhereInput>
    OR?: Enumerable<SmsNotificationScalarWhereInput>
    NOT?: Enumerable<SmsNotificationScalarWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    device_id?: StringFilter | string
    to?: StringFilter | string
    subject?: StringFilter | string
    body?: StringFilter | string
    send?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceNotificationUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceNotificationWhereUniqueInput
    update: XOR<DeviceNotificationUpdateWithoutDeviceInput, DeviceNotificationUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceNotificationCreateWithoutDeviceInput, DeviceNotificationUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceNotificationUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceNotificationWhereUniqueInput
    data: XOR<DeviceNotificationUpdateWithoutDeviceInput, DeviceNotificationUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceNotificationUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceNotificationScalarWhereInput
    data: XOR<DeviceNotificationUpdateManyMutationInput, DeviceNotificationUncheckedUpdateManyWithoutDevice_notificationInput>
  }

  export type DeviceNotificationScalarWhereInput = {
    AND?: Enumerable<DeviceNotificationScalarWhereInput>
    OR?: Enumerable<DeviceNotificationScalarWhereInput>
    NOT?: Enumerable<DeviceNotificationScalarWhereInput>
    device_id?: StringFilter | string
    notification_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type DeviceCreateWithoutDevice_userInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDevice_userInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDevice_userInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
  }

  export type UserCreateWithoutDevice_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    account_user?: AccountUserCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevice_userInput = {
    id?: string
    name: string
    email: string
    password: string
    whatsapp?: string | null
    phone?: string | null
    cpf_cnpj?: string | null
    photo?: string | null
    gender?: GenderType
    birthdate?: Date | string | null
    google_id?: string | null
    apple_id?: string | null
    facebook_id?: string | null
    rd_station_id?: string | null
    rd_station_sync?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lastLogin?: Date | string
    account_user?: AccountUserUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    user_addresses?: UserAddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevice_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
  }

  export type DeviceUpsertWithoutDevice_userInput = {
    update: XOR<DeviceUpdateWithoutDevice_userInput, DeviceUncheckedUpdateWithoutDevice_userInput>
    create: XOR<DeviceCreateWithoutDevice_userInput, DeviceUncheckedCreateWithoutDevice_userInput>
  }

  export type DeviceUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserUpsertWithoutDevice_userInput = {
    update: XOR<UserUpdateWithoutDevice_userInput, UserUncheckedUpdateWithoutDevice_userInput>
    create: XOR<UserCreateWithoutDevice_userInput, UserUncheckedCreateWithoutDevice_userInput>
  }

  export type UserUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    account_user?: AccountUserUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevice_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    apple_id?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_id?: NullableStringFieldUpdateOperationsInput | string | null
    rd_station_sync?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: DateTimeFieldUpdateOperationsInput | Date | string
    account_user?: AccountUserUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    user_addresses?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SmsNotificationCreateWithoutNotificationInput = {
    id?: string
    device: DeviceCreateNestedOneWithoutSms_notificationInput
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUncheckedCreateWithoutNotificationInput = {
    id?: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationCreateOrConnectWithoutNotificationInput = {
    where: SmsNotificationWhereUniqueInput
    create: XOR<SmsNotificationCreateWithoutNotificationInput, SmsNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type SmsNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<SmsNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type EmailNotificationCreateWithoutNotificationInput = {
    id?: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationUncheckedCreateWithoutNotificationInput = {
    id?: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationCreateOrConnectWithoutNotificationInput = {
    where: EmailNotificationWhereUniqueInput
    create: XOR<EmailNotificationCreateWithoutNotificationInput, EmailNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type EmailNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<EmailNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type PushNotificationCreateWithoutNotificationInput = {
    id?: string
    title: string
    subject: string
    send?: string | null
    device: DeviceCreateNestedOneWithoutPush_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationUncheckedCreateWithoutNotificationInput = {
    id?: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateOrConnectWithoutNotificationInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutNotificationInput, PushNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type PushNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<PushNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type DeviceNotificationCreateWithoutNotificationInput = {
    device: DeviceCreateNestedOneWithoutDevice_notificationInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationUncheckedCreateWithoutNotificationInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateOrConnectWithoutNotificationInput = {
    where: DeviceNotificationWhereUniqueInput
    create: XOR<DeviceNotificationCreateWithoutNotificationInput, DeviceNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type DeviceNotificationCreateManyNotificationInputEnvelope = {
    data: Enumerable<DeviceNotificationCreateManyNotificationInput>
    skipDuplicates?: boolean
  }

  export type SmsNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: SmsNotificationWhereUniqueInput
    update: XOR<SmsNotificationUpdateWithoutNotificationInput, SmsNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<SmsNotificationCreateWithoutNotificationInput, SmsNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type SmsNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: SmsNotificationWhereUniqueInput
    data: XOR<SmsNotificationUpdateWithoutNotificationInput, SmsNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type SmsNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: SmsNotificationScalarWhereInput
    data: XOR<SmsNotificationUpdateManyMutationInput, SmsNotificationUncheckedUpdateManyWithoutSms_notificationInput>
  }

  export type EmailNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: EmailNotificationWhereUniqueInput
    update: XOR<EmailNotificationUpdateWithoutNotificationInput, EmailNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<EmailNotificationCreateWithoutNotificationInput, EmailNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type EmailNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: EmailNotificationWhereUniqueInput
    data: XOR<EmailNotificationUpdateWithoutNotificationInput, EmailNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type EmailNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: EmailNotificationScalarWhereInput
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyWithoutEmail_notificationInput>
  }

  export type EmailNotificationScalarWhereInput = {
    AND?: Enumerable<EmailNotificationScalarWhereInput>
    OR?: Enumerable<EmailNotificationScalarWhereInput>
    NOT?: Enumerable<EmailNotificationScalarWhereInput>
    id?: StringFilter | string
    notification_id?: StringFilter | string
    to?: StringFilter | string
    from?: StringFilter | string
    from_name?: StringFilter | string
    cc?: StringNullableFilter | string | null
    bcc?: StringNullableFilter | string | null
    type?: EnumEmailTypeNotificationFilter | EmailTypeNotification
    subject?: StringFilter | string
    body?: StringFilter | string
    url_callback?: StringFilter | string
    opened?: StringNullableFilter | string | null
    clicked?: StringNullableFilter | string | null
    failed?: StringNullableFilter | string | null
    error_description?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PushNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: PushNotificationWhereUniqueInput
    update: XOR<PushNotificationUpdateWithoutNotificationInput, PushNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<PushNotificationCreateWithoutNotificationInput, PushNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type PushNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: PushNotificationWhereUniqueInput
    data: XOR<PushNotificationUpdateWithoutNotificationInput, PushNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type PushNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: PushNotificationScalarWhereInput
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyWithoutPush_notificationInput>
  }

  export type DeviceNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: DeviceNotificationWhereUniqueInput
    update: XOR<DeviceNotificationUpdateWithoutNotificationInput, DeviceNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<DeviceNotificationCreateWithoutNotificationInput, DeviceNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type DeviceNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: DeviceNotificationWhereUniqueInput
    data: XOR<DeviceNotificationUpdateWithoutNotificationInput, DeviceNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type DeviceNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: DeviceNotificationScalarWhereInput
    data: XOR<DeviceNotificationUpdateManyMutationInput, DeviceNotificationUncheckedUpdateManyWithoutDevice_notificationInput>
  }

  export type NotificationsCreateWithoutEmail_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutEmail_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutEmail_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
  }

  export type NotificationsUpsertWithoutEmail_notificationInput = {
    update: XOR<NotificationsUpdateWithoutEmail_notificationInput, NotificationsUncheckedUpdateWithoutEmail_notificationInput>
    create: XOR<NotificationsCreateWithoutEmail_notificationInput, NotificationsUncheckedCreateWithoutEmail_notificationInput>
  }

  export type NotificationsUpdateWithoutEmail_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutEmail_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsCreateWithoutSms_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutSms_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutSms_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
  }

  export type DeviceCreateWithoutSms_notificationInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSms_notificationInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSms_notificationInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
  }

  export type NotificationsUpsertWithoutSms_notificationInput = {
    update: XOR<NotificationsUpdateWithoutSms_notificationInput, NotificationsUncheckedUpdateWithoutSms_notificationInput>
    create: XOR<NotificationsCreateWithoutSms_notificationInput, NotificationsUncheckedCreateWithoutSms_notificationInput>
  }

  export type NotificationsUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type DeviceUpsertWithoutSms_notificationInput = {
    update: XOR<DeviceUpdateWithoutSms_notificationInput, DeviceUncheckedUpdateWithoutSms_notificationInput>
    create: XOR<DeviceCreateWithoutSms_notificationInput, DeviceUncheckedCreateWithoutSms_notificationInput>
  }

  export type DeviceUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type NotificationsCreateWithoutPush_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutPush_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutPush_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
  }

  export type DeviceCreateWithoutPush_notificationInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutPush_notificationInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
    device_notification?: DeviceNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutPush_notificationInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
  }

  export type NotificationsUpsertWithoutPush_notificationInput = {
    update: XOR<NotificationsUpdateWithoutPush_notificationInput, NotificationsUncheckedUpdateWithoutPush_notificationInput>
    create: XOR<NotificationsCreateWithoutPush_notificationInput, NotificationsUncheckedCreateWithoutPush_notificationInput>
  }

  export type NotificationsUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type DeviceUpsertWithoutPush_notificationInput = {
    update: XOR<DeviceUpdateWithoutPush_notificationInput, DeviceUncheckedUpdateWithoutPush_notificationInput>
    create: XOR<DeviceCreateWithoutPush_notificationInput, DeviceUncheckedCreateWithoutPush_notificationInput>
  }

  export type DeviceUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    device_notification?: DeviceNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateWithoutDevice_notificationInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDevice_notificationInput = {
    id?: string
    external_id?: number | null
    device_physical_id: string
    platform: PlatformType
    version: string
    token_notification: string
    created_at?: Date | string
    updated_at?: Date | string
    device_user?: DeviceUserUncheckedCreateNestedManyWithoutDeviceInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutDeviceInput
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDevice_notificationInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
  }

  export type NotificationsCreateWithoutDevice_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutDevice_notificationInput = {
    id?: string
    title: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    type: TypeNotification
    sms_notification?: SmsNotificationUncheckedCreateNestedManyWithoutNotificationInput
    email_notification?: EmailNotificationUncheckedCreateNestedManyWithoutNotificationInput
    push_notification?: PushNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationsCreateOrConnectWithoutDevice_notificationInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
  }

  export type DeviceUpsertWithoutDevice_notificationInput = {
    update: XOR<DeviceUpdateWithoutDevice_notificationInput, DeviceUncheckedUpdateWithoutDevice_notificationInput>
    create: XOR<DeviceCreateWithoutDevice_notificationInput, DeviceUncheckedCreateWithoutDevice_notificationInput>
  }

  export type DeviceUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_physical_id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | PlatformType
    version?: StringFieldUpdateOperationsInput | string
    token_notification?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_user?: DeviceUserUncheckedUpdateManyWithoutDeviceNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutDeviceNestedInput
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type NotificationsUpsertWithoutDevice_notificationInput = {
    update: XOR<NotificationsUpdateWithoutDevice_notificationInput, NotificationsUncheckedUpdateWithoutDevice_notificationInput>
    create: XOR<NotificationsCreateWithoutDevice_notificationInput, NotificationsUncheckedCreateWithoutDevice_notificationInput>
  }

  export type NotificationsUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutDevice_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | TypeNotification
    sms_notification?: SmsNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    email_notification?: EmailNotificationUncheckedUpdateManyWithoutNotificationNestedInput
    push_notification?: PushNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type PaymentCycleCreateWithoutPlansInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCycleUncheckedCreateWithoutPlansInput = {
    id?: string
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCycleCreateOrConnectWithoutPlansInput = {
    where: PaymentCycleWhereUniqueInput
    create: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
  }

  export type AccountCreateWithoutPlanInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutPlanInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutPlanInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPlanInput, AccountUncheckedCreateWithoutPlanInput>
  }

  export type AccountCreateManyPlanInputEnvelope = {
    data: Enumerable<AccountCreateManyPlanInput>
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    account: AccountCreateNestedOneWithoutSubscriptionInput
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyPlanInput>
    skipDuplicates?: boolean
  }

  export type PaymentCycleUpsertWithoutPlansInput = {
    update: XOR<PaymentCycleUpdateWithoutPlansInput, PaymentCycleUncheckedUpdateWithoutPlansInput>
    create: XOR<PaymentCycleCreateWithoutPlansInput, PaymentCycleUncheckedCreateWithoutPlansInput>
  }

  export type PaymentCycleUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCycleUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutPlanInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutPlanInput, AccountUncheckedUpdateWithoutPlanInput>
    create: XOR<AccountCreateWithoutPlanInput, AccountUncheckedCreateWithoutPlanInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutPlanInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutPlanInput, AccountUncheckedUpdateWithoutPlanInput>
  }

  export type AccountUpdateManyWithWhereWithoutPlanInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    email?: StringFilter | string
    cpf_cnpj?: StringNullableFilter | string | null
    market_name?: StringFilter | string
    phone?: StringNullableFilter | string | null
    whatsapp?: StringNullableFilter | string | null
    logo?: StringNullableFilter | string | null
    person_type?: EnumPersonTypeFilter | PersonType
    site?: StringNullableFilter | string | null
    social_reason?: StringNullableFilter | string | null
    facebook_url?: StringNullableFilter | string | null
    instagram_url?: StringNullableFilter | string | null
    banner?: StringNullableFilter | string | null
    gender?: EnumGenderTypeFilter | GenderType
    street?: StringFilter | string
    number?: StringFilter | string
    complement?: StringNullableFilter | string | null
    district?: StringFilter | string
    city?: StringFilter | string
    state?: StringFilter | string
    zipcode?: StringFilter | string
    plan_id?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    domain?: StringFilter | string
    isActive?: BoolFilter | boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PlanCreateWithoutPayment_cycleInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    account?: AccountCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutPayment_cycleInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    account?: AccountUncheckedCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutPayment_cycleInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutPayment_cycleInput, PlanUncheckedCreateWithoutPayment_cycleInput>
  }

  export type PlanCreateManyPayment_cycleInputEnvelope = {
    data: Enumerable<PlanCreateManyPayment_cycleInput>
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithWhereUniqueWithoutPayment_cycleInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutPayment_cycleInput, PlanUncheckedUpdateWithoutPayment_cycleInput>
    create: XOR<PlanCreateWithoutPayment_cycleInput, PlanUncheckedCreateWithoutPayment_cycleInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutPayment_cycleInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutPayment_cycleInput, PlanUncheckedUpdateWithoutPayment_cycleInput>
  }

  export type PlanUpdateManyWithWhereWithoutPayment_cycleInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutPlansInput>
  }

  export type PlanScalarWhereInput = {
    AND?: Enumerable<PlanScalarWhereInput>
    OR?: Enumerable<PlanScalarWhereInput>
    NOT?: Enumerable<PlanScalarWhereInput>
    id?: StringFilter | string
    external_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    description?: StringFilter | string
    slug?: StringFilter | string
    price?: FloatFilter | number
    max_users?: IntFilter | number
    max_labels?: IntFilter | number
    payment_cycle_id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type PlanCreateWithoutSubscriptionInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle: PaymentCycleCreateNestedOneWithoutPlansInput
    account?: AccountCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    payment_cycle_id: string
    account?: AccountUncheckedCreateNestedManyWithoutPlanInput
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanCreateOrConnectWithoutSubscriptionInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
  }

  export type AccountCreateWithoutSubscriptionInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemCreateNestedManyWithoutAccountInput
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    stock_items?: StockItemUncheckedCreateNestedManyWithoutAccountInput
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutSubscriptionInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type PlanUpsertWithoutSubscriptionInput = {
    update: XOR<PlanUpdateWithoutSubscriptionInput, PlanUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
  }

  export type PlanUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle?: PaymentCycleUpdateOneRequiredWithoutPlansNestedInput
    account?: AccountUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    payment_cycle_id?: StringFieldUpdateOperationsInput | string
    account?: AccountUncheckedUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithoutSubscriptionInput = {
    update: XOR<AccountUpdateWithoutSubscriptionInput, AccountUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<AccountCreateWithoutSubscriptionInput, AccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type AccountUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCreateWithoutStock_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutStock_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutStock_itemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutStock_itemsInput, ItemUncheckedCreateWithoutStock_itemsInput>
  }

  export type AccountCreateWithoutStock_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan?: PlanCreateNestedOneWithoutAccountInput
    subscription?: SubscriptionCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryCreateNestedManyWithoutAccountInput
    account_users?: AccountUserCreateNestedManyWithoutAccountInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    domain: string
    items?: ItemCreateNestedManyWithoutAccountInput
    coupons?: CouponCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationCreateNestedOneWithoutAccountInput
    customers?: CustomerCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountUncheckedCreateWithoutStock_itemsInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    campaign?: CampaignUncheckedCreateNestedManyWithoutAccountInput
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    plan_id?: string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutAccountInput
    created_at?: Date | string
    updated_at?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutAccountInput
    account_activities?: AccountActivitiesUncheckedCreateNestedManyWithoutAccountInput
    account_deliveries?: AccountDeliveryUncheckedCreateNestedManyWithoutAccountInput
    account_users?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    domain: string
    items?: ItemUncheckedCreateNestedManyWithoutAccountInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAccountInput
    account_configuration?: AccountConfigurationUncheckedCreateNestedOneWithoutAccountInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountInput
    isActive?: boolean
  }

  export type AccountCreateOrConnectWithoutStock_itemsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutStock_itemsInput, AccountUncheckedCreateWithoutStock_itemsInput>
  }

  export type ItemUpsertWithoutStock_itemsInput = {
    update: XOR<ItemUpdateWithoutStock_itemsInput, ItemUncheckedUpdateWithoutStock_itemsInput>
    create: XOR<ItemCreateWithoutStock_itemsInput, ItemUncheckedCreateWithoutStock_itemsInput>
  }

  export type ItemUpdateWithoutStock_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutStock_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type AccountUpsertWithoutStock_itemsInput = {
    update: XOR<AccountUpdateWithoutStock_itemsInput, AccountUncheckedUpdateWithoutStock_itemsInput>
    create: XOR<AccountCreateWithoutStock_itemsInput, AccountUncheckedCreateWithoutStock_itemsInput>
  }

  export type AccountUpdateWithoutStock_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneWithoutAccountNestedInput
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutStock_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemCreateWithoutStock_historyInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    winery?: WineryCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutStock_historyInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutStock_historyInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutStock_historyInput, ItemUncheckedCreateWithoutStock_historyInput>
  }

  export type ItemUpsertWithoutStock_historyInput = {
    update: XOR<ItemUpdateWithoutStock_historyInput, ItemUncheckedUpdateWithoutStock_historyInput>
    create: XOR<ItemCreateWithoutStock_historyInput, ItemUncheckedCreateWithoutStock_historyInput>
  }

  export type ItemUpdateWithoutStock_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutStock_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateWithoutWineryInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    item_type: ItemTypeCreateNestedOneWithoutItemsInput
    country?: CountryCreateNestedOneWithoutItemsInput
    region?: RegionCreateNestedOneWithoutItemsInput
    harvest?: string | null
    no_harvest?: boolean
    wine_type?: WineTypeCreateNestedOneWithoutItemsInput
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account: AccountCreateNestedOneWithoutItemsInput
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeCreateNestedManyWithoutItemInput
    order_items?: OrderItemCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemCreateNestedManyWithoutItemInput
    stock_items?: StockItemCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutWineryInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    item_grape?: ItemGrapeUncheckedCreateNestedManyWithoutItemInput
    order_items?: OrderItemUncheckedCreateNestedManyWithoutItemInput
    campaign_items?: CampaignItemUncheckedCreateNestedManyWithoutItemInput
    stock_items?: StockItemUncheckedCreateNestedManyWithoutItemInput
    stock_history?: StockHistoryUncheckedCreateNestedManyWithoutItemInput
    ItemTag?: ItemTagUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutWineryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutWineryInput, ItemUncheckedCreateWithoutWineryInput>
  }

  export type ItemCreateManyWineryInputEnvelope = {
    data: Enumerable<ItemCreateManyWineryInput>
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutWineryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutWineryInput, ItemUncheckedUpdateWithoutWineryInput>
    create: XOR<ItemCreateWithoutWineryInput, ItemUncheckedCreateWithoutWineryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutWineryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutWineryInput, ItemUncheckedUpdateWithoutWineryInput>
  }

  export type ItemUpdateManyWithWhereWithoutWineryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type CampaignCreateManyAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    campaign_type_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateManyAccountInput = {
    id?: string
    plan_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderCreateManyAccountInput = {
    id?: string
    external_id?: number | null
    code: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesCreateManyAccountInput = {
    activities_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryCreateManyAccountInput = {
    delivery_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountUserCreateManyAccountInput = {
    id?: string
    user_id: string
    role_id: string
  }

  export type InvoiceCreateManyAccountInput = {
    id?: string
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockItemCreateManyAccountInput = {
    item_id: string
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type ItemCreateManyAccountInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponCreateManyAccountInput = {
    id?: string
    code: string
    dicount_type: CouponDiscountType
    discount_value: number
    couponUse_type: CouponUseType
    inital_date?: Date | string
    expiration_date?: Date | string | null
    min_value?: number | null
    max_value?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerCreateManyAccountInput = {
    id?: string
    email: string
    mobile_phone: string
    phone: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    origin_registration: CustomerOriginRegistration
    cpf_cnpj: string
    note: string
    converted?: boolean
  }

  export type CampaignUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type?: CampaignTypeUpdateOneRequiredWithoutCampaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCampaignNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign_type_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUpdateWithoutAccountInput = {
    activities?: ActivitiesUpdateOneRequiredWithoutAccount_activitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateWithoutAccountInput = {
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateManyWithoutAccount_activitiesInput = {
    activities_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryUpdateWithoutAccountInput = {
    delivery?: DeliveryUpdateOneRequiredWithoutAccount_deliveriesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryUncheckedUpdateWithoutAccountInput = {
    delivery_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryUncheckedUpdateManyWithoutAccount_deliveriesInput = {
    delivery_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAccount_userNestedInput
    role?: RoleUpdateOneRequiredWithoutAccountUserNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserUncheckedUpdateManyWithoutAccount_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemUpdateWithoutAccountInput = {
    item?: ItemUpdateOneRequiredWithoutStock_itemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockItemUncheckedUpdateWithoutAccountInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockItemUncheckedUpdateManyWithoutStock_itemsInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ItemUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateManyWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    dicount_type?: EnumCouponDiscountTypeFieldUpdateOperationsInput | CouponDiscountType
    discount_value?: FloatFieldUpdateOperationsInput | number
    couponUse_type?: EnumCouponUseTypeFieldUpdateOperationsInput | CouponUseType
    inital_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    min_value?: NullableFloatFieldUpdateOperationsInput | number | null
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile_phone?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFieldUpdateOperationsInput | CustomerOriginRegistration
    cpf_cnpj?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile_phone?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFieldUpdateOperationsInput | CustomerOriginRegistration
    cpf_cnpj?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerUncheckedUpdateManyWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile_phone?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    origin_registration?: EnumCustomerOriginRegistrationFieldUpdateOperationsInput | CustomerOriginRegistration
    cpf_cnpj?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountActivitiesCreateManyActivitiesInput = {
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountActivitiesUpdateWithoutActivitiesInput = {
    account?: AccountUpdateOneRequiredWithoutAccount_activitiesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountActivitiesUncheckedUpdateWithoutActivitiesInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryCreateManyDeliveryInput = {
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountDeliveryUpdateWithoutDeliveryInput = {
    account?: AccountUpdateOneRequiredWithoutAccount_deliveriesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeliveryUncheckedUpdateWithoutDeliveryInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserCreateManyUserInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountUserCreateManyUserInput = {
    id?: string
    account_id: string
    role_id: string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserAddressCreateManyUserInput = {
    id?: string
    name?: string | null
    street: string
    number: string
    district: string
    state: string
    complement?: string | null
    additional_information?: string | null
    city: string
    zip_code: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUpdateWithoutUserInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_userNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateWithoutUserInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateManyWithoutDevice_userInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_usersNestedInput
    role?: RoleUpdateOneRequiredWithoutAccountUserNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserUncheckedUpdateManyWithoutAccount_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    orders?: OrderUpdateManyWithoutUser_addressNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutUser_addressNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateManyWithoutUser_addressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    additional_information?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    zip_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyUser_addressInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateWithoutUser_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUser_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RolePermissionCreateManyPermissionInput = {
    role_id: string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRolePermissionInput = {
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyRoleInput = {
    permission_id: string
  }

  export type AccountUserCreateManyRoleInput = {
    id?: string
    account_id: string
    user_id: string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    permission?: PermisionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permission_id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutAccount_usersNestedInput
    user?: UserUpdateOneRequiredWithoutAccount_userNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUserUncheckedUpdateManyWithoutAccountUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateManyCampaignInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignItemCreateManyCampaignInput = {
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CampaignItemUpdateWithoutCampaignInput = {
    item?: ItemUpdateOneRequiredWithoutCampaign_itemsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignItemUncheckedUpdateWithoutCampaignInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignItemUncheckedUpdateManyWithoutCampaign_itemsInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyCampaign_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    discount_value?: number | null
    discount_type?: CampaignTypeDiscount | null
    start_date?: Date | string | null
    expiration_date?: Date | string | null
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CampaignUpdateWithoutCampaign_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: AccountUpdateOneRequiredWithoutCampaignNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCampaignNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaign_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_type?: NullableEnumCampaignTypeDiscountFieldUpdateOperationsInput | CampaignTypeDiscount | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type OrderCreateManyCouponInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    user_id: string
    user_address_id: string
    is_read?: boolean
    order_status_id: string
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order_status_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ItemGrapeCreateManyItemInput = {
    grape_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderItemCreateManyItemInput = {
    order_id: string
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type CampaignItemCreateManyItemInput = {
    campaign_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockItemCreateManyItemInput = {
    account_id: string
    quantity: number
    min_quantity?: number
    max_quantity?: number
  }

  export type StockHistoryCreateManyItemInput = {
    id?: string
    reason?: string | null
    operation: StockHistoryType
    quantity: number
    date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagCreateManyItemInput = {
    tag_id: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeUpdateWithoutItemInput = {
    grape?: GrapeUpdateOneRequiredWithoutItem_grapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeUncheckedUpdateWithoutItemInput = {
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeUncheckedUpdateManyWithoutItem_grapeInput = {
    grape_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutItemInput = {
    order?: OrderUpdateOneRequiredWithoutOrder_itemsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateWithoutItemInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrder_itemsInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignItemUpdateWithoutItemInput = {
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_itemsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignItemUncheckedUpdateWithoutItemInput = {
    campaign_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemUpdateWithoutItemInput = {
    account?: AccountUpdateOneRequiredWithoutStock_itemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockItemUncheckedUpdateWithoutItemInput = {
    account_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    min_quantity?: IntFieldUpdateOperationsInput | number
    max_quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StockHistoryUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: EnumStockHistoryTypeFieldUpdateOperationsInput | StockHistoryType
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: EnumStockHistoryTypeFieldUpdateOperationsInput | StockHistoryType
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockHistoryUncheckedUpdateManyWithoutStock_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: EnumStockHistoryTypeFieldUpdateOperationsInput | StockHistoryType
    quantity?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagUpdateWithoutItemInput = {
    tag?: TagUpdateOneRequiredWithoutItemTagNestedInput
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagUncheckedUpdateWithoutItemInput = {
    tag_id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagUncheckedUpdateManyWithoutItemTagInput = {
    tag_id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyItem_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemUpdateWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItem_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemTagCreateManyTagInput = {
    item_id: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemTagUpdateWithoutTagInput = {
    item?: ItemUpdateOneRequiredWithoutItemTagNestedInput
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTagUncheckedUpdateWithoutTagInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeCreateManyGrapeInput = {
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemGrapeUpdateWithoutGrapeInput = {
    item?: ItemUpdateOneRequiredWithoutItem_grapeNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGrapeUncheckedUpdateWithoutGrapeInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateCreateManyCountryInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemCreateManyCountryInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StateUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    regions?: RegionUpdateManyWithoutStateNestedInput
    cities?: CityUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    regions?: RegionUncheckedUpdateManyWithoutStateNestedInput
    cities?: CityUncheckedUpdateManyWithoutStateNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StateUncheckedUpdateManyWithoutStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type RegionCreateManyStateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CityCreateManyStateInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUpdateManyWithoutRegionNestedInput
    items?: ItemUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    subregion?: SubRegionUncheckedUpdateManyWithoutRegionNestedInput
    items?: ItemUncheckedUpdateManyWithoutRegionNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionCreateManyRegionInput = {
    id?: string
    external_id?: number | null
    name: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemCreateManyRegionInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubRegionUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubRegionUncheckedUpdateManyWithoutSubregionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyWine_typeInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    winery_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemUpdateWithoutWine_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    winery?: WineryUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutWine_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    winery_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }

  export type OrderItemCreateManyOrderInput = {
    item_id: string
    created_at?: Date | string
    updated_at?: Date | string
    price: number
    quantity: number
  }

  export type InvoiceCreateManyOrderInput = {
    id?: string
    account_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    item?: ItemUpdateOneRequiredWithoutOrder_itemsNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutInvoicesNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyOrder_statusInput = {
    id?: string
    external_id?: number | null
    code: string
    account_id: string
    total: number
    coupon_id?: string | null
    user_id: string
    user_address_id: string
    is_read?: boolean
    campaign_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateWithoutOrder_statusInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutOrderNestedInput
    total?: FloatFieldUpdateOperationsInput | number
    coupon?: CouponUpdateOneWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    user_address?: UserAddressUpdateOneRequiredWithoutOrdersNestedInput
    is_read?: BoolFieldUpdateOperationsInput | boolean
    campaign?: CampaignUpdateOneWithoutOrdersNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrder_statusInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    coupon_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_address_id?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DeviceUserCreateManyDeviceInput = {
    user_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateManyDeviceInput = {
    id?: string
    notification_id: string
    title: string
    subject: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationCreateManyDeviceInput = {
    id?: string
    notification_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateManyDeviceInput = {
    notification_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceUserUpdateWithoutDeviceInput = {
    user?: UserUpdateOneRequiredWithoutDevice_userNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUserUncheckedUpdateWithoutDeviceInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutPush_notificationNestedInput
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateManyWithoutPush_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: NotificationsUpdateOneRequiredWithoutSms_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateManyWithoutSms_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUpdateWithoutDeviceInput = {
    notification?: NotificationsUpdateOneRequiredWithoutDevice_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateWithoutDeviceInput = {
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateManyWithoutDevice_notificationInput = {
    notification_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationCreateManyNotificationInput = {
    id?: string
    device_id: string
    to: string
    subject: string
    body: string
    send?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmailNotificationCreateManyNotificationInput = {
    id?: string
    to: string
    from: string
    from_name: string
    cc?: string | null
    bcc?: string | null
    type: EmailTypeNotification
    subject: string
    body: string
    url_callback: string
    opened?: string | null
    clicked?: string | null
    failed?: string | null
    error_description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PushNotificationCreateManyNotificationInput = {
    id?: string
    title: string
    subject: string
    send?: string | null
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeviceNotificationCreateManyNotificationInput = {
    device_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SmsNotificationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneRequiredWithoutSms_notificationNestedInput
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmsNotificationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateManyWithoutEmail_notificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    from_name?: StringFieldUpdateOperationsInput | string
    cc?: NullableStringFieldUpdateOperationsInput | string | null
    bcc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEmailTypeNotificationFieldUpdateOperationsInput | EmailTypeNotification
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    url_callback?: StringFieldUpdateOperationsInput | string
    opened?: NullableStringFieldUpdateOperationsInput | string | null
    clicked?: NullableStringFieldUpdateOperationsInput | string | null
    failed?: NullableStringFieldUpdateOperationsInput | string | null
    error_description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutPush_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    send?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUpdateWithoutNotificationInput = {
    device?: DeviceUpdateOneRequiredWithoutDevice_notificationNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceNotificationUncheckedUpdateWithoutNotificationInput = {
    device_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyPlanInput = {
    id?: string
    external_id?: number | null
    name: string
    email: string
    cpf_cnpj?: string | null
    market_name: string
    phone?: string | null
    whatsapp?: string | null
    logo?: string | null
    person_type: PersonType
    site?: string | null
    social_reason?: string | null
    facebook_url?: string | null
    instagram_url?: string | null
    banner?: string | null
    gender: GenderType
    street: string
    number: string
    complement?: string | null
    district: string
    city: string
    state: string
    zipcode: string
    created_at?: Date | string
    updated_at?: Date | string
    domain: string
    isActive?: boolean
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    account_id: string
    due: Date | string
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    subscription?: SubscriptionUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUpdateManyWithoutAccountNestedInput
    items?: ItemUpdateManyWithoutAccountNestedInput
    coupons?: CouponUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUpdateOneWithoutAccountNestedInput
    customers?: CustomerUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    campaign?: CampaignUncheckedUpdateManyWithoutAccountNestedInput
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutAccountNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutAccountNestedInput
    account_activities?: AccountActivitiesUncheckedUpdateManyWithoutAccountNestedInput
    account_deliveries?: AccountDeliveryUncheckedUpdateManyWithoutAccountNestedInput
    account_users?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    domain?: StringFieldUpdateOperationsInput | string
    stock_items?: StockItemUncheckedUpdateManyWithoutAccountNestedInput
    items?: ItemUncheckedUpdateManyWithoutAccountNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAccountNestedInput
    account_configuration?: AccountConfigurationUncheckedUpdateOneWithoutAccountNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountNestedInput
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf_cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    market_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | PersonType
    site?: NullableStringFieldUpdateOperationsInput | string | null
    social_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderTypeFieldUpdateOperationsInput | GenderType
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    district?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutSubscriptionNestedInput
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    due?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateManyPayment_cycleInput = {
    id?: string
    external_id?: number | null
    name: string
    description: string
    slug: string
    price: number
    max_users: number
    max_labels: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUpdateWithoutPayment_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    account?: AccountUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutPayment_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    account?: AccountUncheckedUpdateManyWithoutPlanNestedInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    max_users?: IntFieldUpdateOperationsInput | number
    max_labels?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyWineryInput = {
    id?: string
    external_id?: number | null
    name: string
    description?: string | null
    type_id: string
    country_id?: string | null
    region_id?: string | null
    harvest?: string | null
    no_harvest?: boolean
    wine_type_id?: string | null
    alcohol_percentage?: Decimal | DecimalJsLike | number | string | null
    price: number
    promotional_price?: number | null
    photo?: string | null
    account_id: string
    is_active?: boolean
    control_stock?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ItemUpdateWithoutWineryInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: ItemTypeUpdateOneRequiredWithoutItemsNestedInput
    country?: CountryUpdateOneWithoutItemsNestedInput
    region?: RegionUpdateOneWithoutItemsNestedInput
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type?: WineTypeUpdateOneWithoutItemsNestedInput
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutItemsNestedInput
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutWineryInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: StringFieldUpdateOperationsInput | string
    country_id?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: NullableStringFieldUpdateOperationsInput | string | null
    harvest?: NullableStringFieldUpdateOperationsInput | string | null
    no_harvest?: BoolFieldUpdateOperationsInput | boolean
    wine_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    alcohol_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: FloatFieldUpdateOperationsInput | number
    promotional_price?: NullableFloatFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    control_stock?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item_grape?: ItemGrapeUncheckedUpdateManyWithoutItemNestedInput
    order_items?: OrderItemUncheckedUpdateManyWithoutItemNestedInput
    campaign_items?: CampaignItemUncheckedUpdateManyWithoutItemNestedInput
    stock_items?: StockItemUncheckedUpdateManyWithoutItemNestedInput
    stock_history?: StockHistoryUncheckedUpdateManyWithoutItemNestedInput
    ItemTag?: ItemTagUncheckedUpdateManyWithoutItemNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}